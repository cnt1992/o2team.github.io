{"title":"Aotu.io","description":"凹凸实验室(Aotu.io) 始建于2015年，是一个年轻基情的技术社区组织。<br/>O2面向多终端技术体系，致力于构建沉淀与分享包括但不限于交互、页面制作技巧、前端开发、原生APP开发等方面的专业知识及案例。","language":"zh-cn","link":"https://aotu.io","pubDate":"Mon, 26 Aug 2019 09:00:00 GMT","lastBuildDate":"Tue, 27 Aug 2019 10:53:26 GMT","generator":"hexo-generator-json-feed","webMaster":"凹凸实验室","items":[{"title":"京东 PC 首页 2019 改版前端总结","link":"https://aotu.io/notes/2019/08/26/jdindex_2019/","description":"距离上次首页改版，已有2年3个月零五天。相比上次改版对首页整体框架、开发流程的大刀阔斧（前两次改版总结传送门：2016版，2017版），这次的改版看起来显得有点像跳水——没什么水花。在站在巨人肩膀上的小巨人的叮咛与期盼下，这次改版在延续17版的框架与流程的基础之上，为首页的稳定性、安全性、视觉体验、无障碍体验方面见缝插针地添了砖加了瓦。 本文将从以下几个方面进行阐述 引入强类型校验 升级资源构建方案 接入自动化测试 完善监控体系 优化页面加载体验：骨架屏 优化信息无障碍体验 引入强类型校验在性能几近无懈可击的情况下，我们决定从稳定性入手，为项目引入强类型校验，弥补 JavaScript 这种弱类型语言在不可预测性上的缺陷。 强类型语言 TypeScript 已发布6年有余，国内应用的开发者也在慢慢增长。一般来说，业务开发周期短，迭代频繁，TypeScript 的引入对于很大一部分开发者来说是一件费时费力的事，用的话业务可以上线，不用的话业务照样可以上线，因此团队极少在业务生产中应用。但秉承着不折腾不凹凸的理念，新版首页不负使命的，进行了基于 TS 的重构。 做 TS 重构并不难，把 js 后缀改成 ts 就好了。完。 当然是开玩笑的啦！显然，这样的 TS 是没有意义的。只有严格遵循 TS 标准的代码才能最大化 TS 的效用。在项目中，我们对 TS 的检查开启 strict 模式，每次提交时，都会对代码做一次完整的检查，只要有 TS 报错就禁止提交，旨在向成员传达一个信息——写强类型语言就该有觉悟，否则就是耍流氓。 没有深入使用过 TS 的同学在前期可能会感到人生的艰难，但这些都是为你好为了保证代码的健壮性。例如，在以往难以定位、查找的 window 全局变量的管理上，十分另开发者头疼，而引入了 TS 之后，只要对全局变量进行了接口设置，各个组件中再也不会出现多余或是未知全局变量的情况。再例如，在写一个拥有 get、set 方法的存贮类的时候，TS 能帮助检测获取内容的类型： 123456789101112131415161718192021222324interface MemoryState &#123; testa: boolean testb: string&#125;class Controller &#123; state: StateType constructor() &#123; this.state = &#123; state: &#123;&#125;, &#125; &#125; get&lt;K extends MemoryStateKeys&gt;(key: K) &#123; return this.state.memory[key] &#125; set&lt;K extends MemoryStateKeys&gt;(key: K, value: MemoryState[K]): MemoryState[K] &#123; this.state.memory[key] = value return value &#125;&#125; 当我们使用 new Controller().get(&quot;testb&quot;) 的时候，TS 能够在开发阶段检测 testb 是否是 string 类型。通过 TS 的检测插件，我们能放心的使用 string 类型对象的方法，简化繁复的判断逻辑，同时保证代码在获取到非期望值时能及时通过报错发现，一切的输入和输出都是稳定可预测的，四舍五入就是在写代码的时候自动走了一部分测试，为项目的开发与迭代保驾护航。 升级资源构建方案旧版首页项目使用的构建工具 Athena，推进了开发流程自动化，但是涉及到定制化的构建流程时，由于 Athena 的通用性，不方便直接做改动。首页包含直出、同步、异步三种类型的资源引用，需对资源的打包进行特殊处理，所以我们这次回归 Webpack，基于 Webpack 4.0 做了以下的方案优化： 发布流程优化 旧版的发布流程中，每次发布需要对改动的文件进行 diff 检查，避免产生不符合预期的误改动。Webpack 默认打包机制的特点，是根据模块的打包顺序为每一个模块提供一个按顺序编号的 ID，对文件的包进行依赖管理。旧版首页的入口文件包含依赖包管理的执行环境，因此任何一个包引入顺序发生变动时，入口文件都会发生变动。以上的打包机制会出现一个文件发生引入顺序变动时，可能会影响到编译后的几个甚至十几个文件发生变动的情况，而这些文件中的逻辑代码部分其实并不需要更新，这就降低了 diff 代码的准确性，使得这一中间检查措施失去了原本的意义。首页缓存机制与资源懒加载机制使得静态资源在发布时，需要对发生变动的文件进行 CDN 缓存清除的操作，也就意味着，改动文件越多，需要清除的缓存资源链接就越多，而链接越多，由于缓存清除不同步引起的资源异步加载出错的概率就越高，每次上线发布都存在一定的风险。 为了减少发布风险，新版首页的打包机制改变了 Webpack 的打包逻辑，通过设置，每个模块不再通过顺序编号的 ID 管理依赖包，而是通过文件目录生成哈希编码的专有 ID，并把依赖包的执行环境从入口文件中抽离出来作为一个单独的资源请求，这样每次改动文件时，可以只针对改动的文件 diff，剔除了其他非预期的 diff 情况。通过新的构建方案，使代码改动控制在预期的范围内，保证部署流程的稳定。 项目架构优化旧版页面的性能优化方案中，包含了部分 js 片段直出，这些代码是项目所依赖的基函数，需要在核心 js 代码执行之前启动。但这样的方案也有一些不尽人意的地方： 由于代码需要直出于页面模版中，考虑到兼容性，这些代码不能使用一些高级语法，每次改动都需要确保自己的代码没有兼容问题，导致维护成本巨高。同时，首页页面模版由后台负责管理，直出代码的改动需经过后台发布，迭代成本略高，风险也不小； 由于打包的限制，核心代码与模板代码存在同一套公用代码，代码冗余不说，一旦这部分代码发生变动还需要同时修改与发布两部分的代码，使得代码的维护成本增高。 针对以上问题，新版中我们将这些代码重新放入核心代码，模板代码中不再承载任何逻辑代码，迭代发版不再涉及模版发布，只需进行静态资源的发布即可，开发过程中统一使用 JS 高级语法，去除人工维护兼容语法代码的过程。 至此，我们通过增强资源打包的可预测性、以及优化项目资源架构两个方面对资源的发布方案进行了优化。 接入自动化测试一个页面开发完成后，在对其进行提测之前，对页面进行自测是一个必不可少的环节。一方面，保证页面所开发的功能能正常运作；另一方面，保证在对一个功能进行开发时，没有影响到页面其他区域功能的正常使用。一般情况下，自测需要人为手动地进行测试，但这样会有两个缺点，第一，需要测试的区域数量过于巨大，相似的测试操作过于频繁，浪费了人力，也影响了测试的效率；第二，人为的自测由于没有统一的自测规范，因此在测试时很容易有所疏漏，从而忽视了一些看似微小，实则影响巨大的 bug，花费了大量的时间，却得不到自测所需要的效果。针对这种情况，我们产生了实施自动化测试的想法。以新版首页为例，我们通过使用 Nightwatch.js，为新版首页创建了一个自动化测试脚本，对新版的首页的73项项目进行自动化测试。 结果显示，通过自动化测试，在不到三分钟的时间内，完成了对新版首页73项指标的测试，这也意味着，若要通过自动化测试，来对任一页面进行自测，自测的时间都可控制在五分钟以内，并且准确性更高。将自动化测试应用在发布前以及上线后5分钟之内，及时检查测试用例，保证每次发版的安全。 完善监控体系旧版页面的前端监控体系覆盖了浏览器信息、页面加载测速、楼层隐藏方面，但信息通知较为滞后，且仅覆盖了页面 onLoad 时间，收到告警信息时，无法做到快速定位问题。 参考京东购物小程序目前的监控机制，新版首页针对代码报错、接口可用性增加了上报监控。 代码报错监控：BadJS通过 BadJS 框架捕获页面报错，并分析处理报错信息上报至京东 BadJS 服务。通过上报数据，我们可以得到报错的详细信息以及发生次数。通过分析上报数据，可以发现一些潜在的问题，及时修复，保证首页代码的健壮性。同时根据上报数，还可以预估出一个问题所造成的影响范围，便于预估损失。 业务可用性监控：UMPUMP 又称可用率上报，可定义丰富的判定规则，包含调用次数、可用率、和 TP 三个维度，在此基础上还可以对这三个维度进行环比，以减少误报的可能性，近期系统还上线了红灯告警-语音通知功能。UMP 一般被用来监听接口可用性，但对于首页来说，除了接口，还需关注楼层隐藏的情况。目前的兜底方案中，每个楼层中的模块接口兜底全部失效的情况下，会隐藏当前楼层。楼层一旦发生隐藏，则意味着出现了比较严重的问题，需快速关注并解决。UMP 可做到触发告警规则时，1分钟之内即推送通知，精确到接口，便于及时发现问题，及时止损。需要注意的是，如何设置一套能够较为精确反映问题发生、减少假报警的阈值尤为重要，毕竟狼来了喊多了，也就等于没有监控。 测速上报这一部分延用了旧版的 Athena 测速上报方案，并对一些与业务数据上报重复的部分做了减法，同时增加了接口的测速上报，完善故障追溯数据体系。 优化页面加载体验：骨架屏旧版页面懒加载的占位方案采用了统一区域 loading 动画的方式，这种方式的优势在于复用成本低，适配性强。但如果遇到较大面积的模块或是模块较为密集的情况时，区域 loading 动画的体验有所下降————要么是空白区域过大，要么是 loading 动画过于密集，模块加载过程造成的视觉差异感知较为明显。而对于 PC 首页来说，空白区域过大是主要存在的问题。 低网速下旧版首页的 loading 体验 这次改版，我们引入了骨架屏方案，最终目的是以灰色豆腐块的形式尽量缩小真实模块结构与加载占位之间的视觉差异。执行起来可以按照视觉差异分为两种对应关系： 弱对应关系：只对模块进行标题、子项等主要内容进行块化处理，复用成本较高，适配性中等； 强对应关系：以视觉效果为基础，对子项进一步作出图片、文案的块化处理，针对占位面积较大、内容更为复杂的子项进行更细化的块化拆分，复用成本低，适配性高。 考虑到首页的特殊性，我们最终选择了强对应关系的骨架屏方案，并为了可扩展性，使用的是使用样式渲染的骨架屏，而不是直接使用图片占位。除了开发成本的上升，页面首屏加载代码量也有所增加。 项目结构使用骨架屏所要达到的效果包含以下几点： 提前占位，在页面的加载中滚动条不发生较为明显的跳动； 页面快速滚动时也能看到骨架屏样式的占位。 也就意味着骨架屏的内容需要与页面做同步加载处理，结合懒加载组件，骨架屏组件需提前作为 loading 结构传入，并保证样式在页面渲染的第一时间进行加载，否则就失去了骨架屏的意义。 每个需要骨架屏样式的组件，单独拆分出一个 placeholder 组件。组件内的占位结构包含两类样式——颜色与尺寸定位，加上容器外层的动画效果样式。颜色样式全页公用，尺寸定位样式与正式组件公用： 尺寸定位样式与正式组件公用的目的是为了在将来组件样式发生变化时，保证骨架屏与正式样式的统一修改，避免出现样式修改上的遗漏，但同时增加了样式的维护成本。同时样式编写与拆分的过程中也需要开发者注意兼容骨架屏的样式，例如需要占位豆腐块的容器间距 padding、margin 的选择都很重要。因此这次首页的骨架屏尝试并不适合快速复用至其他项目。 新版首页骨架屏 loading 体验 优化信息无障碍体验互联网信息无障碍，即针对视力障碍人士所提供的辅助。系统级别的辅助主要依赖读屏工具，读屏工具可以解决网页端信息无障碍 60%的阻碍，剩余的 40%需要在网页开发的过程中由开发者进行体验优化。 没有做任何信息无障碍处理的网页，使用读屏工具访问时一般存在以下几个问题： 多余无用信息的播报，例如：跳转链接、图片名称； 弹出浮层无法访问； 懒加载内容直接跳过； 为了造福国内一百一十人中的一个视障人士（数据来自这里），本次改版，我们决定在 PC 首页开启京东商城桌面端首个信息无障碍实践。 桌面端视障用户的操作主要通过键盘进行。针对刚才提出的几个问题，PC 首页初步的无障碍体验优化方案分为几个阶段。 第一阶段，语义化一切 tab 可及的元素——包含页面外跳转链接的 a 标签统一添加 aria-label 属性，以便读屏软件能够简化读取元素信息； 第二阶段，保证页面主要模块的访问——懒加载内容占位容器将 tab-index 设置为大于 0 的值，使得 tab 键能够遍历到，以便触发页面懒加载，避免 tab 直接跳过； 第三阶段，扩展带弹出浮层等元素的操作——针对无障碍增加弹出浮层交互逻辑，入口增加 aria-haspopup 属性，告诉读屏软件这里是弹出浮层的入口，将 tab-index 设置为大于 0 的数值使得 tab 操作可聚焦到，浮层弹出后焦点自动聚焦至浮层； 第四阶段，为视障用户额外增加快捷跳转——参考 Google 搜索结果页，可在页面的顶部，增加一些隐藏的快捷跳转。PC 首页本次对搜索框以及底部的“为你推荐”位置增加了隐藏跳转链接，只有使用键盘操作的用户能够定位到。 对于商城页面来说，第一阶段能满足基本的内容访问，而如果能做到第四阶段，才能算一个完整的信息无障碍网站。商城业务中，无障碍体验一直缺乏相应的规范与测试流程，因此通过本次 PC 首页的改版实践，输出了一份针对商城频道页的信息无障碍开发规范，内容包含： 访问路径设计规范 语义化规范 读屏测试规范 未来将借由这份规范，陆续实现商城其他业务的无障碍体验优化。 综上，本次改版对于开发者来说最大的变化，就是本地开发体验更加舒服、发布风险有所降低、故障追溯更加完善，而对用户来说，页面加载跳动感大大减小，视障用户的体验终于得以照顾到。作为商城桌面端的入口与门面，首页的改进一定不止于此，希望每一次的改版都能有一丝的优化，使得首页这个项目趋近完美。","pubDate":"Mon, 26 Aug 2019 09:00:00 GMT","guid":"https://aotu.io/notes/2019/08/26/jdindex_2019/","category":"PC"},{"title":"使用 React Hooks 重构你的小程序","link":"https://aotu.io/notes/2019/07/10/taro-hooks/","description":"本文由余澈在 GMTC 全球大前端技术 2019 的演讲：《使用 React Hooks 重构你的小程序》整理而成。 背景一直关注小程序开发的朋友应该会注意到，最开始小程序就是为了微型创新型业务打造的一个框架，最多只能运行 1m 的包。可是后来发现很多厂商把越来越多的业务搬到了小程序上，小程序的能力也在不断地开放，变得越来越强大。于是后来打包限制上升到了 2m，然后引入了分包，现在已经已经可以上传 8m 的小程序。其实这个体积已经可以实现非常巨型非常复杂的业务了。就从 Taro 的用户来看，例如京东购物小程序和 58 同城小程序不管从代码的数量还是复杂度都不亚于 PC 端业务，所以我们可以说前端开发的复杂度正在向小程序端转移。 而小程序开发其实也是前端开发的一个子集，在整个前端业界，我们又是怎么解决复杂度这个问题的呢？ 首先我们看看 React：React Core Team 成员，同时也是 Redux 的作者 Dan Abramov 在 2018 年的 ReactConf 向大家首次介绍了 React Hooks。React Hooks 是为了解决 Class Component 的一些问题而引入的： Class Component 组件间的逻辑难以复用。因为 JavaScript 不像 Go 或 C++ 一样，Class 可以多重继承，类的逻辑的复用就成了一个问题； 复杂组件难以理解。Class Component 经常会在生命周期做一些数据获取事件监听的副作用函数，这样的情况下我们就很难把组件拆分为更小的力度； Class 令人迷惑。很多新手应该会被 Class 组件绑定事件的 this 迷惑过，绑定事件可以用 bind，可以直接写箭头函数，也可以写类属性函数，但到底哪种方法才是最好的呢？而到了 ES 2018，class 还有多种语法，例如装饰器，例如 private fileds 这些奇奇怪怪的语法也为新手增加了更多的困惑。 而对于 Vue 而言也有相同的问题，Vue 的作者尤玉溪老师在 VueConf China 2019 也给 Vue 3.0 引入了一个叫 Functional-based API 的概念，它是受 React Hooks 启发而增加的新 API。由于 Vue 2.0 组件组合的模式是对象字面量形式，所以 Functional-based API 可以作为 Mixins 的替代，配合新的响应式 API 作为新的组件组合模式。那么对于 Vue 3.0 我们还知之甚少，以后的 API 也有可能改变，但或许是英雄所见略同，React 和 Vue 对于降低前端开发复杂度这一问题都不约而同地选择了 Hooks 这一方案，这到底是为什么呢？ 我们可以一下之前的组件组合方案，首先是 Mixins，红色圈的 Mixins，黄色的是组件，我们知道 Mixins 其实就是把多个对象组合成一个对象，Mixins 的过程就有点像调用 Object.assgin 方法。那 Mixins 有什么问题呢？首先是命名空间耦合，如果多个对象同名参数，这些参数就会耦合在一起；其次由于 Mixins 必须是运行时才能知道具体有什么参数，所以是 TypeScript 是无法做静态检查的；第三是组件参数不清晰，在 Mixins 中组件的 props 和其他参数没什么两样，很容易被其它的 Mixins 覆盖掉。 为了解决 Mixins 的问题，后来发展出了高阶组件（HOC）的方式，高阶组件就和图里一样，一个组件嵌套着另外的组件。它的确解决了 Mixins 的一些问题，例如命名空间解耦，由于每次都会生成新组件，就不存在命名空间问题了；其次它也能很好地做静态检查；但它依然没有办法处理组件 props 的问题，props 还是有可能会在高阶组件中被更改；而且它还有了新的问题，每多用一次高阶组件，都会多出一个组件实例。 最后我们来看一下 Hooks，紫色的圈圈是 Hooks，就像图里一样，Hooks 都在同一个组件里，Hooks 之间还可以相互调用。因为 Hooks 跑在一个普通函数式组件里，所以他肯定是没有命名空间的问题，同时 TypeScript 也能对普通函数做很好的静态检查，而且 Hooks 也不能更改组件的 Props，传入的是啥最后可用的就是啥；最后 Hooks 也不会生成新的组件，所以他是单组件实例。 在 Taro 1.3 版本，我们实现了一大堆特性，其中的重头戏就是 React Hooks 的支持。虽然 React Hooks 正式稳定的时间并不长，但我们认为这个特性能有效地简化开发模式，提升开发效率和开发体验。即便 Hooks 的生态和最佳实践还尚未完善，但我们相信未来 Hooks 会成为 React 开发模式的主流，也会深刻地影响其它框架未来的 API 构成。所以在 Taro 的规划中我们也把 Hooks 放在了很重要的位置。 什么是 Hooks？相信笔者扯了那么多，大家对 Hooks 应该产生了一些兴趣，那什么是 Hooks 呢？简单来说，Hooks 就是一组在 React 组件中运行的函数，让你在不编写 Class 的情况下使用 state 及其它特性。具体来说，Hooks 可以表现为以下的形式： useState 与内部状态我们可以看一个原生小程序的简单案例，一个简单计数器组件，点击按钮就 + 1，相信每位前端开发朋友都可以轻松地写一个计数器组件。但我们可以稍微改一下代码，把事件处理函数改为箭头函数。如果是这样代码就跑不了了。事实上在原生开发中 this 的问题是一以贯之的，所以我们经常要开个新变量把 this 缓存起来，叫做 self 什么的来避免类似的问题。我们之前也提到过，如果采用 ES6 的 Class 来组织组件同样也会遇到 this 指向不清晰的问题。 12345678910Page(&#123; data: &#123; count: 0 &#125;, increment: () =&gt; &#123; // 这里写箭头函数就跑不了了 this.setData(&#123; count: this.data.count + 1 &#125;) &#125;&#125;) 再来看看我们的 hooks 写法，我们引入了一个叫 useState 的函数，它接受一个初始值参数，返回一个元组，如果是写后端的同学应该对这个模式比较熟悉，就像 Koa 或者 Go 一样，一个函数返回两个值或者说叫一个元组，不过我们返回的第一个参数是当前的状态，一个是设置这个状态的函数，每次调用这个设置状态的 setState 函数都会使得整个组件被重新渲染。然后用 ES6 的结构语法把它俩解构出来使用。 然后我们在定义一个增加的函数，把他绑定到 onClick 事件上。 123456789101112131415161718function Counter () &#123; // 返回一个值和一个设置值的函数 // 每次设置值之后会重新渲染组件 const [ count, setCount ] = useState(0) function increment () &#123; setCount(count + 1) &#125; return ( &lt;View&gt; &lt;Text&gt;You clicked &#123;count&#125; times&lt;/Text&gt; &lt;Button onClick=&#123;increment&#125;&gt; Click me &lt;/Button&gt; &lt;/View&gt; )&#125; 同样是非常简单的代码。如果你熟悉 Taro 之前的版本的话就会知道这样的代码在以前的 Taro 是跑不了的，不过 Taro 1.3 之后事件传参可以传入任何合法值，你如果想直接写箭头函数或者写一个柯里化的函数也是完全没有问题的。 大家可以发现我们使用的 Hooks 就是一个非常简单非常 normal 的函数，没有 this 没有 class，没有类构造函数，没有了 this，再也不会出现那种 this、self 傻傻分不清楚的情况。 大家可以记住这个简单的计数器组件，以后之后讲的很多案例是基于这个组件做的。 useEffect 与副作用接下来我们看一个稍微复杂一些的例子，一个倒计时组件，我们点击按钮就开始倒计时，再点击就停止倒计时。在我们这个组件里有两个变量，start 用于控制是否开始计时，time 就是我们的倒计时时间。这里注意我们需要多次清除 interval，而在现实业务开发中，这个 touchStart 函数可能会复杂得多，一不小心就会提前清除 interval 或忘记清除。 123456789101112131415161718192021Page(&#123; data: &#123; time: 60 &#125;, start: false, toggleStart () &#123; this.start = !this.start if (this.start) &#123; this.interval = setInterval(() =&gt; &#123; this.setData(&#123; time: this.data.time - 1 &#125;) &#125;, 1000) &#125; else &#123; clearInterval(this.interval) &#125; &#125;, onUnload () &#123; clearInterval(this.interval) &#125;&#125;) 12345&lt;view&gt; &lt;button bindtap=\"toggleStart\"&gt; &#123;&#123;time&#125;&#125; &lt;/button&gt;&lt;/view&gt; 而我们 Hooks 的例子会是这样：我们引入了一个 useEffect 函数。之前我们提到过，每次调用 useState 返回的 setState 函数都会重新调用整个函数，其实就包括了 useEffect 函数，useEffect 接受两个参数。第一个就是副作用，也就是 effect 函数，他不接受也不返回任何参数。第二个参数是依赖数组，当数组中的变量变化时就会调用，第一个参数 effect 函数。Effect 函数还可以返回一个函数，这个函数在下一次 effect 函数被调用时或每次组件被注销时或者就会调用，我们可以在这里清楚掉一些事件的订阅或者 interval 之类可能会导致内存泄露的行为。在我们这个例子中，当 start 每次变化就会重新跑一次 effect 函数，每隔一秒会设置一次 time 的值让它减一，但这样的写法是有问题的。 123456789101112131415161718192021function Counter () &#123; const [ start, setStart ] = useState(false) const [ time, setTime ] = useState(60) useEffect(() =&gt; &#123; // effect 函数，不接受也不返回任何参数 let interval if (start) &#123; interval = setInterval(() =&gt; &#123; // setTime(time - 1) ❌ time 在 effect 闭包函数里是拿不到准确值的 setTime(t =&gt; t -1) // ✅ 在 setTime 的回调函数参数里可以拿到对应 state 的最新值 &#125;, 1000) &#125; return () =&gt; clearInterval(interval) // clean-up 函数，当前组件被注销时调用 &#125;, [ start ]) // 依赖数组，当数组中变量变化时会调用 effect 函数 return ( &lt;View&gt; &lt;Button onClick=&#123;() =&gt; setStart(!start)&#125;&gt;&#123;time&#125;&lt;/Button&gt; &lt;/View&gt; )&#125; 因为我们在 setInterval 这个函数的闭包中，我们捕捉到 time 这个变量的值不能和最新的值对应得上，time 的值有可能在我们意料之外地被更改了多次。解决的方案也很简单，之前我们提到过 useState 返回的 setState 方法，可以接受一个函数作为参数，而这个函数的参数，就是 state 最新的值，所以只要我们传入一个函数就好了。这是其中一种方法。 还有另一种方法是使用 useRef Hooks，useRef 可以返回一个可变的引用，它会生成一个对象，对象里这个有 current 属性，而 current 的值是可变的。在我们这个例子里，每次更改 currentTime.current 都是同步的，而且 currentTime 是一个引用，所以 currentTime.current 一定是可控的。 123456789101112131415161718192021function Counter () &#123; const [ start, setStart ] = useState(false) const [ time, setTime ] = useState(60) const currentTime = useRef(time) // 生成一个可变引用 useEffect(() =&gt; &#123; // effect 函数，不接受也不返回任何参数 let interval if (start) &#123; interval = setInterval(() =&gt; &#123; setTime(currentTime.current--) // currentTime.current 是可变的 &#125;, 1000) &#125; return () =&gt; clearInterval(interval) // clean-up 函数，当前组件被注销时调用 &#125;, [ start ]) // 依赖数组，当数组中变量变化时会调用 effect 函数 return ( &lt;View&gt; &lt;Button onClick=&#123;() =&gt; setStart(!start)&#125;&gt;&#123;time&#125;&lt;/Button&gt; &lt;/View&gt; )&#125; 虽然说我们可以 useRef 来解决这个问题，但是没必要这样做。因为 setTime 传递一个回调函数的方法显然可读性更高。真正有必要的是把我们的 interval 变量作为一个 ref，我们在函数最顶层的作用域把 interval 作为一个 ref，这样我们就可以在这个函数的任何一个地方把他清除，而原来的代码中我们把 interval 作为一个普通的变量放在 effect 函数里，这样如果我们有一个事件也需要清除 interval，这就没法做到了。但是用 useRef 生成可变引用就没有这个限制。 1234567891011121314151617181920function Counter () &#123; const [ start, setStart ] = useState(false) const [ time, setTime ] = useState(60) const interval = useRef() // interval 可以在这个作用域里任何地方清除和设置 useEffect(() =&gt; &#123; // effect 函数，不接受也不返回任何参数 if (start) &#123; interval.current = setInterval(() =&gt; &#123; setTime(t =&gt; t - 1) // ✅ 在 setTime 的回调函数参数里可以拿到对应 state 的最新值 &#125;, 1000) &#125; return () =&gt; clearInterval(interval.current) // clean-up 函数，当前组件被注销时调用 &#125;, [ start ]) // 依赖数组，当数组中变量变化时会调用 effect 函数 return ( &lt;View&gt; &lt;Button onClick=&#123;() =&gt; setStart(!start)&#125;&gt;&#123;time&#125;&lt;/Button&gt; &lt;/View&gt; )&#125; useContext 与跨组件通信接下来我们再来看一个跨组件通信的例子，例如我们有三个组件，page 组件有一个 child 组件，child 组件有一个 counter 组件，而我们 counter 组件的 count 值和 setCount 函数，是由 page 组件传递下来的。这种情况在一个复杂业务的开发中也经常能遇到，在原生小程序开发中我们应该怎么做呢？ 我们需要手动的把我们 counter 的值和函数手动地依次地传递下去，而这样的传递必须是显式的，你需要在 JavaScript 中设置 props 的参数，也需要在 WXML 里设置 props 的参数，一个也不能少，少了就跑不动。我们还注意到即便 child 组件没有任何业务逻辑，他也必须要设置一个 triggerEvent 的函数和 props 的类型声明。这样的写法无疑是非常麻烦而且限制很大的。 1234567891011121314151617181920&lt;!-- page.wxml --&gt;&lt;view&gt; &lt;child /&gt;&lt;/view&gt;&lt;!-- child.wxml --&gt;&lt;view&gt; &lt;counter /&gt;&lt;/view&gt;&lt;!-- counter.wxml --&gt;&lt;view&gt; &lt;text&gt; You clicked &#123;&#123;count&#125;&#125; times &lt;/text&gt; &lt;butto bindtap=\"increment\"&gt; Click me &lt;/button&gt;&lt;/view&gt; 1234567891011121314151617181920212223242526272829303132333435// page.jsPage(&#123; data: &#123; count: 0 &#125;, increment () &#123; this.setData(&#123; count: this.data.count + 1 &#125;) &#125;&#125;)// child.jsComponent(&#123; properties: &#123; count: Number &#125;, methods: &#123; increment () &#123; this.triggerEvent('increment') &#125; &#125;&#125;)// counter.jsComponent(&#123; properties: &#123; count: Number &#125;, methods: &#123; increment () &#123; this.triggerEvent('increment') &#125; &#125;&#125;) 而我们可以看看 Hooks 的写法，首先我们用 Taro.createContext 创建一个 context 对象，在我们 page 组件里把我们的 count 和 setCount 函数作为一个对象传入到 Context.Provider 的 value 里。然后在我们的 Counter 组件，我们可以使用 useContext 这个 Hooks 把我们的 count 和 setCount 取出来，就直接可以使用了。 12345678910111213141516171819202122232425262728293031323334export const CounterContext = Taro.createContext(null);// page.jsconst Page = () =&gt; &#123; const [ count, setCount ] = useState(0) return ( &lt;CounterContext.Provider value=&#123;&#123; count, setCount &#125;&#125;&gt; &lt;Child /&gt; &lt;/CounterContext.Provider&gt; );&#125;;// child.jsconst Child = () =&gt; ( &lt;View&gt; &lt;Counter /&gt; &lt;/View&gt;);// counter.jsconst Counter = () =&gt; &#123; const &#123; count, setCount &#125; = useContext(CounterContext) return ( &lt;View&gt; &lt;Text&gt; You clicked &#123;count&#125; times &lt;/Text&gt; &lt;Button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt; Click me &lt;/Button&gt; &lt;/View&gt; )&#125; 大家可以发现使用 Context 的代码比原来的代码精简了很多，参数不需要一级一级地显式传递，child 组件也和事实一样，没有一行多余的逻辑。但精简不是最大的好处。最大的好处是大家可以发现我们的 Context 可以传递一个复杂的对象，熟悉小程序原生开发的同学可能会知道，所有 props 的传递都会被小程序序列化掉，如果传递了一个复杂的对象最终会变成一个 JSON。但是用 Taro 的 context 则没有这层限制，你可以传入一个带有函数的对象，也可以传入像是 imutabale 或者 obserable 这样复杂的对象。在 taro 1.3 我们对 props 系统进行了一次重构，Taro 的 context 和 props 一样，属性传递没有任何限制，想传啥就传啥。 另外一个值得注意的点的是，context 的传递可以无视父级组件的更新策略，在这个例子中即便我们通过 shouldComponentUpdate() 禁止了 child 组件的更新，但 counter 作为它的子组件依然是可以更新的。这个特性可以让我们做性能优化的时候更为灵活一些。 Hooks 在小程序实战讲完了 Hooks 的基本使用，有些同学会觉得：咦，我怎么觉得你这几个东西感觉平平无奇，没什么特别的。但实际上这些基础的 Hooks 单独拿出来看的确不能玩出什么花样，但他们组合起来却能迸发强大的力量。 自定义 Hooks大家在业务开发可能会遇到这样的需求，实现一个双击事件，如果你是从 H5 开发过来的可能会直接写 onDoubleClick，但很遗憾，小程序组件是没有 doubleClick 这个事件的。当然，如果你使用 Taro 又用了 TypeScript 就不会犯这样的错误，编辑器就回直接给你报错 Text 组件没有这个属性。 于是你就自己实现了一个双击事件，代码大概是这样，有一个上次点击的时间作为状态，每次触发单机事件的时候和上次点击的时间做对比，如果间隔过小，那他就是一个双击事件。代码非常简单，但我们不禁就会产生一个问题问题，每一次给一个组件加单击事件，我们就每次都加这么一坨代码吗？ 12345678910111213141516171819202122232425function EditableText (&#123; title &#125;) &#123; const [ lastClickTime, setClickTime ] = useState(0) const [ editing, setEditing ] = useState(false) return ( &lt;View&gt; &#123; editing ? &lt;TextInput editing=&#123;editing&#125; /&gt; : &lt;Text onClick=&#123;e =&gt; &#123; const currentTime = e.timeStamp const gap = currentTime - lastClickTime if (gap &gt; 0 &amp;&amp; gap &lt; 300) &#123; // double click setEditing(true) &#125; setClickTime(currentTime) &#125;&#125; &gt; &#123;title&#125; &lt;/Text&gt; &#125; &lt;/View&gt; )&#125; 这个时候我们就可以写一个自定义 Hooks，代码和原来的代码也差不多，useDoubleClick 不接受任何参数，但当我们调用 useDoubleClick 时候返回一个名为 textOnDoubleClick 的函数，在在 Text 组件的事件传参中，我们再在 textOnDoubleClick 函数中传入一个回调函数，这个回调函数就是触发双击条件时候的函数。当我们给这个自定义 Hooks 做了柯里化之后，我们就可以做到知道 Hook 使用时才暴露回调函数: 123456789101112131415161718192021222324252627282930313233function useDoubleClick () &#123; const [ lastClickTime, setClickTime ] = useState(0) return (callback) =&gt; (e) =&gt; &#123; const currentTime = e.timeStamp const gap = currentTime - lastClickTime if (gap &gt; 0 &amp;&amp; gap &lt; 300) &#123; callback &amp;&amp; callback(e) &#125; setClickTime(currentTime) &#125;&#125;function EditableText (&#123; title &#125;) &#123; const [ editing, setEditing ] = useState(false) const textOnDoubleClick = useDoubleClick() return ( &lt;View&gt; &#123; editing ? &lt;TextInput editing=&#123;editing&#125; /&gt; : &lt;Text onClick=&#123;textOnDoubleClick(() =&gt; setEditing(true) )&#125; &gt; &#123;title&#125; &lt;/Text&gt; &#125; &lt;/View&gt; )&#125; 柯里化函数好像有一点点绕，但一旦我们完成了这一步，这种我们的自定义 hooks 就可以像多次调用： 123456789101112131415function EditableText (&#123; title &#125;) &#123; const textOnDoubleClick = useDoubleClick() const buttonOnDoubleClick = useDoubleClick() // 任何实现单击类型的组件都有自己独立的双击状态 return ( &lt;View&gt; &lt;Text onClick=&#123;textOnDoubleClick(...)&#125;&gt; &#123;title&#125; &lt;/Text&gt; &lt;Button onClick=&#123;buttonOnDoubleClick(...)&#125; /&gt; &lt;/View&gt; )&#125; 每一个大家不妨试想如果按照我们传统的 render props 实现，每次都要多写一个 container 组件，如果用 Mixins 或高阶组件来实现就更麻烦，我们需要基于每个不同类型的组件创造一个新的组件。而使用 Hooks，任何一个实现了单机类型的组件都可以通过我们的自定义 Hook 实现双击效果，不管从它的内部实现来看，还是从它暴露的 API 来看都是非常优雅的。 性能优化接下来我们谈一下性能优化，相信大家也有过这种情况，有一个数组，他只需拿到他的 props 要渲染一次，从此之后他就再也不需要更新了。对于传统而言的 Class Component 我们可以设置 shouldComponentUpdate() 返回 false。 12345678910111213class Numbers extends Component &#123; shouldComponentUpdate () &#123; return false &#125; render () &#123; return &lt;View&gt; &#123; expensive(this.props.array).map(i =&gt; &lt;View&gt;&#123;i&#125;&lt;/View&gt;) &#125; &lt;/View&gt; &#125;&#125; 而对于函数式组件而言，我们也可以做一样的事情。Taro 和 React 一样提供 Taro.memo API，他的第一个参数接受一个函数式组件，第二个参数和我们的 shouldComponentUpdate() 一样，判断组件在什么样的情况下需要更新。如果第二个参数没有传入的话，Taro.memo 的效果就和 Taro.PureComponent 一样，对新旧 props 做一层浅对比，如果浅对比不相等则更新组件。 12345678910111213function Numbers (&#123; array &#125;) &#123; return ( &lt;View&gt; &#123; expensive(array).map( i =&gt; &lt;View&gt;&#123;i&#125;&lt;/View&gt; ) &#125; &lt;/View&gt; )&#125;export default Taro.memo(Numbers, () =&gt; true) 第二种情况我们可以看看我们的老朋友，计数器组件。但是这个计数器组件和老朋友有两点不一样：第一是每次点击 + 1，计数器需要调用 expensive 函数循环 1 亿次才能拿到我们想要的值，第二点是它多了一个 Input 组件。在我们真实的业务开发中，这种情况也很常见：我们的组件可能需要进行一次昂贵的数据处理才能得到最终想要的值，但这个组件又还有多个 state 控制其它的组件。在这种情况下，我们如果正常书写业务逻辑是有性能问题的： 123456789101112131415161718192021function Counter () &#123; const [ count, setCount ] = useState(0) const [val, setValue] = useState('') function expensive() &#123; let sum = 0 for (let i = 0; i &lt; count * 1e9; i++) &#123; sum += i &#125; return sum &#125; return ( &lt;View&gt; &lt;Text&gt;You clicked &#123;expensive()&#125; times&#125;&lt;/Text&gt; &lt;Button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt; Click me &lt;/Button&gt; &lt;Input value=&#123;val&#125; onChange=&#123;event =&gt; setValue(event.detail.value)&#125; /&gt; &lt;/View&gt; )&#125; 因为我们 count 的值跟 Input 的值没有关系，但我们每次改变 Input 的值，就会触发这个组件重新渲染。也就是说这个循环一亿次的 expensive() 函数就会重新调用。这样情况显然是不能接受的。为了解决这个问题，我们可以使用 useMemo API。useMemo 的签名和 useEffect 有点像，区别就在于 useMemo 的第一个函数有返回值，这个函数返回的值同时也是 useMemo 函数的返回值。而第二个参数同样是依赖数组，只有当这个数组的数据变化时候，useMemo 的函数才会重新计算，如果数组没有变化，那就直接从缓存中取数据。在我们这个例子里我们只需要 count 变化才进行计算，而 Input value 变化无需计算。 123456789101112131415161718192021function Counter () &#123; const [ count, setCount ] = useState(0) const [val, setValue] = useState('') const expensive = useMemo(() =&gt; &#123; let sum = 0 for (let i = 0; i &lt; count * 100; i++) &#123; sum += i &#125; return sum &#125;, [ count ]) // ✅ 只有 count 变化时，回调函数才会执行 return ( &lt;View&gt; &lt;Text&gt;You Clicked &#123;expensive&#125; times&lt;/Text&gt; &lt;Button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt; Click me &lt;/Button&gt; &lt;Input value=&#123;val&#125; onChange=&#123;event =&gt; setValue(event.detail.value)&#125; /&gt; &lt;/View&gt; )&#125; 我们刚才提到的两个 memo 的 API ，他的全称其实是 Memoization。由于 Hooks 都是在普通函数中运行的，所以我们要做好性能优化，一定要好好利用缓存和记忆化这一技术。 在计算机科学中，记忆化（Memoization）是一种提高程序运行速度的优化技术。通过储存大计算量函数的返回值，当这个结果再次被需要时将其从缓存提取，而不用再次计算来节省计算时间。 大规模状态管理提到状态管理，React 社区最有名的工具当然是 Redux。在 react-redux@7 中新引用了三个 API: useSelector。它有点像 connect() 函数的第一个参数 mapStateToProps，把数据从 state 中取出来； useStore 。返回 store 本身； useDispatch。返回 store.dispatch。 在 Taro 中其实你也可以使用我们之前提到过的 createContext 和 useContext 直接就把 useStore 和 useDispatch 实现了。而基于 useStore 和 useDispatch 以及 useState，useMemo，useEffect 也可以实现 useSelector。也就是说 react-redux@7 的新 API 全都是普通 Hooks 构建而成的自定义 Hooks。当然我们也把 react-redux@7 的新功能移植到了 @tarojs/redux，在 Taro 1.3 版本你可以直接使用这几个 API。 Hooks 的实现我们现在对 Hooks 已经有了以下的了解，一个合法的 Hooks ，必须满足以下需求才能执行: 只能在函数式函数中调用 只能在函数最顶层中调用 不能在条件语句中调用 不能在循环中调用 不能在嵌套函数中调用 我想请大家思考一下，为什么一个 Hook 函数需要满足以上的需求呢？我想请大家以可以框架开发者的角度去思考下这个问题，而不是以 API 的调用者的角度去逆向地思考。当一个 Hook 函数被调用的时，这个 Hook 函数的内部实现应该可以访问到当前正在执行的组件，但是我们的 Hooks API 的入参却没有传入这个组件，那究竟是怎么样的设计才可以让我们的 hook 函数访问到正在执行的组件，也能够准确地定位自己呢？ 聪明的朋友或许已经猜到了，这些所有线索都指向一个结果，Hooks 必须是一个按顺序执行的函数。也就是说，不管整个组件执行多少次，渲染多少次，组件中 Hooks 的顺序都是不会变的。 我们还知道另外一条规则，Hooks 是 React 函数内部的函数，于是我们就可以知道，要实现 Hooks 最关键的问题在于两个: 找到正在执行的 React 函数 找到正在执行的 Hooks 的顺序。 我们可以设置一个全局的对象叫 CurrentOwner，它有两个属性，第一个是 current，他是正在执行的 Taro 函数，我们可以在组件加载和更新时设置它的值，加载或更新完毕之后再设置为 null；第二个属性是 index，它就是 CurrentOwner.current 中 Hooks 的顺序，每次我们执行一个 Hook 函数就自增 1。 1234567891011const CurrentOwner: &#123; current: null | Component&lt;any, any&gt;, index: number&#125; = &#123; // 正在执行的 Taro 函数, // 在组件加载和重新渲染前设置它的值 current: null, // Taro 函数中 hooks 的顺序 // 每执行一个 Hook 自增 index: 0&#125; 在 React 中其实也有这么一个对象，而且你还可以使用它，它叫做 __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner，也就是说如果你想给 React 15 实现 Hooks，其实也可以做到的。但也正如它的名字一样，如果你用了说不定就被 fire 了，被优化了，所以更好的方案还是直接使用我们 taro。 接下来我们来实现我们的 getHook 函数，同样很简单，如果 CurrenOwner.current 是 null，那这就不是一个合法的 hook 函数，我们直接报错。如果满足条件，我们就把 hook 的 index + 1，接下来我们把组件的 Hooks 都保存在一个数组里，如果 index 大于 Hooks 的长度，说明 Hooks 没有被创造，我们就 push 一个空对象，避免之后取值发生 runtime error。然后我们直接返回我们的 Hook。 1234567891011function getHook (): Hook &#123; if (CurrentOwner.current === null) &#123; throw new Error(`invalid hooks call: hooks can only be called in a taro component.`) &#125; const index = CurrentOwner.index++ // hook 在该 Taro 函数中的 ID const hooks: Hook[] = CurrentOwner.current.hooks // 所有的 hooks if (index &gt;= hooks.length) &#123; // 如果 hook 还没有创建 hooks.push(&#123;&#125; as Hook) // 对象就是 hook 的内部状态 &#125; return hooks[index] // 返回正在执行的 hook 状态&#125; 既然我们已经找到了我们正在执行的 Hooks，完整地实现 Hooks 也就不难了。之前我们讨论过 useState 的签名，现在我们一步一步地看他的实现。 首先如果 initState 是函数，直接执行它。其次调用我们我们之前写好的 getHook 函数，它返回的就是 Hook 的状态。接下来就是 useState 的主逻辑，如果 hook 还没有状态的话，我们就先把正在执行的组件缓存起来，然后 useState 返回的，就是我们的 hook.state, 其实就是一个数组，第一个值当然就是我们 initState，第一个参数是一个函数，它如果是一个函数，我们就执行它，否则就直接把参数赋值给我们 的 hook.state 第一个值，赋值完毕之后我们把当前的组件加入到更新队列，等待更新。 1234567891011121314151617function useState&lt;S&gt; (initialState: S | (() =&gt; S)): [S, Dispatch&lt;SetStateAction&lt;S&gt;&gt;] &#123; if (isFunction(initialState)) &#123; // 如果 initialState 是函数 initialState = initialState() // 就直接执行 &#125; const hook = getHook() as HookState&lt;S&gt; // 找到该函数中对应的 hook if (isUndefined(hook.state)) &#123; // 如果 hook 还没有状态 hook.component = Current.current! // 正在执行的 Taro 函数，缓存起来 hook.state = [ // hook.state 就是我们要返回的元组 initialState, (action) =&gt; &#123; hook.state[0] = isFunction(action) ? action(hook.state[0]) : action enqueueRender(hook.component) // 加入更新队列 &#125; ] &#125; return hook.state // 已经创建 hook 就直接返回&#125; 最后我们把 hook.state 返回出去就大功告成了。 Taro 的 Hooks 总共有八个 API， useState 的实现大家可以发现非常简单，但其实它的代码量和复杂度是所有 Hooks 的实现中第二高的。所以其实 Hooks 也没有什么黑科技，大家可以放心大胆地使用。 总结与展望在 2018 年 Ember.js 的作者提出过一个观点，Compilers are the New Frameworks，编译器即框架。什么意思呢？就拿 React 来举例，单单一个 React 其实没什么用，你还需要配合 create-react-app, eslint-plugin-react-hooks, prettier 等等编译相关的工具最终才能构成一个框架，而这些工具也恰巧是 React Core Team 的人创造的。而这样趋势不仅仅发生在 React 身上，大家可以发现在2018年，尤玉溪老师的主要工作就是开发 vue-cli。而对一些更激进的框架，例如 svelte，它的框架就是编译器，编译器就是框架。 而到了 2019 年，我想提出一个新概念，叫框架即生态。就拿 Taro 来说，使用 Taro 你可以复用 React 生态的东西，同时 Taro 还有 taro doctor，Taro 开发者社区，Taro 物料市场，还有腾讯小程序·云开发等等多个合作伙伴一起构成了 Taro 生态，而整个 Taro 生态才是框架。在过去的半年，我们持续改进并优化了 Taro 框架的表现，以上提到的特性与功能在 Taro 1.3 全部都可以正常使用。而在框架之外，我们也深耕社区，推出了 Taro 物料市场和 Taro 开发者社区，并和腾讯小程序·云开发合作举办了物料开发竞赛。现在，我们诚挚邀请你一起来参与社区贡献，让小程序开发变得更好、更快、更方便： Taro 官网：https://taro.jd.com/ Taro 物料市场：https://taro-ext.jd.com/ Taro 开发者社区：https://taro-club.jd.com/","pubDate":"Wed, 10 Jul 2019 13:00:00 GMT","guid":"https://aotu.io/notes/2019/07/10/taro-hooks/","category":"小程序"},{"title":"邀您参加「Taro x 小程序·云开发」物料开发竞赛","link":"https://aotu.io/notes/2019/07/01/taro-ext-action/","description":"多端统一开发解决方案 Taro 是由凹凸实验室开源、遵循 React 语法规范的多端开发解决方案，截止目前 star 数即将突破两万，受到了前端开发者的广泛关注，成为了当前最受欢迎的小程序多端开发框架之一。开发者只需书写一套代码，通过 Taro 的编译，即可将源代码分别编译出可以在不同端（微信/百度/支付宝/字节跳动/QQ/快应用小程序、H5、React-Native 等）运行的代码，很大程度提高了小程序的开发效率和开发体验。 小程序·云开发提供的一站式开发服务。打通了小程序前端与云资源的链路，让开发者无需管理后端服务架构，即可轻松拥有各种后端能力，极大减轻开发过程中繁杂的后端操作，使小程序开发更简单。告别以前开发小程序需要买服务器、部署后端服务、搭建运维服务等繁琐工作。 随着 Taro 受到越来越多的关注，也涌现了许多 优秀案例 和优秀轮子，他们分散各处，我们希望有个集中的地方让大家快速查找，方便地使用这些轮子而不用重复制造，因此推出了 Taro 物料市场，大家可以分享、学习或使用。 Taro 团队和腾讯云团队一直有着深入的合作，我们可以看到在 Taro 项目初始化的时候提供了“云开发模板”；在 Taro 掘金小册里介绍和使用小程序云开发；在腾讯云的高校公开课里有 Taro 的参与…… 值物料市场上线之际，Taro 团队和腾讯云团队再次合作，联合举办此次 Taro x 小程序·云开发物料上传激励活动 ，Taro 的开发者们只要上传 Taro 开发的包含腾讯云开发能力（例如：云数据库、云存储、云函数）的物料，就可以参与活动，并有机会赢得奖品。 活动时间及评奖方式： 即日起至 2019 年 07 月 30 日，提交物料并被审核通过。 2019 年 8 月 1 日 - 8 月 10 日，竞赛评委将根据物料的完整性、可用性、多端兼容性、评分、下载量、Github Star 等综合权重打分，评选出此次活动的获奖者。 2019 年 8 月 12 日，公布获奖名单，获奖者发送地址给 Taro 团队，Taro 团队按地址发放奖品。 说明：目前物料市场上管理员已经上传的物料欢迎原作者认领。（原作者只需上传自己的物料，管理员看到后会把管理员上传的删除） 奖品设置：一等奖（ 1 名）： 腾讯云代金券3000元 腾讯云精美电脑包 1 个（颜色随机） 凹凸实验室珍藏 T 恤 1 件 二等奖（ 2 名）： 腾讯云代金券1500元 腾讯云Q版蓝牙音箱 1个（颜色随机） 凹凸实验室珍藏 T 恤 1 件 三等奖（ 3 名）： 腾讯云代金券500元 腾讯云抱枕 1 个 凹凸实验室珍藏 T 恤 1 件 参与奖（不限名额）： 腾讯云定制公仔 或 京东Joy公仔 1 个 其他 获奖作者将进入核心开发者交流群，享受 Taro 和云开发核心开发者提供优先的技术支持和 bug 受理。 优秀的作品和获奖作者将得到宣传报道，有助于为简历资质添彩。 参赛方式 登录物料市场 https://taro-ext.jd.com 点击 「发布物料」 填入物料相关信息并提交发布 物料有多种类型，包含组件、项目模版或页面模版、JS SDK、UI库，都可以参与活动，要求使用 Taro 开发 和 小程序·云开发 评委人员 Taro 核心开发团队 小程序云开发 核心开发团队 Taro 联合开发团队 黄轶 Zoom · 前端架构师 许世超 网易严选 · 前端负责人 吴立奇 美的 · 美的官方商城核心开发 · 小程序‘轻松问卷’开发者 其他注意事项 提交的物料都会经过后台审核 完整性、可用性是比较重要的参考维度 感谢感谢腾讯云小伙伴的支持，为我们提供了奖品，欢迎大家体验腾讯云产品。 声明本活动解释权归 Taro 团队和腾讯云团队 相关网址： Taro 官网：https://taro.jd.com Taro 物料市场: https://taro-ext.jd.com Taro 社区：https://taro-club.jd.com GitHub: https://github.com/NervJS/taro","pubDate":"Mon, 01 Jul 2019 13:00:00 GMT","guid":"https://aotu.io/notes/2019/07/01/taro-ext-action/","category":"小程序"},{"title":"Taro 「物料市场」及「交流社区」 惊喜上线","link":"https://aotu.io/notes/2019/06/21/taro-ext-club/","description":"多端统一开发框架 Taro 自 2018 年 6 月开源以来，一直受到业界的广泛关注和支持。 目前，Taro GitHub star 数已经突破了 1.8W。作为研发团队，我们为取得的成绩感到欣喜，但也始终不忘初心。一直以来，我们对 Taro 框架不断完善和优化，近期也即将发布全新的大版本（Taro 1.3），将提供快应用和 QQ 小程序的开发支持，React Hooks 支持，Taro Doctor 等重大特性 (详情)。而与此同时，我们也马不停蹄，对 Taro 进行了全方位的升级，希望给大家带来小小的惊喜。 我们不仅带来了焕然一新的 Taro 官网，还一次性推出了 Taro 物料市场 和 Taro 开发者社区。帮助 Taro 实现从 多端统一开发框架 到 多端统一开发解决方案 的转型。 Taro 物料市场：https://taro-ext.jd.com/Taro 开发者社区：https://taro-club.jd.com/ 物料市场 — “让每一个轮子产生价值”随着 Taro 受到越来越多的关注，许多 Taro 项目也正式投入生产，涵盖包括 电商、工具、服务 等多种类型，也涌现了许多优秀案例。 但项目开发中，开发者都不得不面临重复的逻辑开发，对现有的逻辑进行 Taro 代码的适配等问题，严重影响开发效能。 开源的时代，我们不希望闭门造车，我们诚邀开发者们共同打造完整的 多端适配 生态，一起沉淀优秀的开发物料，进而赋能更多的开发者。 因此，物料市场应运而生。 我们将物料划分为 4 个大类：组件、UI 库、模版、SDK。每个物料都配有说明文档，并对支持的端进行标记，方便接入使用。 物料的获取方式也相当灵活，可通过 ZIP/TAR 包下载，也可直接通过作者提供的 NPM 或 GitHub 地址下载。 此外，还可以对物料进行评论、收藏和打分，这将作为衡量物料质量的一个指标，为筛选物料提供参考。 后续，我们将加入打赏功能，开发者通过发布优质的物料，给与别人便利的同时，自己可以收获一定的奖励。此外，我们还会不断完善物料质量评定标准，制定用户积分体系，等等。这都将促进整个生态更加健康而全面的发展。 如果你对物料市场有任何建议，或有意愿参与物料市场的建设，欢迎随时与我们联系：taro@jd.com。 开发者社区 — “让每一次交流被沉淀”目前，Taro 共收到了 2k 多个 GitHub Issue，并建立了十多个开发交流微信群（每个群上限人数 500）。 我们希望与开发者进行及时且顺畅的交流，更希望每一次的问题答疑、经验交流都能被沉淀，分享给更多开发者，同时，我们渴望开发者之间可以开放互助，因此我们打造了一个全新的开发者社区。 开发者可通过社区多个版块交流问题、共享经验、发布案例，等等。 Taro 社区基于 NodeBB 开发，共设有 12 个版块，包括 Taro、Taro UI 及其对应转换的 8 个端，有效地对内容做了归类。此外，还设置了 新闻 版块，用于发布 Taro 新闻、公告、规划等；招聘 版块，让 Taro 求职者和招聘者快速匹配；灌水 版块，提供一个健康文明的交流（you）平台。 为了加强社区内容的管理，我们沉淀了一套自动化的社区管理解决方案：通过智能分析微信群聊记录，对有效信息进行筛选和整合，自动同步至社区；并使用插件 GitHub Embed 将 GitHub Issue 直接导入，从而打通 GitHub、微信、社区 三方平台，旨在让社区内容更及时、更全面。 如果你对开发者社区有任何建议，或有意愿参与社区的建设与管理工作，欢迎随时与我们联系：taro@jd.com。 官网 — “全新面貌，蓄势待发”开源近一年，Taro 成长了许多。一开始，我们试图用 React 来实现微信小程序开发；而现在，我们期待的是，Taro 在移动端开发、多端适配领域可以无往不利。 Taro 正在经历由内而外的成长，因此，我们对 Taro 品牌进行了全新升级，旨在赋予其独特的品牌风格。 全新的官网将作为品牌化的一个窗口，不仅带来了全新的视觉体验，内容上更是增加了生态能力和业界合作的展示，并丰富了应用案例和学习资料，方便开发者迅速上手 Taro。 愿景这一切仅仅是起步，未来我们还将推出更多平台、工具、服务，努力将 Taro 打造为名副其实的移动端解决方案。 希望通过我们的点滴努力，创造出更好的移动端开发环境，让工作回归简单、让生活日益丰满。 相关网址： Taro 官网：https://taro.jd.com Taro 物料市场: https://taro-ext.jd.com Taro 社区：https://taro-club.jd.com GitHub: https://github.com/NervJS/taro","pubDate":"Fri, 21 Jun 2019 13:00:00 GMT","guid":"https://aotu.io/notes/2019/06/21/taro-ext-club/","category":"小程序"},{"title":"Taro 1.3 震撼升级：全面支持 JSX 语法和 HOOKS","link":"https://aotu.io/notes/2019/06/13/taro-1-3/","description":"在 Taro 1.2 发布之后，Taro 在业界收获了巨大的赞誉和关注：GitHub 上 Star 数量超过 19000 粒，NPM 下载量也稳居同类开发框架之首，同时 Taro 团队也和腾讯、百度、华为等数十家业界巨头的研发团队展开了深入和有效的合作。 Taro 1.3 是我们酝酿最久的版本：经历了横跨 6 个月的开发时间，近 2000 次的代码提交，近百位开发者的共同参与。我们终于在今天骄傲地发布了 Taro 1.3。 Taro 1.3 的特性包括但不限于： 支持快应用和 QQ 小程序的开发 全面支持 JSX 语法和 React Hooks 大幅提高 H5 性能和可用性 Taro Doctor 支持快应用和 QQ 小程序的开发快应用的开发模式非常特别，它的 API、组件系统、组件库和其他小程序端差异非常大，并且快应用只是一个标准，各家安卓厂商对运行时的实现也各不相同。而这块「硬骨头」终于也被 Taro 啃下了。 QQ 小程序作为新兴的小程序类容器，大家普遍对它知之甚少，但 Taro 也率先实现了对 QQ 小程序的支持。 支持快应用和 QQ 小程序意味着 Taro 真正对业界主流小程序实现了「全覆盖」，不管你的业务要支持哪一个小程序端，只要维护一套代码，Taro 就能生成对应小程序平台的代码。同时 Taro 也成为了业界首个同时支持微信小程序、百度智能小程序、字节跳动小程序、支付宝小程序、快应用、QQ 小程序共 6 端小程序的开发框架。 全面支持 JSX 语法和 React Hooks作为使用 React 和 JSX 语法的开发框架，Taro 早期的版本在编译器和编辑器检查工具都对语法做了高强度的限制。而在 Taro 1.3 中，开发者可以充分发挥自己的创造力和想象力，可以任意地写 if-else，可以任意地写匿名函数，可以把 JSX 放在类函数中，也可以放在普通函数中，等等。只要编译器和和 ESLint 不报错，就可以这么写。 虽然 React Hooks 正式稳定的时间并不长，但我们认为这个特性能有效地简化开发模式，提升开发效率和开发体验。即便 Hooks 的生态和最佳实践还尚未完善，但我们相信未来 Hooks 会成为 React 开发模式的主流，也会深刻地影响其它框架未来的 API 构成。所以我们优先把 React Hooks 带到了 Taro 中，还写了两个小例子展示如何在 Taro 中使用 Hooks： V2EX: https://github.com/NervJS/taro-v2ex-hooks TodoMVC: https://github.com/NervJS/taro-todomvc-hooks 全新生命周期和 Context API在 Taro 1.3 我们还实现了 React 16 的新生命周期函数 static getDerivedStateFromProps() 和 getSnapshotBeforeUpdate()。当新的生命周期函数注入到类组件时，老的生命周期函数将不会被调用，没有使用新的生命周期函数则不会影响原有生命周期的调用。就多数情况而言，我们更推荐使用新的生命周期来构建你的类组件，因为这样能减少一次渲染和更新的开销。更多详细信息可以查看相关文档。 Taro 1.3 还实现了 React 16 的 createContext、contextType 和 useContext API。新 Context 通过声明式的 API 来传递组件的更新，使得Taro 跨组件通信和共享状态更为直观。同时，例如 react-redux 这样的热门库也正在基于 Context 和 Hooks 进行重构，我们也非常期待与社区一起探索 React/Taro 新的开发与设计模式。 大幅提高 H5 性能和可用性作为除微信小程序之外需求量最高的端，我们一直都部署了重要的开发战力在 H5 端。而在 Taro 1.3 中，我们优化了编译代码的方式，实现了资源最小引入和按需引入，将原有最小项目的编译大小降低了 80% 左右。这对于网络状况不佳的 H5 端无疑是巨大的提升。 H5 端的 API 数量和质量也得到了大幅地增长，Taro 1.3 新增了 28 个 H5 API，解决了上百个 H5 相关的 issue。 关于 H5 端性能更感兴趣可以查看文章:《决战性能之巅 - Taro H5 转换与优化升级》。 Taro Doctor我们还从 Flutter Doctor 中得到启发，开发了 Taro Doctor。 Taro Doctor 就像一个医生一样，可以诊断项目的依赖、设置、结构，以及代码的规范是否存在问题，并尝试给出解决方案。 但和真正的医生不一样，Taro Doctor 不需要排队挂号，也不用花钱。你只需要在终端运行命令：taro doctor，就像图里一样： 还有更多除了以上的特性之外，Taro 1.3 还做了许多额外的工作，这些工作可能对日常开发影响不大，但为 Taro 的稳定性以及将来更多的可能性夯实了基础： 组件传参（props）系统重构在 Taro 1.0 到 1.2 的小程序端，我们一直使用原生小程序框架的组件传参系统，但小程序组件系统没办法传递函数的值，也无法传递非具名参数，并且各小程序组件的实现各不相同。为了解决这些问题，在 Taro 1.3 中我们自己实现了一套组件传参系统。新系统会使得传参相关的代码更为可靠，同时也是我们支持更多 JSX 语法的基础。 命令行工具（CLI） 重构在 Taro 1.3，我们将命令行工具使用 TypeScript 进行了重构并逐步添加更多测试用例。重构之后我们可以更加大胆地为 CLI 添加新功能，替换老旧依赖。同时我们也会将 CLI 的功能以 API 的形式暴露出来，赋能给其它开发工具和我们的合作伙伴。 移动端容器更换我们和京东的 ARES) 团队合作，把原有的移动端容器 expo 替换为深度定制的 JDReact。JDReact 大幅提升了 Taro 移动端的可控性，可以让我们突破 expo 的掣肘，引入原生移动端代码，提供定制功能和 API，并且性能和稳定性的表现都会更好。 支持开发小程序插件小程序插件是小程序带来的一个非常优秀的特性，可以极大地提高代码复用率，降低包大小，为开发者带来诸多便利，目前微信、支付宝小程序已经支持插件功能。而从 1.3 版本开始，Taro 支持直接开发微信与支付宝小程序插件，这意味着 Taro 项目将和小程序插件无缝对接，不再有开发模式切换的成本。 支持「小程序·云开发」「小程序·云开发」是微信小程序联合腾讯云团队提供的一个非常强大的功能，它是一款 Serverless 服务，为开发者提供了「云函数」、「云数据库」和「云文件存储」三大能力，并且将这些能力封装成特定的接口，可以帮助开发者快速构建微信小程序的后端服务。为了让 Taro 开发者能够享受到「小程序·云开发」的能力，Taro 也加入了对「小程序·云开发」的支持，为「小程序·云开发」提供了初始化模板，并且将小程序云相关的 API 进行了封装，方便开发者进行使用。同时，「小程序·云开发」已提供 H5 版本的 SDK，Taro 支持将小程序、H5 的调用方式进行统一封装，帮助开发者快速打造 Serverless 的多端应用。 升级兼容性正如前面所提到，Taro 1.3 是一个酝酿时间最久，拥有特性最多的大版本，对 Taro 底层也进行了不小的重构，所以，1.3 版本的升级带了以下 2 个兼容性问题。 JSX 中的事件监听函数必须绑定作用域在之前的 Taro 版本中，JSX 中绑定的事件监听函数，是可以不需要绑定任何作用域，就能访问到组件实例的，例如 123456789101112131415161718192021import Taro, &#123; Component, Config &#125; from '@tarojs/taro'import &#123; View, Button &#125; from '@tarojs/components'export default class Test extends Component &#123; state = &#123; hello: 'noclick' &#125; clickHandler () &#123; this.setState(&#123; hello: 'click' &#125;) &#125; render () &#123; return ( &lt;View className=&#123;styles.index&#125;&gt; &lt;Button onClick=&#123;this.clickHandler&#125;&gt;点击&lt;/Button&gt; &lt;/View&gt; ) &#125;&#125; 上述例子中，&lt;Button /&gt; 按钮绑定的点击事件，在之前版本中是能够正常执行的，Taro 会默认将 clickHandler 的作用域绑定为当前组件实例，但是这并不符合 React 中的实际情况，所以，在 1.3 版本中，我们对这一问题进行了修复，现在 JSX 中的事件监听函数必须绑定作用域，否则就会报错。 上述代码中 JSX 部分可以修改为如下 1234567render () &#123; return ( &lt;View className=&#123;styles.index&#125;&gt; &lt;Button onClick=&#123;this.clickHandler.bind(this)&#125;&gt;点击&lt;/Button&gt; &lt;/View&gt; )&#125; 或者你也可以在 constructor 中将函数进行提前绑定作用域， 1234567891011constructor () &#123; this.clickHandlerBind = this.clickHandler.bind(this)&#125;render () &#123; return ( &lt;View className=&#123;styles.index&#125;&gt; &lt;Button onClick=&#123;this.clickHandlerBind&#125;&gt;点击&lt;/Button&gt; &lt;/View&gt; )&#125; 还有一种做法是，将 clickHandler 写成箭头函数，这种方式在新旧版本中均可以正常运行。 暂时无法在原生应用中使用 Taro 组件在之前版本中，使用 Taro 编译后的组件是可以直接用在原生项目中的，以提升复用性，但 1.3 版本由于组件的 props 系统彻底重构了，升级 1.3 后暂时无法在原生项目中使用 Taro 组件，我们正在积极处理这个问题，在后续版本中将继续支持这一特性。 在框架之外Taro 团队除了 1.3 版本中完善多端适配，提高框架开发体验和开发效率之外，我们还在生态建设上付出了诸多努力，其中包括全新升级的官网，物料/插件市场，独立的社区/论坛。 我们认为，Taro 能够安身立命的本钱是作为开发框架的硬实力，但真正决定 Taro 能走多远却是生态、社区以及合作伙伴。我们在 1.3 已经把实力大幅增强，现在邀请你一起参与或观察 Taro 在生态和社区的建设： Taro 官网：https://taro.jd.com Taro 物料市场: https://taro-ext.jd.com Taro 社区：https://taro-club.jd.com GitHub: https://github.com/NervJS/taro","pubDate":"Thu, 13 Jun 2019 06:00:00 GMT","guid":"https://aotu.io/notes/2019/06/13/taro-1-3/","category":"小程序"},{"title":"小程序框架全面测评","link":"https://aotu.io/notes/2019/03/12/mini-program-framework-full-review/","description":"最近前端届多端框架频出，相信很多有代码多端运行需求的开发者都会产生一些疑惑：这些框架都有什么优缺点？到底应该用哪个？ 作为 Taro 开发团队一员，笔者想在本文尽量站在一个客观公正的角度去评价各个框架的选型和优劣。但宥于利益相关，本文的观点很可能是带有偏向性的，大家可以带着批判的眼光去看待，权当抛砖引玉。 那么，当我们在讨论多端框架时，我们在谈论什么： 多端笔者以为，现在流行的多端框架可以大致分为三类： 1. 全包型这类框架最大的特点就是从底层的渲染引擎、布局引擎，到中层的 DSL，再到上层的框架全部由自己开发，代表框架是 Qt 和 Flutter。这类框架优点非常明显：性能（的上限）高；各平台渲染结果一致。缺点也非常明显：需要完全重新学习 DSL（QML/Dart），以及难以适配中国特色的端：小程序。 这类框架是最原始也是最纯正的的多端开发框架，由于底层到上层每个环节都掌握在自己手里，也能最大可能地去保证开发和跨端体验一致。但它们的框架研发成本巨大，渲染引擎、布局引擎、DSL、上层框架每个部分都需要大量人力开发维护。 2. Web 技术型这类框架把 Web 技术（JavaScript，CSS）带到移动开发中，自研布局引擎处理 CSS，使用 JavaScript 写业务逻辑，使用流行的前端框架作为 DSL，各端分别使用各自的原生组件渲染。代表框架是 React Native 和 Weex，这样做的优点有： 开发迅速 复用前端生态 易于学习上手，不管前端后端移动端，多多少少都会一点 JS、CSS 缺点有： 交互复杂时难以写出高性能的代码，这类框架的设计就必然导致 JS 和 Native 之间需要通信，类似于手势操作这样频繁地触发通信就很可能使得 UI 无法在 16ms 内及时绘制。React Native 有一些声明式的组件可以避免这个问题，但声明式的写法很难满足复杂交互的需求。 由于没有渲染引擎，使用各端的原生组件渲染，相同代码渲染的一致性没有第一种高。 3. JavaScript 编译型这类框架就是我们这篇文章的主角们：Taro、WePY 、uni-app 、 mpvue 、 chameleon，它们的原理也都大同小异：先以 JavaScript 作为基础选定一个 DSL 框架，以这个 DSL 框架为标准在各端分别编译为不同的代码，各端分别有一个运行时框架或兼容组件库保证代码正确运行。 这类框架最大优点和创造的最大原因就是小程序，因为第一第二种框架其实除了可以跨系统平台之外，也都能编译运行在浏览器中。(Qt 有 Qt for WebAssembly, Flutter 有 Hummingbird，React Native 有 react-native-web, Weex 原生支持) 另外一个优点是在移动端一般会编译到 React Native/Weex，所以它们也都拥有 Web 技术型框架的优点。这看起来很美好，但实际上 React Native/Weex 的缺点编译型框架也无法避免。除此之外，编译型框架的抽象也不是免费的：当 bug 出现时，问题的根源可能出在运行时、编译时、组件库以及三者依赖的库等等各个方面。在 Taro 开源的过程中，我们就遇到过 Babel 的 bug，React Native 的 bug，JavaScript 引擎的 bug，当然也少不了 Taro 本身的 bug。相信其它原理相同的框架也无法避免这一问题。 但这并不意味着这类为了小程序而设计的多端框架就都不堪大用。首先现在各巨头超级 App 的小程序百花齐放，框架会为了抹平小程序做了许多工作，这些工作在大部分情况下是不需要开发者关心的。其次是许多业务类型并不需要复杂的逻辑和交互，没那么容易触发到框架底层依赖的 bug。 那么当你的业务适合选择编译型框架时，在笔者看来首先要考虑的就是选择 DSL 的起点。因为有多端需求业务通常都希望能快速开发，一个能够快速适应团队开发节奏的 DSL 就至关重要。不管是 React 还是 Vue（或者类 Vue）都有它们的优缺点，大家可以根据团队技术栈和偏好自行选择。 如果不管什么 DSL 都能接受，那就可以进入下一个环节： 生态以下内容均以各框架现在（2019 年 3 月 11日）已发布稳定版为标准进行讨论。 开发工具就开发工具而言 uni-app 应该是一骑绝尘，它的文档内容最为翔实丰富，还自带了 IDE 图形化开发工具，鼠标点点点就能编译测试发布。 其它的框架都是使用 CLI 命令行工具，但值得注意的是 chameleon 有独立的语法检查工具，Taro 则单独写了 ESLint 规则和规则集。 在语法支持方面，mpvue、uni-app、Taro 、WePY 均支持 TypeScript，四者也都能通过 typing 实现编辑器自动补全。除了 API 补全之外，得益于 TypeScript 对于 JSX 的良好支持，Taro 也能对组件进行自动补全。 CSS 方面，所有框架均支持 SASS、LESS、Stylus，Taro 则多一个 CSS Modules 的支持。 所以这一轮比拼的结果应该是： uni-app &gt; Taro &gt; chameleon &gt; WePY、mpvue 多端支持度只从支持端的数量来看，Taro 和 uni-app 以六端略微领先（移动端、H5、微信小程序、百度小程序、支付宝小程序、头条小程序），chameleon 少了头条小程序紧随其后。 但值得一提的是 chameleon 有一套自研多态协议，编写多端代码的体验会好许多，可以说是一个能戳到多端开发痛点的功能。uni-app 则有一套独立的条件编译语法，这套语法能同时作用于 js、样式和模板文件。Taro 可以在业务逻辑中根据环境变量使用条件编译，也可以直接使用条件编译文件（类似 React Native 的方式）。 在移动端方面，uni-app 基于 weex 定制了一套 nvue 方案 弥补 weex API 的不足；Taro 则是暂时基于 expo 达到同样的效果；chameleon 在移动端则有一套 SDK 配合多端协议与原生语言通信。 H5 方面，chameleon 同样是由多态协议实现支持，uni-app 和 Taro 则是都在 H5 实现了一套兼容的组件库和 API。 mpvue 和 WePY 都提供了转换各端小程序的功能，但都没有 h5 和移动端的支持。 所以最后一轮对比的结果是： chameleon &gt; Taro、uni-app &gt; mpvue &gt; WePY 组件库/工具库/demo作为开源时间最长的框架，WePY 不管从 Demo，组件库数量 ，工具库来看都占有一定优势。 uni-app 则有自己的插件市场和 UI 库，如果算上收费的框架和插件比起 WePy 也是完全不遑多让的。 Taro 也有官方维护的跨端 UI 库 taro-ui ，另外在状态管理工具上也有非常丰富的选择（Redux、MobX、dva），但 demo 的数量不如前两个。但 Taro 有一个转换微信小程序代码为 Taro 代码的工具，可以弥补这一问题。 而 mpvue 没有官方维护的 UI 库，chameleon 第三方的 demo 和工具库也还基本没有。 所以这轮的排序是： WePY &gt; uni-app 、taro &gt; mpvue &gt; chameleon 接入成本接入成本有两个方面： 第一是框架接入原有微信小程序生态。由于目前微信小程序已呈一家独大之势，开源的组件和库（例如 wxparse、echart、zan-ui 等）多是基于原生微信小程序框架语法写成的。目前看来 uni-app 、Taro、mpvue 均有文档或 demo 在框架中直接使用原生小程序组件/库，WePY 由于运行机制的问题，很多情况需要小改一下目标库的源码，chameleon 则是提供了一个按步骤大改目标库源码的迁移方式。 第二是原有微信小程序项目部分接入框架重构。在这个方面 Taro 在京东购物小程序上进行了大胆的实践，具体可以查看文章《Taro 在京东购物小程序上的实践》。其它框架则没有提到相关内容。 而对于两种接入方式 Taro 都提供了 taro convert 功能，既可以将原有微信小程序项目转换为 Taro 多端代码，也可以将微信小程序生态的组件转换为 Taro 组件。 所以这轮的排序是： Taro &gt; mpvue 、 uni-app &gt; WePY &gt; chameleon 流行度从 GitHub 的 star 来看，mpvue 、Taro、WePY 的差距非常小。从 NPM 和 CNPM 的 CLI 工具下载量来看，是 Taro（3k/week）&gt; mpvue (2k/w) &gt; WePY (1k/w)。但发布时间也刚好反过来。笔者估计三家的流行程度和案例都差不太多。 uni-app 则号称有上万案例，但不像其它框架一样有一些大厂应用案例。另外从开发者的数量来看也是 uni-app 领先，它拥有 20+ 个 QQ 交流群（最大人数 2000）。 所以从流行程度来看应该是： uni-app &gt; Taro、WePY、mpvue &gt; chameleon 开源建设一个开源作品能走多远是由框架维护团队和第三方开发者共同决定的。虽然开源建设不能具体地量化，但依然是衡量一个框架/库生命力的非常重要的标准。 从第三方贡献者数量来看，Taro 在这一方面领先，并且 Taro 的一些核心包/功能（MobX、CSS Modules、alias）也是由第三方开发者贡献的。除此之外，腾讯开源的 omi 框架小程序部分也是基于 Taro 完成的。 WePY 在腾讯开源计划的加持下在这一方面也有不错的表现；mpvue 由于停滞开发了很久就比较落后了；可能是产品策略的原因，uni-app 在开源建设上并不热心，甚至有些部分代码都没有开源；chameleon 刚刚开源不久，但它的代码和测试用例都非常规范，以后或许会有不错的表现。 那么这一轮的对比结果是： Taro &gt; WePY &gt; mpvue &gt; chameleon &gt; uni-app 最后补一个总的生态对比图表： 未来从各框架已经公布的规划来看： WePY 已经发布了 v2.0.alpha 版本，虽然没有公开的文档可以查阅到 2.0 版本有什么新功能/特性，但据其作者介绍，WePY 2.0 会放大招，是一个「对得起开发者」的版本。笔者也非常期待 2.0 正式发布后 WePY 的表现。 mpvue 已经发布了 2.0 的版本，主要是更新了其它端小程序的支持。但从代码提交， issue 的回复/解决率来看，mpvue 要想在未来有作为首先要打消社区对于 mpvue 不管不顾不更新的质疑。 uni-app 已经在生态上建设得很好了，应该会在此基础之上继续稳步发展。如果 uni-app 能加强开源开放，再加强与大厂的合作，相信未来还能更上一层楼。 chameleon 的规划比较宏大，虽然是最后发的框架，但已经在规划或正在实现的功能有： 快应用和端拓展协议 通用组件库和垂直类组件库 面向研发的图形化开发工具 面向非研发的图形化页面搭建工具 如果 chameleon 把这些功能都做出来的话，再继续完善生态，争取更多第三方开发者，那么在未来 chameleon 将大有可为。 Taro 的未来也一样值得憧憬。Taro 即将要发布的 1.3 版本就会支持以下功能： 快应用支持 Taro Doctor，自动化检查项目配置和代码合法性 更多的 JSX 语法支持，1.3 之后限制生产力的语法只有 只能用 map 创造循环组件 一条 H5 打包体积大幅精简 同时 Taro 也正在对移动端进行大规模重构；开发图形化开发工具；开发组件/物料平台以及图形化页面搭建工具。 结语那说了那么多，到底用哪个呢？ 如果不介意尝鲜和学习 DSL 的话，完全可以尝试 WePY 2.0 和 chameleon ，一个是酝酿了很久的 2.0 全新升级，一个有专门针对多端开发的多态协议。 uni-app 和 Taro 相比起来就更像是「水桶型」框架，从工具、UI 库，开发体验、多端支持等各方面来看都没有明显的短板。而 mpvue 由于开发一度停滞，现在看来各个方面都不如在小程序端基于它的 uni-app 。 当然，Talk is cheap。如果对这个话题有更多兴趣的同学可以去 GitHub 另行研究，有空看代码，没空看提交： chameleon: https://github.com/didi/chameleon mpvue: https://github.com/Meituan-Dianping/mpvue Taro: https://github.com/NervJS/taro uni-app: https://github.com/dcloudio/uni-app WePY: https://github.com/Tencent/wepy (按字母顺序排序)","pubDate":"Tue, 12 Mar 2019 15:09:41 GMT","guid":"https://aotu.io/notes/2019/03/12/mini-program-framework-full-review/","category":"小程序"},{"title":"决战性能之巅 - Taro H5 转换与优化升级","link":"https://aotu.io/notes/2019/02/28/taro-h5-optimize/","description":"前言作为一个多端开发框架，Taro 从项目发起时就已经支持编译到 H5 端。随着 Taro 多端能力的不断成熟，我们对 Taro H5 端应用的要求也不断提升。我们已经不再满足于“能跑”，更希望 Taro 能跑得快。 我们经常收到用户反馈：为什么使用 Taro 脚手架创建的空项目，打包后代码体积却有 400KB+；也有用户在 Issue 中提到，Taro 的部分 Api 占用空间巨大，事实上功能却并不完美，等等。作为一个开源项目，我们非常重视社区开发者们的意见。所以在最新版本中，我们对 Taro H5 端的性能表现进行了优化。 作为运行时的基础，每一个 Taro 的 H5 端应用都需要引入 @tarojs/components 和 @tarojs/taro-h5 等基础依赖包。在编译、打包之后，这些依赖包大约会在首屏占用 400KB 以上的空间。如果开发者还使用了 UI 库，例如 Taro-UI，基础体积还会更大，这严重限制了 Taro H5 端应用的性能优化空间。 事实上，我们在 H5 端应用中并不会使用到全部的 Taro 组件和 Api。将这些依赖包全部打包进应用是没有必要，也是不合理的。进行死码删除（Dead code elimination），进一步缩减代码体积，就是我们的优化方向之一。 效果在介绍具体细节之前，我们先看一看优化的效果，因为这可能会让你更有兴趣了解后面的内容。用一句话来说，效果非常显著。 我们建立了一个空项目，在项目配置中加入了webpack-bundle-analyzer插件以查看编译分析。下图是优化前的打包文件分析结果： 而在优化后，对比非常明显： 优化前生成的代码总大小为 455KB，而在优化后仅剩约 96KB，仅是原来的 1/5 左右。 你需要做什么很简单，作为使用者，你不需要做任何代码上的改动，只需要将 Taro 更新到最新版本即可。但在看不见的地方，Taro 却默默地做了许多工作。下面会从原理出发，详细介绍 Taro 的工作。 原理死码删除（Dead code elimination）是一种代码优化技术，可以删除对应用程序执行结果没有影响的代码。Web Fundamentals 的一篇文章有提到，treeshaking 是由 Rollup 提出的一种死码删除的形式。 Tree shaking is a form of dead code elimination. The term was popularized by Rollup, but the concept of dead code elimination has existed for some time. – Reduce JavaScript Payloads with Tree Shaking, Jeremy Wagner 通过在构建时进行静态分析，编译工具可以分析出我们代码中真正的依赖关系。treeshaking 把我们的代码想象成一棵树，代码的每个依赖项看作树上的节点。将未使用过的依赖项从构建结果中移除，这就是 treeshaking 的基本思想。 那么，假设我们手头有一段代码，我们要怎样辨别其中可以删除的部分呢？答案是，通过分析副作用： 123456789101112// add.jsexport default function add（a, b）&#123; return a + b; &#125;// add2.jsconsole.log('这是一个log')export default function add2（a, b）&#123; return a + b; &#125;// index.jsimport add from './add.js' // 没有副作用，可以删除import add2 from './add2.js' // 有副作用，不能直接删除// EOF 副作用这个名词对于了解函数式编程的同学肯定不陌生。修改外部状态，或者是产生输出等等，都是副作用；而存在副作用的代码，是不能被直接移除的。类似上面这个代码示意，add2 模块就是存在副作用的。 站在巨人的肩膀上除了 Rollup 之外，支持 treeshaking 的工具/插件还有很多，比如 babel-plugin-transform-dead-code-elimination、uglify、terser等。 webpack 在 v2 之后就内置了对 treeshaking 的支持，并在 webpack@4 中对 treeshaking 功能进行了扩展。 Taro H5 端在构建过程中，使用 webpack 作为构建的核心。在 webpack 中使用 treeshaking 功能有几个需要注意的地方： 如果是 npm 模块，需要package.json中存在sideEffects字段，并且准确配置了存在副作用的源代码。 必须使用 ES6 模块语法。由于诸如babel-preset-env之类的 babel 预配置包默认会对代码的模块机制进行改写，还需要将modules设置为false，将模块解析的工作直接交给 webpack。 需要工作在 webpack 的production模式下。 webpack 的 treeshaking 工作主要分为两步。第一步是在模块级别移除未使用且无副作用的模块，这一步由 webpack 的内置插件完成；第二步是在文件级别移除未使用的代码，这一步由代码压缩工具 Terser 完成的。 移除未使用的模块前面我们提到，需要在package.json中配置sideEffects字段。 在 webpack 文档 中有提到，这一举动正是为了让 webpack 正确地识别到没有副作用的代码模块。 在 webpack 中，模块依赖分析是由内置插件 SideEffectsFlagPlugin 进行的。 经过 SideEffectsFlagPlugin处理后，没有使用过并且没有副作用的模块都会被打上sideEffectFree标记。 在 ModuleConcatenationPlugin 中，带着sideEffectFree标记的模块将不会被打包： 来到这里，webpack 完成了在模块级别对未使用模块的排除。接下来，依靠 Terser，webpack 可以在文件级别，对未使用、无副作用的代码进行移除。 移除未使用的代码在 CommonJS 规范中，我们通过require函数来引入模块，通过module.exports进行导出。这意味着我们可以在代码中的任何地方用任何方式引入和导出模块：可以是在某个需要等待用户输入的回调函数中，或者是在符合某个条件才进行引入等等。所以在使用 ES6 的模块系统之前，对 Javascript 做编译时的依赖关系分析是近乎不可能的（并不是完全不可能。prepack 通过实现一个 JS 解释器，甚至可以在编译时提前进行静态计算）。 12345678// utils.jsmodule.exports.add = function (a, b) &#123; return a + b &#125;;module.exports.minus = function (a, b) &#123; return a - b &#125;;// index.js;var utils = require('./utils.js');utils.add(1, 2); 像上面这段代码，虽然我们最终只使用了add函数，但minus函数也会在最终的打包代码中出现，因为在编译时无法快速得知是否使用了minus函数。 在 ES6 的模块系统中，我们使用import/export语法来进行模块的引入和导出。与 CommonJS 规范不同的是，这套新的模块系统存在一些限制：import/export行为只能在代码的顶层、默认使用严格模式等等。这些限制使代码模块的导入与导出变得静态化，模块间的依赖关系在开发时已经确定，编译器也更容易解析我们的代码。 1234567// utils.jsexport function add (a, b) &#123; return a + b &#125;;export function minus (a, b) &#123; return a - b &#125;;// index.js;import &#123; add &#125; from './utils.js';add(1, 2); 在使用 ES6 模块系统改造后，我们可以清楚地看到，minus函数确实没有被使用过，所以可以安全地将其从最终打包代码中移除。 当然，具体的分析过程非常复杂。变量提升、object 取值操作、for(var i in list) 语句、自执行函数、函数传参（onClick(function a () {…})）等等，都有可能导致意料之外的情况，从而导致 treeshaking 失效。如果想了解 Terser 的具体处理过程，百度/Google 会是最好的老师。 Taro 做了什么Taro 需要对依赖包做一些修改。 组件的 ES 模块化在进行组件库的 ES 模块化改造之前，如果要发布 @tarojs/components 包，Taro 会执行命令 yarn build，使用 webpack 对源代码进行打包，输出为dist/index.js文件。由于 webpack 并不支持输出为 ES 模块，所以这是个 UMD 模块。 这个文件占据了 462KB 的空间，并且由于模块规范等问题，无法进行 treeshaking。所以就算开发者在 Taro 的项目中只引入了两个组件，最终的打包结果也会包含所有的内置组件。 事实上，@tarojs/components 的源码本身是使用 ESM 规范的： 所以只要让 webpack 直接解析组件库的源码，我们立即就可以享受到 webpack 自带 treeshaking 带来的好处了。 同时，我们也在sideEffects属性中对样式文件做了标记，帮助 webpack 对样式代码的副作用进行识别，在项目编译的代码中保留样式代码。 Api 的 ES 模块化同样，以前在发布 @tarojs/taro-h5 之前，Taro 也需要执行命令 yarn build，使用 Rollup 对源代码进行打包，输出为dist/index.js文件： 这个文件占据了 262KB 的空间。同样，只要是个 Taro 的 H5 端应用，生成的代码都会全量引入这个文件。 我们对 @tarojs/taro-h5 进行模块化改造的思路与 @tarojs/components 相同。我们希望 @tarojs/taro-h5 模块本身遵守 ESM 模块规范，那就只需要标记一下sideEffects，再修改一下模块入口就好。 粗略一看，@tarojs/taro-h5 还挺 “ESM” 的，但这还不够。我们还需要将这些 Api 以 namedExports 的形式导出，开发者使用import { XXX } from &#39;@tarojs/taro-h5&#39;导入 Api 即可。 那么问题来了。在 Taro 项目中，我们一直使用的是 defaultImport，并不会使用 Api 的 namedExports 形式： 12345import Taro from '@tarojs/taro-h5'Taro.navigateTo()Taro.getSystemInfo()// Taro.xxx ... 只要 Api 是通过对Taro变量取属性获取，Taro变量就需要具备所有的 Api，treeshaking 也就无从谈起。 有没有办法把 defaultImport 修改为 namedImports 呢？答案是肯定的。我们写了一个 babel 插件 babel-plugin-transform-taroapi，将指定的 Api 调用替换为 namedImports，未指定的变量则保留属性取值的形式。具体源码可以在这里查看。 12345678910111213// const apis = new Set(['navigateTo', 'navigateBack', ...])&#123; babel: &#123; preset: ['babel-preset-env'], plugins: [ // ..., ['babel-plugin-transform-taroapi', &#123; packageName: '@tarojs/taro-h5', apis &#125;] ] &#125;&#125; 这个插件接受一个对象作为配置参数：packageName属性指定需要进行替换的模块名，apis接受一个 Set 对象，也就是所有 Api 的列表。 为了避免后期手动维护 Api 列表的情况，我们给 @tarojs/taro-h5 模块加了一个编译任务，通过一个简单的Rollup 插件，在执行yarn build命令时生成一份 Api 列表： 下面是编译前后的代码对比。可以看到，在编译后setStorage、getStorage的调用都被替换为 namedImports。 1234567891011// 编译前import Taro from '@tarojs/taro-h5';Taro.initPxTransform(&#123;&#125;);Taro.setStorage()Taro['getStorage']()// 编译后import Taro, &#123; setStorage as _setStorage, getStorage as _getStorage &#125; from '@tarojs/taro-h5';Taro.initPxTransform(&#123;&#125;);_setStorage();_getStorage(); 到这里，虽然过程比较艰辛，但我们对 @tarojs/taro-h5 的模块化改造终于完成了。 最后截至目前，Taro 在 H5 端的完成度已经很高，但是并不完美。未来，在对已有问题进行修复的同时，我们还将继续为 Taro H5 端带来更多新的特性，比如对社区中呼声相当高的switchTab、页面滚动监听onPageScroll、下拉刷新onPullDownRefresh等 Api 的支持，更加统一的页面切换动画，以及更加稳定的多页面模式等等。 Taro 发展到现在，离不开社区的支持。非常感谢在 github、微信群中踊跃反馈的开发者们。如果你对Taro有什么想法或建议，Taro 非常欢迎你来吐槽或观光： https://github.com/NervJS/taro","pubDate":"Thu, 28 Feb 2019 15:09:41 GMT","guid":"https://aotu.io/notes/2019/02/28/taro-h5-optimize/","category":"小程序"},{"title":"Taro UI 2.0 发布：新增自定义主题功能，适配更多小程序","link":"https://aotu.io/notes/2019/02/25/taro-ui-2.0/","description":"前言转眼间，Taro UI 发布已有半年，感谢大家的支持，让我们收获了 GitHub 1400+ star。在此期间，我们不断完善组件库的功能和特性，新增了许多组件和小工具，包括但不限于: 新增日历、索引选择、区域选择、图片选择等十一个组件 适配支付宝小程序、百度小程序 新增自定义主题功能 新增主题生成器，以帮助开发者更好地使用自定义主题功能 新增 Issue Helper，以帮助开发者更规范地填写 Issue 新增组件在 1.0 版本发布之后，我们又陆续新增了如下十一个组件： 视图组件：页面提示、 分隔符、倒计时、 幕帘 、步骤条 操作反馈：全局信息组件 表单：图片选择器、区域选择器、索引选择器、日历组件、搜索栏 其中，在社区里呼声最高的组件，非日历组件莫属。由于日历组件复杂度偏高，要适配多端环境难度偏大，纵观市面上的小程序 UI 组件库，包含日历组件的寥寥无几。尽管如此，我们团队的大鱼兄仍独自挑起重担，几乎完美地实现了该组件，此处掌声献给大鱼兄。 日历组件功能预览： 适配支付宝小程序、百度小程序在 1.0 版本适配微信小程序时，我们遇到了很多困难。比如： 微信小程序自定义组件使用 Shadow DOM 进行渲染，引起了以下几种问题： 组件之间无法使用相邻选择器，如组件间加 border 的需求，最终只能通过新增 props 给开发者自行控制 无法自定义 flex 布局组件，最终只能提供样式给开发者自行使用 Component 组件对应 wxss 文件的样式，只对组件 wxml 内的节点生效。经过不断探索，才发现 addGlobalClass 这一属性，需在自定义组件内激活 addGlobalClass 选项，才能使自定义组件被 app.wxss 或页面的 wxss 中的所有的样式定义影响。。 原生组件的使用限制。由于原生组件脱离在 WebView 渲染流程外，原生组件的层级是最高的，所以页面中的其他组件无论设置 z-index 为多少，都无法盖在原生组件上。由此导致模态框等组件无法遮挡 input、textarea等原生组件，造成穿透效果。 可喜的是，微信官方团队已经在改善该问题，对小程序原生组件引入了同层渲染模式。通过同层渲染，小程序原生组件可与其他内置组件处于相同层级，不再有特殊的使用限制。详见。 小程序不支持 requestAnimationFrame，无法很好地实现 js 动画。 克服完上述微信小程序的困难后，支付宝小程序和百度小程序的适配工作大多是解决样式和某些API的差异。得益于 Taro 良好的支持，Taro UI 的适配工作暂时告一段落。 新增自定义主题功能Taro UI 1.0 发布时只有一套默认的主题配色，为满足业务和品牌上多样化的视觉需求，UI 库支持一定程度的样式定制。 Taro UI 的组件样式是使用 SCSS 编写的，如果你的项目中也使用了 SCSS，那么可以直接在项目中改变 Taro UI 的样式变量。 新建一个主题样式文件（例如 custom-variables.scss）并覆盖默认主题变量： 1234/* 改变主题变量，具体变量名可查看 taro-ui/dist/style/variables/default.scss 文件 */$color-brand: #6190E8;/* 引入 Taro UI 默认样式 */@import \"~taro-ui/dist/style/index.scss\"; 之后在项目的入口文件中引入以上的样式文件即可（无需重复引入组件的默认样式）。 目前，我们额外定制了京东主题和 7Fresh 主题色，可通过扫描以下二维码查看。 京东主题： 7Fresh 主题： 新增主题生成器为了让开发者更好地使用自定义主题功能，我们还新增了主题生成器。开发者可以使用该工具方便地定制 UI 主题。 主题生成器地址： https://nervjs.github.io/taro-ui-theme-preview/ 效果预览： 新增 Issue Helper虽然我们配置了 Issue Template，但仍有部分开发者没有根据规范填写 Issue。我们排查问题时经常需要再次询问版本号信息、复现代码等等，这不仅消耗我们维护项目的精力，还降低了 Issue 处理效率。因此我们参考了 Ant 和 iView 团队的做法，制作了 Issue Helper 页面，帮助开发者更规范地填写 Issue。 Taro UI Issue Helper 地址： https://nervjs.github.io/taro-ui-issue-helper/ 此外，我们发现重复制作 Issue Helper 页面是一件很浪费劳动力的事情，于是将 Issue Helper 封装成一个命令行工具，开发者可以通过简单配置 config.js，执行命令 issue-helper build 就可以生成所需要的页面。 Issue Helper 工具仓库地址： https://github.com/jimczj/issue-helper 未来计划 适配字节跳动小程序 国际化 i18n 致谢感谢大家对 Taro UI 的使用与反馈，我们会致力于将 Taro UI 打造成高质量组件库，不断丰富组件功能与特性，紧跟 Taro 的步伐适配更多平台。 最后，欢迎关注并使用我们的组件库： https://github.com/NervJS/taro-ui","pubDate":"Mon, 25 Feb 2019 04:53:41 GMT","guid":"https://aotu.io/notes/2019/02/25/taro-ui-2.0/","category":"小程序"},{"title":"全新 Phaser 3 游戏引擎特性一览","link":"https://aotu.io/notes/2018/12/23/phaser3/","description":"什么是 Phaser ?Phaser 是一款快速、免费以及开源 HTML5 游戏框架，它支持 WebGL 和 Canvas 两种渲染模式，可以在任何 Web 浏览器环境下运行，游戏可以通过第三方工具转为 iOS、Android 支持的 Native APP，允许使用 JavaScript 和 TypeScript 进行开发。 目前 Phaser 存在三个版本：分别是 Phaser 2 版本、社区版本 Phaser CE 和最新版本 Phaser 3。","pubDate":"Sun, 23 Dec 2018 16:00:00 GMT","guid":"https://aotu.io/notes/2018/12/23/phaser3/","category":"H5游戏开发"},{"title":"Taro 1.2：将已有微信小程序转换为多端应用","link":"https://aotu.io/notes/2018/12/17/taro-1-2/","description":"在距离 Taro 1.1 发布 之后一个月，经历了 500 多次提交和 17 个预览版本的迭代之后，我们有信心在今天发布 Taro 1.2 正式版。 Taro 1.2 比起 Taro 1.1 和其它的小程序开发框架，增加了许多首次在小程序框架上实现的功能，这些功能包括但不限于： 微信小程序转多端应用 字节跳动（头条）小程序支持 CSS Modules 支持 MobX 支持 微信小程序转多端应用就像博客大战时代博客服务商提供了「搬家」工具一样，Taro 现在也提供了「搬家」工具让你方便地入驻 Taro 社区。转换原有微信小程序应用非常简单，只需要安装 Taro 命令行工具，定位到待转项目根目录，运行命令：1$ taro convertTaro 就会把转换好的代码生成在根目录下的 taroConvert 文件夹。转换后的代码是高可读性的 JSX 代码，没有额外的庞大组件库开销。你可以轻易地进行二次开发，或者直接将这些代码通过 taro build 命令生成任意 Taro 已经支持平台的应用。我们已经尝试使用 taro convert 成功转换了四个 GitHub 上最热门的开源微信小程序应用，它们转换之后都表现良好：- EastWorld/wechat-app-mall ★5000+ - 微信小程序商城- tumobi/nideshop-mini-program ★3000+ - 基于 Node.js + MySQL 开发的开源微信小程序商城- RebeccaHanjw/weapp-wechat-zhihu ★1000+ - 仿知乎- jectychen/wechat-v2ex ★400+ - V2EX taro convert 不仅仅能支持转换微信小程序应用，它还能转换微信小程序第三方组件。例如 wxParse 经过 taro convert 编译之后还能突破原有只能解析 11 层 HTML 嵌套的限制，理论上可以解析无限层 HTML 嵌套。更多详情可以访问文档 https://nervjs.github.io/taro/docs/taroize.html 了解更多。字节跳动（头条）小程序支持作为一个「多端统一开发框架」，Taro 当然也不会放过字节跳动小程序。在 Taro 1.2，你可以通过如下命令进行字节跳动小程序端的编译预览及打包：123456789# npm script$ npm run dev:tt$ npm run build:tt# 仅限全局安装$ taro build --type tt --watch$ taro build --type tt# npx 用户也可以使用$ npx taro build --type tt --watch$ npx taro build --type tt选择字节跳动小程序模式，你需要下载并打开字节跳动小程序开发者工具，然后在项目编译完后选择项目根目录下 dist 目录进行预览。相应地，Taro 的平台标识（process.env.TARO_ENV）也增加了新成员tt，代表字节跳动小程序。CSS Modules 支持 在 Taro 最早开源的时候我们就支持了 SCSS 、 LESS 和 Stylus，而在 Taro 1.2 中我们百尺竿头更进一步，给社区带来了 JSX 的好伙伴：CSS Modules。 对于 Taro 而言支持 CSS Modules 有着重要的意义。Taro 在 1.0 的时候已经支持组件的 style 传入 JavaScript 对象，支持了 CSS Modules 之后组件的 className 也能做这点——这意味着 Taro 完全可以做到 JSX 的一项特性：「Everything in JavaScript」。同时，通过编辑器的自动补全和校验功能，开发者再也不用担心 CSS 类误输入和 CSS 类的命名问题。 你可以查阅文档 CSS Modules 的使用 找到 CSS Modules 的开启方法。 CSS Modules 的支持主要由 Taro 社区的个人开发者 @MrKou47 (MrKou47) 开发，感谢他的贡献。 MobX 支持 在小程序应用变得日趋复杂的今天，越来越多的开发者选择使用独立的状态管理工具。在 Taro 1.1 你可以选择 Redux 的体系的 redux-thunk 、dva-core、redux-saga 等工具。在 Taro 1.2 我们又带来了 taro-mobx。 在 Taro 中使用 MobX 非常简单，你可以通过 taro init &lt;your app&gt; 命令创建一个全新的 MobX 模板项目。也可以查阅 使用 MobX 文档将 taro-mobx 接入已有项目。 MobX 的支持主要由 Taro 社区的个人开发者 @nanjingboy (Tom Huang) 开发，感谢他的贡献。 更多特性面对社区里给力的个人贡献者，Taro 官方团队也没有闲着。在 Taro 1.2 开发期间通过 commit 关闭了 169 个 issue 的同时，我们还披星戴月带来了更多特性。其中值得一提的是： H5 路由系统彻底重构 小程序组件的 props 支持传入 JSX 元素 支持 JSX 元素写在 switch-case 中，并支持 if-else 和 switch-case 的多重嵌套 支持引用别名（alias） 与百度小程序和字节跳动小程序官方通力合作，抹平了一大波和微信小程序的差异 你可以通过 CHANGELOG 查阅完整的功能迭代纪录。 写在最后Taro 1.2 最为激动人心的功能显然是「微信小程序转 Taro」 功能，通过这个功能已有的微信小程序应用能转化更好维护的 Taro（类 React） 代码，也能把 Taro 代码转化为多端应用。 但更重要的是，本次 Taro 1.2 更新的两个核心功能点均由个人开发者贡献——这完全体现了 Taro 社区的活跃、强大和开放。我们也会长期地维护与社区开发者们的关系，与开发者们一同成长，互利互赢。这也是 Taro 选择开源的意义所在。 如果你有任何想法，或者没有想法，Taro 都非常欢迎你来吐槽或观光： https://github.com/NervJS/taro","pubDate":"Mon, 17 Dec 2018 16:00:00 GMT","guid":"https://aotu.io/notes/2018/12/17/taro-1-2/","category":"小程序"},{"title":"Taro深度开发实践","link":"https://aotu.io/notes/2018/11/30/taro_practice/","description":"前言凹凸实验室的 Taro 是遵循 React 语法规范的多端开发方案，Taro 目前已对外开源一段时间，受到了前端开发者的广泛欢迎和关注。截止目前 star 数已经突破11.2k，还在开启的 Issues 有 200多个，已经关闭700多个，可见使用并参与讨论的开发者是非常多的。Taro 目前已经支持微信小程序、H5、RN、支付宝小程序、百度小程序，持续迭代中的 Taro，也正在兼容更多的端以及增加一些新特性的支持。 回归正题，本篇文章主要讲的是 Taro 深度开发实践，综合我们在实际项目中使用 Taro 的一些经验和总结，首先会谈谈 Taro 为什么选择使用React语法，然后再从Taro项目的代码组织、数据状态管理、性能优化以及多端兼容等几个方面来阐述 Taro 的深度开发实践体验。 为什么选择使用React语法这个要从两个方面来说，一是小程序原生的开发方式不够友好，或者说不够工程化，在开发一些大型项目时就会显得很吃力，主要体现在以下几点： 一个小程序页面或组件，需要同时包含 4 个文件，以至开发一个功能模块时，需要多个文件间来回切换 没有自定义文件预处理，无法直接使用 Sass、Less 以及较新的 ES Next 语法 字符串模板太过孱弱，小程序的字符串模板仿的是 Vue，但是没有提供 Vue 那么多的语法糖，当实现一些比较复杂的处理时，写起来就非常麻烦，虽然提供了 wxs 作为补充，但是使用体验还是非常糟糕 缺乏测试套件，无法编写测试代码来保证项目质量，也就不能进行持续集成，自动化打包 原生的开发方式不友好，自然就想要有更高效的替代方案。所以我们将目光投向了市面上流行的三大前端框架React、Vue、Angular 。Angular在国内的流行程度不高，我们首先排除了这种语法规范。而类 Vue 的小程序开发框架市面上已经有一些优秀的开源项目，同时我们部门内的技术栈主要是 React，那么 React 语法规范 也自然成为了我们的第一选择。除此之外，我们还有以下几点的考虑： React 一门非常流行的框架，也有广大的受众，使用它也能降低小程序开发的学习成本 小程序的数据驱动模板更新的思想与实现机制，与 React 类似 React 采用 JSX 作为自身模板，JSX 相比字符串模板来说更加自由，更自然，更具表现力，不需要依赖字符串模板的各种语法糖，也能完成复杂的处理 React 本身有跨端的实现方案 ReactNative，并且非常成熟，社区活跃，对于 Taro 来说有更多的多端开发可能性 综上所述，Taro 最终采用了 React 语法 来作为自己的语法标准，配合前端工程化的思想，为小程序开发打造了更加优雅的开发体验。 Taro项目的代码组织要进行 Taro 的项目开发，首先自然要安装 taro-cli，具体的安装方法可参照文档，这里不做过多介绍了，默认你已经装好了 taro-cli 并能运行命令。 然后我们用 cli 新建一个项目，得到的项目模板如下： 12345678910111213├── dist 编译结果目录├── config 配置目录| ├── dev.js 开发时配置| ├── index.js 默认配置| └── prod.js 打包时配置├── src 源码目录| ├── pages 页面文件目录| | ├── index index页面目录| | | ├── index.js index页面逻辑| | | └── index.css index页面样式| ├── app.css 项目总通用样式| └── app.js 项目入口文件└── package.json 如果是十分简单的项目，用这样的模板便可以满足需求，在 index.js 文件中编写页面所需要的逻辑 假如项目引入了 redux，例如我们之前开发的项目，目录则是这样的： 1234567891011121314151617181920├── dist 编译结果目录├── config 配置目录| ├── dev.js 开发时配置| ├── index.js 默认配置| └── prod.js 打包时配置├── src 源码目录| ├── actions redux里的actions| ├── asset 图片等静态资源| ├── components 组件文件目录| ├── constants 存放常量的地方，例如api、一些配置项| ├── reducers redux里的reducers| ├── store redux里的store| ├── utils 存放工具类函数| ├── pages 页面文件目录| | ├── index index页面目录| | | ├── index.js index页面逻辑| | | └── index.css index页面样式| ├── app.css 项目总通用样式| └── app.js 项目入口文件└── package.json 我们之前开发的一个电商小程序，整个项目大概3万行代码，数十个页面，就是按上述目录的方式组织代码的。比较重要的文件夹主要是pages、components和actions。 pages里面是各个页面的入口文件，简单的页面就直接一个入口文件可以了，倘若页面比较复杂那么入口文件就会作为组件的聚合文件，redux的绑定一般也是此页面里进行。 组件都放在components里面。里面的目录是这样的，假如有个coupon优惠券页面，在pages自然先有个coupon，作为页面入口，然后它的组件就会存放在components/coupon里面，就是components里面也会按照页面分模块，公共的组件可以建一个components/public文件夹，进行复用。 这样的好处是页面之间互相独立，互不影响。所以我们几个开发人员，也是按照页面的维度来进行分工，互不干扰，大大提高了我们的开发效率。 actions这个文件夹也是比较重要，这里处理的是拉取数据，数据再处理的逻辑。可以说，数据处理得好，流动清晰，整个项目就成功了一半，具体可以看下面数据状态管理的部分。如上，假如是coupon页面的actions，那么就会放在actions/coupon里面，可以再一次见到，所有的模块都是以页面的维度来区分的。 除此之外，asset文件用来存放的静态资源，如一些icon类的图片，但建议不要存放太多，毕竟程序包有限制。而constants则是一些存放常量的地方，例如api域名，配置等等。 项目搭建完毕后，在根目录下运行命令行 npm run build:weapp 或者 taro build --type weapp --watch 编译成小程序，然后就可以打开小程序开发工具进行预览开发了。编译成其他端的话，只需指定 type 即可（如编译 H5 ：taro build --type h5 --watch ）。 使用 Taro 开发项目时，代码组织好，遵循规范和约定，便成功了一半，至少会让开发变得更有效率。 数据状态管理上面说到，会用 redux 进行数据状态管理。 说到 redux，相信大家早已耳熟能详了。在 Taro 中，它的用法和平时在 React 中的用法大同小异，先建立 store、reducers，再编写 actions；然后通过@tarojs/redux，使用Provider 和 connect，将 store 和 actions 绑定到组件上。基础的用法大家都懂，下面我给大家介绍下如何更好地使用 redux。 数据预处理相信大家都遇到过这种时候，接口返回的数据和页面显示的数据并不是完全对应的，往往需要再做一层预处理。那么这个业务逻辑应该在哪里管理，是组件内部，还是redux的流程里？ 举个例子： 例如上图的购物车模块，接口返回的数据是 123456789&#123; code: 0, data: &#123; shopMap: &#123;...&#125;, // 存放购物车里商品的店铺信息的map goods: &#123;...&#125;, // 购物车里的商品信息 ... &#125; ...&#125; 对的，购车里的商品店铺和商品是放在两个对象里面的，但视图要求它们要显示在一起。这时候，如果直接将返回的数据存到store，然后在组件内部render的时候东拼西凑，将两者信息匹配，再做显示的话，会显得组件内部的逻辑十分的混乱，不够纯粹。 所以，我个人比较推荐的做法是，在接口返回数据之后，直接将其处理为与页面显示对应的数据，然后再dispatch处理后的数据，相当于做了一层拦截，像下面这样： 123456789101112const data = result.data // result为接口返回的数据const cartData = handleCartData(data) // handleCartData为处理数据的函数dispatch(&#123;type: 'RECEIVE_CART', payload: cartData&#125;) // dispatch处理过后的函数...// handleCartData处理后的数据&#123; commoditys: [&#123; shop: &#123;...&#125;, // 商品店铺的信息 goods: &#123;...&#125;, // 对应商品信息 &#125;, ...]&#125; 可以见到，处理数据的流程在render前被拦截处理了，将对应的商品店铺和商品放在了一个对象了. 这样做有如下几个好处： 一个是组件的渲染更纯粹，在组件内部不用再关心如何将数据修改而满足视图要求，只需关心组件本身的逻辑，例如点击事件，用户交互等 二是数据的流动更可控，后台数据 ——&gt; 拦截处理 ——&gt; 期望的数据结构 ——&gt; 组件，假如后台返回的数据有变动，我们要做的只是改变 handleCartData 函数里面的逻辑，不用改动组件内部的逻辑。 实际上，不只是后台数据返回的时候，其它数据结构需要变动的时候都可以做一层数据拦截，拦截的时机也可以根据业务逻辑调整，重点是要让组件内部本身不关心数据与视图是否对应，只专注于内部交互的逻辑，这也很符合 React 本身的初衷，数据驱动视图。 用Connect实现计算属性计算属性？这不是响应式视图库才会有的么，其实也不是真正的计算属性，只是通过一些处理达到模拟的效果而已。因为很多时候我们使用 redux 就只是根据样板代码复制一下，改改组件各自的store、actions。实际上，我们可以让它可以做更多的事情，例如： 123456789101112131415export default connect((&#123; cart,&#125;) =&gt; (&#123; couponData: cart.couponData, commoditys: cart.commoditys, editSkuData: cart.editSkuData&#125;), (dispatch) =&gt; (&#123; // ...actions绑定&#125;))(Cart)// 组件里render () &#123; const isShowCoupon = this.props.couponData.length !== 0 return isShowCoupon &amp;&amp; &lt;Coupon /&gt;&#125; 上面是很普通的一种connect写法，然后render函数根据couponData里是否数据来渲染。这时候，我们可以把this.props.couponData.length !== 0这个判断丢到connect里，达成一种computed的效果，如下： 123456789101112131415161718export default connect((&#123; cart,&#125;) =&gt; &#123; const &#123; couponData, commoditys, editSkuData &#125; = cart const isShowCoupon = couponData.length !== 0 return &#123; isShowCoupon, couponData, commoditys, editSkuData&#125;&#125;, (dispatch) =&gt; (&#123; // ...actions绑定&#125;))(Cart)// 组件里render () &#123; return this.props.isShowCoupon &amp;&amp; &lt;Coupon /&gt;&#125; 可以见到，在connect里定义了isShowCoupon变量，实现了根据couponData来进行computed的效果。 实际上，这也是一种数据拦截处理。除了computed，还可以实现其它的功能，具体就由各位看官自由发挥了。 性能优化关于数据状态处理，我们提到了两点，主要都是关于 redux 的用法。接下我们聊一下关于性能优化的。 setState的使用其实在小程序的开发中，最大可能的会遇到的性能问题，大多数出现在setData（具体到 Taro 中就是调用 setState 函数）上。这是由小程序的设计机制所导致的，每调用一次 setData，小程序内部都会将该部分数据在逻辑层（运行环境 JSCore）进行类似序列化的操作，将数据转换成字符串形式传递给视图层（运行环境 WebView），视图层通过反序列化拿到数据后再进行页面渲染，这个过程下来有一定性能开销。 所以关于setState的使用，有以下几个原则： 避免一次性更新巨大的数据。这个更多的是组件设计的问题，在平衡好开发效率的情况下尽可能地细分组件。 避免频繁地调用 setState。实际上在 Taro 中 setState 是异步的，并且在编译过程中会帮你做了这层优化，例如一个函数里调用了两次 setState，最后 Taro 会在下一个事件循环中将两者合并，并剔除重复数据。 避免后台态页面进行 setState。这个更有可能是因为在定时器等异步操作中使用了 setState，导致后台态页面进行了 setState 操作。要解决问题该就在页面销毁或是隐藏时进行销毁定时器操作即可。 列表渲染优化在我们开发的一个商品列表页面中，是需要有无限下拉的功能。 因此会存在一个问题，当加载的商品数据越来越多时，就会报错，invokeWebviewMethod 数据传输长度为 1227297 已经超过最大长度 1048576。原因就是我们上面所说的，小程序在 setData 的时候会将该部分数据在逻辑层与视图层之间传递，当数据量过大时就会超出限制。 为了解决这个问题，我们采用了一个大分页思想的方法。就是在下拉列表中记录当前分页，达到 10 页的时候，就以 10 页为分割点，将当前 this.state 里的 list 取分割点后面的数据，判断滚动向前滚动就将前面数据 setState 进去，流程图如下： 可以见到，我们先把商品所有的原始数据放在this.allList中，然后判断根据页面的滚动高度，在页面滚动事件中判断当前的页码。页码小于10，取 this.allList.slice 的前十项，大于等于10，则取后十项，最后再调用 this.setState 进行列表渲染。这里的核心思想就是，把看得见的数据才渲染出来，从而避免数据量过大而导致的报错。 同时为了提前渲染，我们会预设一个500的阈值，使整个渲染切换的流程更加顺畅。 多端兼容尽管 Taro 编译可以适配多端，但有些情况或者有些 API 在不同端的表现差异是十分巨大的，这时候 Taro 没办法帮我们适配，需要我们手动适配。 process.env.TARO_ENV使用process.env.TARO_ENV可以帮助我们判断当前的编译环境，从而做一些特殊处理，目前它的取值有 weapp 、swan 、 alipay 、 h5 、 rn 五个。可以通过这个变量来书写对应一些不同环境下的代码，在编译时会将不属于当前编译类型的代码去掉，只保留当前编译类型下的代码，从而达到兼容的目的。例如想在微信小程序和 H5 端分别引用不同资源： 12345if (process.env.TARO_ENV === 'weapp') &#123; require('path/to/weapp/name')&#125; else if (process.env.TARO_ENV === 'h5') &#123; require('path/to/h5/name')&#125; 我们知道了这个变量的用法后，就可以进行一些多端兼容了，下面举两个例子来详细阐述 滚动事件兼容在小程序中，监听页面滚动需要在页面中的onPageScroll事件里进行，而在 H5 中则是需要手动调用window.addEventListener来进行事件绑定，所以具体的兼容我们可以这样处理： 123456789101112131415161718192021222324class Demo extends Component &#123; constructor() &#123; super(...arguments) this.state = &#123; &#125; this.pageScrollFn = throttle(this.scrollFn, 200, this) &#125; scrollFn = (scrollTop) =&gt; &#123; // do something &#125; // 在H5或者其它端中，这个函数会被忽略 onPageScroll (e) &#123; this.pageScrollFn(e.scrollTop) &#125; componentDidMount () &#123; // 只有编译为h5时下面代码才会被编译 if (process.env.TARO_ENV === 'h5') &#123; window.addEventListener('scroll', this.pageScrollFn) &#125; &#125;&#125; 可以见到，我们先定义了页面滚动时所需执行的函数，同时外面做了一层节流的处理（不了解函数节流的可以看这里）。然后，在 onPageScroll 函数中，我们将该函数执行。同时的，在 componentDidMount 中，进行环境判断，如果是 h5 环境就将其绑定到 window 的滚动事件上。 通过这样的处理，在小程序中，页面滚动时就会执行 onPageScroll 函数（在其它端该函数会被忽略）；在 h5 端，则直接将滚动事件绑定到window上。因此我们就达成小程序，h5端的滚动事件的绑定兼容（其它端的处理也是类似的）。 canvas兼容假如要同时在小程序和 H5 中使用 canvas，同样是需要进行一些兼容处理。canvas 在小程序和 H5 中的 API 基本都是一致的，但有几点不同： canvas 上下文的获取方式不同，h5 中是直接从 dom 中获取；而小程序里要通过调用 Taro.createCanvasContext 来手动创建 绘制时，小程序里还需在手动调用 CanvasContext.draw 来进行绘制 所以做兼容处理时就围绕这两个点来进行兼容 1234567891011121314151617181920212223componentDidMount () &#123; // 只有编译为h5下面代码才会被编译 if (process.env.TARO_ENV === 'h5') &#123; this.context = document.getElementById('canvas-id').getContext('2d') // 只有编译为小程序下面代码才会被编译 &#125; else if (process.env.TARO_ENV === 'weapp') &#123; this.context = Taro.createCanvasContext('canvas-id', this.$scope) &#125;&#125;// 绘制的函数draw () &#123; // 进行一些绘制操作 // ..... // 兼容小程序端的绘制 typeof this.context.draw === 'function' &amp;&amp; this.context.draw(true)&#125;render () &#123; // 同时标记上id和canvas-id return &lt;Canvas id='canvas-id' canvas-id='canvas-id'/&gt;&#125; 可以见到，先是在 componentDidMount 生命周期中，分别针对不同的端的方法而取得 CanvasContext 上下文，在小程序端是直接通过Taro.createCanvasContext进行创建，同时需要在第二个参数传入this.$scope；在 H5 端则是通过 document.getElementById(id).getContext(&#39;2d&#39;)来获得 CanvasContext 上下文。 获得上下文后，绘制的过程是一致的，因为两端的 API 基本一样，而只需在绘制到最后时判读上下文是否有 draw 函数，有的话就执行一遍来兼容小程序端，将其绘制出来。 我们内部用 Canvas 写了一个弹幕挂件，正是用这种方法来进行两端的兼容。 上述两个具体例子总结起来，就是先根据 Taro 内置的 process.env.TARO_ENV 环境变量来判断当前环境，然后再对某些端进行单独适配。因此具体的代码层级的兼容方式会多种多样，完全取决于你的需求，希望上面的例子能对你有所启发。 总结本文先谈了 Taro 为什么选择使用React语法，然后再从Taro项目的代码组织、数据状态管理、性能优化以及多端兼容这几个方面来阐述了 Taro 的深度开发实践体验。整体而言，都是一些较为深入的，偏实践类的内容，如有什么观点或异议，欢迎加入开发交流群，一起参与讨论。","pubDate":"Fri, 30 Nov 2018 06:40:26 GMT","guid":"https://aotu.io/notes/2018/11/30/taro_practice/","category":"小程序"},{"title":"SVG vs Image, SVG vs Iconfont","link":"https://aotu.io/notes/2018/11/23/SVG_vs_Image_vs_iconfont/","description":"这可能是个别人写过很多次的话题，但貌似由于兼容性的原因？图标的显示还是用着 Iconfont 或者 CSS Sprite 的形式？希望通过自己新瓶装旧酒的方式能重新引导一下问题。 SVG vs Image比方说现在要做下图这样的视觉效果： 分析：可能需要三张图片 鼠标移入时的背景图 渐变色前景图 鼠标移入时白色前景图 独立图像现在对比一下背景图使用图片与使用 SVG 格式的体积大小（做图的时候拿错颜色了，其他都一样，能说明道理就行，见谅见谅） 可以看出，在肉眼感觉差异不大的情况下，WebP 格式体积最小，其次是 SVG，而 PNG 的体积过大。 这个 SVG 是在 Sketch 设计稿中导出来的，源码包含了很多冗余无效的代码，实际上是可以优化的，如下。 内部源码 优化后 优化后大约可以减去 1K 个字符。当然这个需要内联使用（Inline SVG） CSS Sprite使用 CSS Sprite 的方式可以减少 HTTP 请求，貌似还可以减少总体图片体积。这里用前景图来对比一下，实际上背景图和前景图都可以合成一张 sprite。 可以看出，CSS Sprite 的体积比 Inline SVG + CSS 的方式大很多。 SVG vs Image 结论 绿色部分表示 SVG 比 Image 略胜一筹的地方，黄色部分表示有所欠缺的地方，灰绿色表示差不多。 1、如今已接近 2019 年了，对于 IE9 (2011年) 这种古老的浏览器都支持 SVG，所以再过多强调更低的兼容性也没有什么意思。2、Inline SVG 在浏览器应该是被渲染成 DOM 节点，所以关于 DOM 节点的性能优化都有必要注意；一个 SVG 图像可能就会有很多路径，即 DOM 节点，太多的 DOM 节点必然会影响浏览器的渲染性能及内存占用，而纯位图的渲染方式应该是没有这方面的顾虑。（DOM 数量影响参考：Google WEB 开发者文档） 综上结论：除开复杂图像，选择 Inline SVG 或者 &lt;img/&gt; 标签的方式引入 SVG，会比使用 独立图像 或 组合图像 (CSS sprite) 的方式更好。 SVG vs Iconfont书写对比 首先看下 Iconfont 与 SVG 图标的使用方式，来源 阿里 Iconfont 平台 很明显 SVG Sprite 使用起来没有 Iconfont 方便，需要写 3 行代码， 而后者只需要写 1 行。当然上面的不是重点，重点是下面的换色与多色支持 换色与多色支持换色1、Iconfont 通过 CSS color 可以轻松更换图标颜色。 2、而 SVG Sprite 比较麻烦，SVG Sprite 的代码原理如下。 12345678910111213// 定义 symbol&lt;svg&gt; &lt;symbol id=\"icon-arrow-left\" viewBox=\"0 0 1024 1024\"&gt; &lt;path d=\"M694 ... 44.576-45.952\"&gt;&lt;/path&gt; &lt;/symbol&gt; &lt;symbol id=\"icon-arrow-right\" viewBox=\"0 0 1024 1024\"&gt; &lt;path d=\"M693 ... 0-0.48-46.4\"&gt;&lt;/path&gt; &lt;/symbol&gt;&lt;/svg&gt;// 使用&lt;svg&gt;&lt;use xlink:href=\"#icon-arrow-left\"/&gt;&lt;/svg&gt;&lt;svg&gt;&lt;use xlink:href=\"#icon-arrow-right\"/&gt;&lt;/svg&gt; 渲染出来的 DOM 结构是这样的： 渲染在了 Shadow DOM 中（关于 Shadow DOM 的知识可以阅读下这篇文章或这篇），这样的 DOM 元素样式就具有了作用域，外面的 CSS 对 shadow-root 内的元素不会生效，如果想要更换元素的颜色，需要使用 /deep/ 来穿透添加样式，如下。123svg /deep/ path &#123; fill: red;&#125; 当然，实际上在只需要在父级元素上添加 fill: red 这样的 CSS 也能起到同样的效果，里面的元素会继承父级的样式。 PS: /deep/ 是 shadow DOM v0 的写法，v1 已经把这样的写法抛弃了，实际上支持 v1 的 shadow DOM, 父级的样式可以直接作用在 shadow-root 里面的元素。 多色支持1、Iconfont 是不支持多色图标的。 2、而 SVG Sprite 可以利用 CSS 变量或 shadow DOM 的方式支持多色图标，shadow DOM的方式上面已经说明，下面借用他人的文章解释 CSS 变量实现多色，如下。 不过使用 CSS 变量或 shadow DOM 的方式兼容性都不好， CSS 变量：Edge15+ shadow DOM：更差。兼容性列表 3、Inline SVG 可以良好地支持多色及多色变化。 渐变色支持Iconfont 与 SVG Sprite 不支持渐变色。Inline SVG 支持渐变色，并且兼容性良好。 渲染无抖动使用 Iconfont，因为字体文件是异步加载的，所以在字体文件还没有加载完毕之前，图标位会留空，加载完毕后才会显示出来，这个过程就会出现向下图（来自 GitHub blog）这样的抖动，而 SVG Sprite 或 Inline SVG 内联加载则不会出现这样的抖动。 当然，Iconfont 也可以内联加载，不过需要转换成 base64 同样式表一起加载，转换后的文件体积则会变为原来的 1.3 倍左右这是由 base64 编码决定的（编码知识链接）。 字体转换成 base64 的一个在线工具：https://transfonter.org/ 体积较大这个是 SVG 对比于 Iconfont 的一个不足之处，如下图。 Inline SVG 与 SVG Sprite 体积差不多。 开发成本三者的开发成本都差不多，不过 SVG 的两种方式都需要前期做些配置，后期开发就会顺手很多（单页应用）。 以 vue + vue cli 为例说明 Inline SVG 便捷使用。 1、 配置 Webpack loader:12345678910111213141516171819202122232425262728293031&#123; // 排除需要转换成 Inline SVG 的目录 exclude: [resolve('src/svgicons')], test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/, loader: 'url-loader', options: &#123; limit: 1, name: utils.assetsPath('img/[name].[hash:7].[ext]') &#125;&#125;,&#123; // 指定特定的目录用于 Inline SVG include: [resolve('src/svgicons')], test: /\\.svg$/, use: [ // 读取 SVG 源代码 &#123; loader: 'raw-loader' &#125;, // 精简优化 SVG 源代码 &#123; loader: 'svgo-loader', options: &#123; plugins: [ &#123; removeTitle: true &#125;, &#123; removeViewBox: false &#125;, &#123; removeDimensions: true &#125;, // ...其他参数 ] &#125; &#125; ]&#125; 2、 创建 SvgIcon.vue 组件:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;template&gt; &lt;div class=\"svg-icon\"&gt; &lt;div class=\"svg-icon-wrapper\" v-html=\"icon\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'SvgIcon', props: &#123; name: &#123; type: String, required: true, &#125;, &#125;, data () &#123; return &#123; icon: this.getIcon(), &#125; &#125;, watch: &#123; name () &#123; this.icon = this.getIcon() &#125;, &#125;, methods: &#123; getIcon () &#123; return require(`@/svgicons/$&#123;this.name&#125;.svg`) &#125;, &#125;,&#125;&lt;/script&gt;&lt;style lang=\"stylus\" scoped&gt;.svg-icon &#123; overflow hidden display inline-block width 1em height 1em &amp;-wrapper &#123; display flex align-items center &gt;&gt;&gt; svg &#123; width 100% height 100% fill currentColor *[fill='none'] &#123; fill none &#125; *[stroke='none'] &#123; stroke none &#125; &#125; &#125;&#125;&lt;/style&gt;&lt;style lang=\"stylus\"&gt;.svg-icon-hover &#123; &amp;:hover &#123; svg &#123; *[fill] &#123; fill currentColor &#125; *[stroke] &#123; stroke currentColor &#125; &#125; &#125;&#125;&lt;/style&gt; 3、使用：1234567&lt;SvgIcon name=\"arrow-right\" /&gt;或者&lt;a class=\"svg-icon-hover\" href=\"#\"&gt; &lt;SvgIcon name=\"arrow-right\" /&gt;&lt;/a&gt; SVG vs Iconfont 结论应该是 Inline SVG vs SVG Sprite vs Iconfont 的结论，如下图。 综上结论选择 Inline SVG 或许是一个不错地选择去替代 Iconfont 的使用方式。 扩展阅读 GitHub 网站很早之前已经将图标的展示方式由 Iconfont 转成了 Inline SVG, 这一篇文章是他们的描述：https://blog.github.com/2016-02-22-delivering-octicons-with-svg/ 很早的一篇文章关于两者的对比：https://css-tricks.com/icon-fonts-vs-svg/","pubDate":"Fri, 23 Nov 2018 01:00:00 GMT","guid":"https://aotu.io/notes/2018/11/23/SVG_vs_Image_vs_iconfont/","category":"WEB开发"},{"title":"Taro 1.1 发布，全面支持微信/百度/支付宝 小程序","link":"https://aotu.io/notes/2018/11/05/taro-1-1/","description":"在 9 月 16 日的掘金小程序大会上，Taro 正式发布了 1.0 版本。 作为一个多端统一开发框架，Taro 1.0 版本为广大开发者带来了许多激动人心的特性，帮助开发者们更方便快捷地开发多端应用。 前进的脚步没有停下，历时一个多月，Taro 1.1 版本正式来袭！ 从 1.0 到 1.1，期间产生了 500 余次 Commit，发布了 23 个版本，Taro 一直保持高速的迭代频率，只为不断打磨，为它注入更多优秀的特性，让更多开发者受益。 Taro 1.1 正式来袭更丰富的平台转换支持自从微信小程序诞生以来，小程序的优势大家有目共睹，各大互联网厂商开始摩拳擦掌，纷纷布局小程序领域，其中势头最劲的当属百度智能小程序和支付宝小程序。对于前端而言，既是机遇，因为平台愈多，带来的机会愈多；也是挑战，因为不同的平台总会各有差异，为每个平台维护一份代码，成本显然太高。 为了降低多端应用的开发成本，在已全面支持 微信小程序 的基础上，Taro 在 1.1 版本中加入了对 百度智能小程序 和 支付宝小程序 的支持。 支持百度智能小程序升级到 1.1 版本后，即可获得将现有项目转换成百度智能小程序的能力。 使用如下命令进行百度智能小程序端编译预览及打包： 123456789# npm script$ npm run dev:swan$ npm run build:swan# 仅限全局安装$ taro build --type swan --watch$ taro build --type swan# npx 用户也可以使用$ npx taro build --type swan --watch$ npx taro build --type swan 选择百度智能小程序模式，需要你下载并打开百度开发者工具，然后在项目编译完后选择项目根目录下 dist 目录进行预览。 目前已有使用 Taro 开发的首款百度智能小程序 “京东好物街” 正式上线，可以使用百度 APP，扫描以下二维码进行体验： 支持支付宝小程序支付宝小程序的转换方式与百度智能小程序一致。 你可以使用如下命令进行百度智能小程序端编译预览及打包： 123456789# npm script$ npm run dev:alipay$ npm run build:alipay# 仅限全局安装$ taro build --type alipay --watch$ taro build --type alipay# npx 用户也可以使用$ npx taro build --type alipay --watch$ npx taro build --type alipay 选择支付宝小程序模式，需要你下载并打开支付宝小程序开发者工具，然后在项目编译完后选择项目根目录下 dist 目录进行预览。 新增平台标识在加入 百度智能小程序 和 支付宝小程序 支持后，目前 Taro 已经提供了对 5 个平台的支持，分别是 微信/百度/支付宝/React Native/H5，为了方便开发者书写平台差异化代码，Taro 为每个平台提供了平台标识，并可以通过 process.env.TARO_ENV 来获得，其取值分别如下 weapp，代表微信小程序 h5，代表 H5 rn，代表 React Native swan，代表百度智能小程序，1.1 版本新增 alipay，代表支付宝小程序，1.1 版本新增 开放多端 UI 库打包能力在 1.0 版本中，Taro 的 build 命令新增了 --ui 参数，来将按照一定规则组织的代码打包成可以在 Taro 中使用的多端 UI 库。 并且，基于这一功能，Taro 推出了首个可以跨多端使用的多端 UI 库 Taro UI。 为了完善 Taro 生态，扩展 Taro 社区，在 1.1 版本中开放了多端 UI 库的打包能力，并提供了详细的开发指南。 同时 Taro 也提供了官方的多端 UI 库示例，这是一个完整规范的 UI 库开发例子，包含必要的项目改造以及测试套件，基于这个示例，开发者可以快速地开发一个多端 UI 库项目。 还有更多在 1.0 版本中，Taro 提供了对 微信小程序、H5 以及 React Native 的支持，而 1.1 版本，在原有支持的基础之上，对每一个平台进行不断完善，让其更加丰富完整。 微信小程序 F 调用 this.setState 时，JSON Diff 算法 Bug 修复 F 修复 this.setState 回调里再调用 this.setState 的 Bug A 新增 componentWillPreload 生命周期，用于数据预加载 A 支持在同一作用域对 JSX 赋值 F 多层 Map 循环嵌套包含条件判断时问题修复 F 中文字符被编译成 unicode 码问题修复 F 三元表达式解析问题修复 A 提升字符串模板的性能 H5 A H5 支持分包配置 F 修复 H5 后台页面依然执行生命周期的问题 F 修复 PUT 、DELETE 等请求 body 为对象时无法发送 body 的问题 A 增加 setTabBarStyle 与 setTabBarItem API A 增加 arrayBufferToBase64 与 base64ToArrayBuffer API A 编译打包支持将公共 npm 包抽离成 lib 库 React Native A 支持 TypeScript F 修复项目初始化后 less 编译报错 A 添加 config.window.navigationStyle 配置 A 添加 showNavigationBarLoading 与 hideNavigationBarLoading API A 增加 arrayBufferToBase64 与 base64ToArrayBuffer API F 修复样式支持警告 A watch 模式时代码按需编译 F 修复同一文件夹下多个JS文件样式引用错误 F app.json 的 expo 配置改为可覆盖 A 支持 Taro.pxTransform F iconPath 和 selectedPath 的为同一个路径导致的重复引用的报错 A 在 config 中添加 rn 的 expo 配置 A 支持 deviceRatio 自定义 更完整的功能迭代记录请参阅 CHANGELOG 未来规划Taro 将会继续保持高效迭代，以满足日益增长的多端开发需求 目前已经确认的开发计划可以参见 Taro 版本开发计划。 小程序转 Taro 代码开启内测值得注意的是，激动人心的小程序转 Taro 代码功能已经开发完成，进入内测阶段，可以通过如下命令安装到 canary 版本，进行体验 1$ npm i -g @tarojs/cli@canary 欢迎针对这一功能，提供宝贵意见，意见入口请戳 👈👈👈 同时，为了帮助 Taro 更好地成长，让 Taro 更好地回馈所有开发者，欢迎您给 Taro 提供优秀想法，或者直接贡献代码。","pubDate":"Mon, 05 Nov 2018 12:00:00 GMT","guid":"https://aotu.io/notes/2018/11/05/taro-1-1/","category":"小程序"},{"title":"单屏页面响应式适配玩法","link":"https://aotu.io/notes/2018/10/22/Responsive-single-screen-design/","description":"首先瞅一下效果图 接着就是思考怎么做，我的想法如下图。 把公共的 页头 、页脚、导航栏、边框 放到最顶层，比方说设置层级为 999，其他每个独立页则放在下面，然后切换页面的时候更新独立页的层级以达到效果图的效果（当然不能超过最顶层）。 适配 上面的方式已经把效果做出来了，接下来就是响应式适配了。 1、Mac OS + Chrome先考虑一下我自己的系统及显示器， MacBook Pro 1440 x 900 + 外设 hp 1920 x 1080 也就是说 Chrome 的网页可视区高度大概为： 900(或1080) - 180 = 720px 180 = 60 + 20 + 10012360: MAC 桌面程序坞动态尺寸，60 可能是我常用的尺寸吧，那就先这个20: MAC 桌面最顶部 icon 放置栏高度100: Chrome 标签页高度 + 地址栏高度 + 书签栏高度 2、Windows + Chrome然后我们再看看 Windows + Chrome 的情况，以 1366 x 768 为例， Chrome 的网页可视区高度大概为 768 - 150 = 618px 150 = 40 + 1101240: Windows 桌面底部程序坞尺寸110: Chrome 标签页高度 + 地址栏高度 + 书签栏高度 3、总结上面两点 以上两点的高度计算通过截图获得，可能会有些许误差。 所以不管在哪种系统下，浏览器的宽度与分辨率是保持一致的（程序坞在底部的时候，程序坞在左右两边一般情况对宽度没有影响），高度则根据系统及浏览器的不同各有不同，比方说 Safari 没有书签高度。 不同系统加浏览器占用的最高高度约为 180，最小约为 0（全屏的时候） 4、主流系统分辨率尺寸然后我们看下当前主流系统及分辨率有哪些 PC &amp; MAC &amp; Chrome12345678910111213常用1280 x 8001366 x 1024 (IPad Pro)1440 x 9001680 x 10501600 x 9001920 x 12002560 x 1440更高忽略2880 x 16203200 x 18005120 x 2880 PC &amp; Windows &amp; Chrome （或 PC &amp; MAC &amp; Chrome &amp; 外设显示器）123451280 x 720/10241366 x 7681440 × 9001600 x 9001920 x 1080 Mobile &amp; Android123360 x 480412 x 732待补充 Mobile &amp; IOS123IPhone 6: 375 x 667IPhone 6 Plus: 414 x 736IPhone X: 375 x 812 不上不下的 IPad:1768 x 1024 5、分析我们以宽度 1024 及以下算作移动端，以上算作 PC 端，所以两种选择 移动端适配一个移动端页面，PC 端适配一个 PC 端页面。 设计之初就想好一个页面适配两端，当然这个设计稿需要比较符合适配两端的条件。 6、别人适配是怎么做的？贴几个录制的视频~ 所以，单屏页面最好页面内容言简意赅，设计层面倾向于水平垂直都居中的情况，是最适合做好这个页面的，并且在各种尺寸变化的情况下能比较良好地展示UI，且开发成本也比较合理。 7、自身情况及实现我们是分两个页面做的，先看一下 PC 端设计稿 结合动画的展现形式，其实并不是很理想做响应式，但还是要适配。 本来想用 rem 做适配的，但是 rem 需要些写很多个匹配，即下面的代码12345678910111213@media all and (max-width: 1024px) &#123; html, body &#123; font-size: 10px; &#125;&#125;@media all and (max-width: 1366px) &#123; html, body &#123; font-size: 12px; &#125;&#125;// 1680 1920 2560 等 然后有个问题就是，@media 是根据 width 的变化来匹配的，完全按照桌面分辨率来显示是没问题的，不过高度随便调节一下（变小），而宽度还是很宽，这时候页面底部的部分文本就会溢出被隐藏掉。 我们不需要考虑更低端的浏览器，所以可以使用比较前沿的特性，如 pointer-events 等特性。 所以使用 vh 做适配方案，vh 是什么单位详情可以看下这篇文章，这里做个简单介绍。 12vw: 相对于浏览器可视区的宽度 1vw = 浏览器可视区宽度的 1%vh: 相对于浏览器可视区的高度 1vh = 浏览器可视区高度的 1% 也就是说 100vh 实际上等于浏览器可视区的高度，所以 px 与 vh 的换算我们举个例子说明一下（一个很简单的数学换算）。假设浏览器可视区高度为 720px，某个元素的宽度为 300px，那应该写成多少 vh 才与 300px 相等呢，如下。1300 ÷ (720 ÷ 100) ≈ 41.666 比如设计稿为 1920x1080（单屏设计高度应该更小一点，如适配第一节所说），可以写个 CSS 预处理函数，这样方便直接使用设计稿的尺寸，以 Sass 为例如下。 123456789@function vh( $value ) &#123; @return ( $value / 1080 / 100 ) + vh;&#125;或者@function vw( $value ) &#123; @return ( $value / 1920 / 100 ) + vw;&#125; 然后，300px 可以无缝写成 vh(300) 或 vw(300)。 so… 对于我们的页面选择 vh 一举两得，不用写很多 rem 匹配，也不会出现溢出的问题。 因为高度变矮，内容的尺寸会随之变小，而页面是 1190 宽，水平居中布局，所以当只改变浏览器宽度的情况下，不会出现宽度变化溢出问题（除非分辨率超大，然后高度居很高，只把宽度缩很小的情况，这个下面会说到）。写完后在上面列举的主流分辨率下一一测试通过。 看看效果（当然这个是最终效果，只改变宽度的拉伸适配在最后会说）： 8、特殊场景这里就是刚刚说到的 分辨率超大，然后高度居很高，只把宽度缩很小的情况，因为设计稿是长宽比例为横向矩形，所以明显与用长宽比为竖向的矩形来看页面是背道而驰的。 委屈委屈，但还是要兼容下，至少看起来要显示正常。 8.1、尝试 rem + vh 方案一开始想的是 rem + vh 结合使用，根元素 html 使用 vh，其他单位则使用 rem，然后找到有问题的宽高比，通过 @media 方式设置 html 为 vw 来达到适配。 事实是，rem 缩小到一定值就不会再缩小了，这个跟浏览器对字体大小限制为最小 12px 一样，看个例子。 根字体小于 12px 以后，rem 对应的值则都是设置的倍数乘以 12；设置根字体为 vh, vw 单位同理，rem 会在 vh, vw 换算达到 12 以后就不再改变。 PPPS: 是不是有点坑，应该字体的属性最小值为 12，而其他属性的值没有控制才对 所以，如果使用 rem + vh 方案，在界面缩小到一定尺寸后继续缩小，有些值达到最小值固定不变，而有些值仍在变小，UI 的展示就变得混乱。 8.2、落地方案，vh + vw + JavaScript 计算而直接在元素的属性值上设置为 vh 或 vw，所有的值都会实时变动，没有最小值（除了属性为字体有最小值），这样就最大程度减少 UI 变乱的情况了，除非缩到很小很小，那就…（此处省略 1000 个字）。 于是乎，现在的想法是 在原来以 vh 为基础的情况下，拷贝所有带 vh 单位的代码，把 vh 换成 vw，当然这些改动都在一个比如叫 .vw-mode 的类下面，基本上可以无缝迁移，只需替换 vh 函数名即可。 把 .vw-mode 下的内容设置为上下居中。 通过 JS 计算，当可视区比例为竖向比例时，则在顶层元素加上 .vw-mode 类名，当比例为横向比例时，则去掉 .vw-mode 类名。 大致的代码如下 CSS1234567891011.homepage.vw-mode &#123; font-size: vw(14); .com-width &#123; width: vw(1190); &#125; .hp-header &#123; padding-top: vw(30); // ...更多代码 &#125; // ...更多代码&#125; JS12345678910this.resizeHandler = () =&gt; &#123; const clientWidth = document.documentElement.clientWidth const clientHeight = document.documentElement.clientHeight // 当长宽比为竖向比例时 const isVerticalRatio = clientWidth / clientHeight &lt; 1370 / 890 $homepageElem.classList[isVerticalRatio ? 'add' : 'remove']('vw-mode')&#125;this.resizeHandler()window.addEventListener('resize', this.resizeHandler) 最后的结果就是上面那个 GIF 效果图了。 9、移动端移动端用户是没法操作浏览器的，所以基本上都是标准的长宽比，用 vh 最合适不过了，或 vw。 10、最后体验（官网）：https://ling.jd.com 体验浏览器：Chrome、Safari 新版，其他浏览器暂不支持","pubDate":"Mon, 22 Oct 2018 11:30:00 GMT","guid":"https://aotu.io/notes/2018/10/22/Responsive-single-screen-design/","category":"项目总结"},{"title":"十分钟打造 3D 物理世界","link":"https://aotu.io/notes/2018/10/18/cannonjs/","description":"前言在繁忙的业务中，为了缩短设计和开发的周期，我们的 H5 小游戏更多的会采用 2D 的视觉风格，但总是一个风格是很无趣的，所以最近搞了一个 3D 物理游戏的需求，在开发的过程中遇到了不少问题，希望通过这篇文章将关于 Three.js、Cannon.js、模型、工具等基础知识、问题总结分享给大家。 开始 3D 项目之前，首先从选择 3D 框架开始，老牌引擎 Three.js 和微软的 Babylon.js 都不错，针对自己的项目需求选择一款即可，这次我主要针对更熟悉的 Three.js 来讲。 Three.js 基础概念使用 Three.js 前，首先要理解以下几个核心概念： Sence 场景在 Three.js 中首先需要创建一个三维空间，我们称之为场景。 场景可以想象成是一个容器，里面存放着所有渲染的物体和使用的光源。 1let scene = new THREE.Scene() Axes 坐标轴Three.js 采用的是右手坐标系，拇指、食指、中指分别表示 X、Y、Z 轴的方向。 Camera 摄像机摄像机就相当于我们的双眼，决定了能够在场景中的所见所得。 Three.js 中提供以下几种摄像机类型，最为常用的是 PerspectiveCamera 透视摄像机，其他了解下即可。 ArrayCamera 阵列摄像机 一个 ArrayCamera 会包含多个子摄像机，通过这一组子摄像机渲染出实际效果，适用于 VR 场景。 CubeCamera 立方摄像机 创建六个 PerspectiveCamera（透视摄像机），适用于镜面场景。 StereoCamera 立体相机 双透视摄像机适用于 3D 影片、视差效果。 OrthographicCamera 正交摄像机OrthographicCamera（正交摄像机）定义了一个矩形可视区域，物体只有在这个区域内才是可见的，另外物体无论距离摄像机是远或事近，物体都会被渲染成一个大小，所以这种摄像机类型适用于 2.5D 场景（例如斜 45 度游戏）。 PerspectiveCamera 透视摄像机最为常用的摄像机类型，模拟人眼的视觉，根据物体距离摄像机的距离，近大远小。默认情况下，摄像机的初始位置 X、Y、Z 都为 0，摄像机方向是从正 Z 轴向负 Z 轴看去。通过 Near 和 Far 定义最近和最远的可视距离，Fov 定义可视的角度。 Mesh 网格有了场景和摄像头就可以看到 3D 场景中的物体，场景中的我们最为常用的物体称为网格。 网格由两部分组成：几何体和材质 Geometry 几何体记录了渲染一个 3D 物体所需要的基本数据：Face 面、Vertex 顶点等信息。 例如下面这个网格是由三角形组成，组成三角形的点称为顶点，组成的三角形称为面。 Material 材质材质就像是物体的皮肤，决定了几何体的外表。外表的定义可以让一个物体看起来是否有镜面金属感、暗淡、纯色、或是透明与否等效果。 Light 光源光源相当于在密闭空间里的一盏灯，对于场景是必不可少的 在 Three.js 常用的有这几种光源： AmbientLight 环境光源属于基础光源，为场景中的所有物体提供一个基础亮度。 DirectionalLight 平行光源效果类似太阳光，发出的光源都是平行的。 HemisphereLight 半球光源只有圆球的半边会发出光源。 PointLight 点光源一个点向四周发出光源，一般用于灯泡。 SpotLight 聚光灯光源一个圆锥体的灯光。 Shadow 阴影另外要注意并不是每一种光源都能产生阴影，目前只有三种光源可以： DirectionalLight 平行光源 PointLight 点光源 SpotLight 聚光灯光源 另外如果要开启模型的阴影的话，模型是由多个 Mesh 组成的，只开启父的 Mesh 的阴影是不行的，还需要遍历父 Mesh 下所有的子 Mesh 为其开启投射阴影 castShadow 和接收投射阴影 receiveShadow。 1234567// 遍历子 Mesh 开启阴影object.traverse(function(child) &#123; if (child instanceof THREE.Mesh) &#123; child.castShadow = true child.receiveShadow = true &#125;&#125;) glTF 模型格式前面提到 Three.js 引擎支持的格式非常的多，我们最为常见的格式有 .obj + .mtl + .jpg/.png，但使用这种模型格式存在一个问题，.obj 是静态模型，不支持动画数据存储，无法使用模型的动画，所以我建议使用 glTF 这种模型格式。 glTF 模型格式介绍传统的 3D 模型格式的设计理念更多是针对本地离线使用，所以这类 3D 模型格式没有针对下载速度或加载速度进行优化，文件大小往往会非常的大，随着 Web 端的兴起，对文件大小更为敏感的今天，我们该尝试别的模型格式了。 glTF 是由 Khronos Group 开发的 3D 模型文件格式，该格式的特点是最大程度的减少了 3D 模型文件的大小，提高了传输、加载以及解析 3D 模型文件的效率，并且它可扩展，可互操作。 第一版 glTF 1.0 于 2015 年 10 月 19 日发布，2017 年 6 月 5 日的 Web 3D 2017 大会发布了最终版本 glTF 2.0。 glTF 模型格式文件组成 模型文件 .gltf包含场景中节点层次结构、摄像机、网格、材质以及动画等描述信息。 二进制文件 .bin包含几何、动画的数据以及其他基于缓冲区的数据，.bin 文件可以直接加载到 GPU 的缓冲区中从而不需要额外的解析，因此能够高效传输和快速加载。 材质贴图文件 .png/.jpg3D 模型做凹凸贴图或普通贴图上所使用到文件。 glTF 模型格式导出官方在 .gltf 格式导出上提供了多种建模软件的导出插件，比如有： 3DS Max Exporter Maya Exporter Blender glTF 2.0 Exporter … 正巧我们常用的 C4D 建模软件官方没有提供 C4D 的导出插件，所以我们使用 C4D 导出后再导入 Blender，通过 Blender 作为中转站导出 glTF 格式文件。 但由于两个建模软件之间的材质并不能相通，导出后的模型文件材质效果表现不佳，这是因为 Blender 有自己的一套材质流程系统，例如有 glTF Metallic Roughness 和 glTF Specular Glossiness，需在此基础之上重新贴材质后导出解决。 另外注意的一点 Blender 的坐标系与 Three.js 是不同的，Blender 会将 Z 和 Y 对调位置，在导出时要选择 Convert Z up to Y up 进行对调。 Three.js 使用 glTF 模型Three.js 中使用 glTF 格式需额外引入 GLTFLoader.js 加载器。 123456var gltfLoader = new THREE.gltfLoader()gltfLoader.load('./assets/box.gltf', function(sence) &#123; var object = scene.gltf // 模型对象 scene.add(object) // 将模型添加到场景中&#125;) glTF 模型动画Animation Clip 动画片段前面提到 glTF 模型格式支持动画，模型动画可以使用 Blender 建模软件制作，通过 Blender 提供的时间轴编辑变形动画或者骨骼动画，每个动画可以编辑为一个 Action 动作，导出后使用 GLTFLoader 加载到 Three.js 中，可以拿到一个 animations 数组，animations 里包含了模型的每个动画 Action 动作。 123456789101112131415161718192021let gltfLoader = new THREE.gltfLoader()let mixer = nullgltfLoader.load('./assets/box.gltf', function(sence) &#123; let object = scene.gltf let animations = sence.animations // 动画数据 if (animations &amp;&amp; animations.length) &#123; mixer = new THREE.AnimationMixer(object) // 对动画进行控制 for (let i = 0; i &lt; animations.length; i++) &#123; mixer.clipAction(animations[i]).play() // 播放所有动画 &#125; &#125; scene.add(object)&#125;)function update() &#123; let delta = clock.getDelta(mixer) mixer.update(delta) // 更新动画片段&#125; Tween 动画对模型实现淡入淡出、缩放、位移、旋转等动画推荐使用 GSAP 来实现更为简便。 1234567891011121314151617181920212223let tween = new TimelineMax()tween .to(box.scale, 1, &#123; // 从 1 缩放至 2，花费 1 秒 x: 2, y: 2, z: 2, ease: Power0.easeInOut, // 速度曲线 onStart: function() &#123; // 监听动画开始 &#125;, onUpdate: function() &#123; // 监听动画过程 &#125;, onComplete: function() &#123; // 监听动画结束 &#125; &#125;) .to(box.position, 1, &#123; // 缩放结束后，位移 x 至 10，花费 1 秒 x: 10, y: 0, z: 0 &#125;) Draco 3D 模型压缩工具Draco 是一个用于压缩、解压缩 3D 几何网格和点云的开源库，为改善 3D 图形存储和传输而设计。 使用该工具可以对 glTF 格式进一步的压缩，会将 glTF 格式转为 .glb 格式，并且 .bin 压缩效果拔群，但是在 Three.js 中使用 .glb 格式需要引入额外的解析库，解析库文件包括 draco_decoder.js（791KB）、draco_decoder.wasm（323 KB）、draco_wasm_wrapper.js（64.3 KB）。所以更推荐当模型文件数量多，且文件较大时使用，否则得不偿失。 压缩使用 glTF Pipeline 工具，需要将三个种类的文件放在一起，执行命令行进行转换。 12$ npm install -g gltf-pipeline // 安装 gltf-pipeline 工具$ gltf-pipeline -i model.gltf -o model.glb // 指定某个 .gltf 文件转为 .glb 格式 Three.js 使用 .glb 格式引入 Draco 解码库 1234567891011// 实例化 loaderlet loader = new THREE.GLTFLoader()// Draco 解码库THREE.DRACOLoader.setDecoderPath('/examples/js/libs/draco')loader.setDRACOLoader(new THREE.DRACOLoader())// 加载 glTF 模型loader.load('models/gltf/box.gltf', function(gltf) &#123; scene.add(gltf.scene)&#125;) Cannon.js 3D 物理引擎目前在 Github 上搜索到的 3D 物理引擎库有 Cannon.js、Oimo.js、Ammo.js、Energy.js、Physijs 等等，大部分都已许久没有更新迭代了（长达好几年），项目的 Star 数量和 Issues 数量也不多，我们该如何选择？ Cannon.js、Oimo.js 和 Energy.js 作为 Babylon.js 的内置物理引擎，我们试着从这三个下手。 Energy.js：使用 C++ 编写转 JavaScript 的 3D 物理引擎，源码不可读，目前 Github 比较冷清。 Oimo.js：一款轻量级的 3D 物理引擎，文件大小 153 KB。 Cannon.js：完全使用 JavaScript 编写的优秀 3D 物理引擎，包含简单的碰撞检测、各种形状的摩擦力、弹力、约束等功能。 从综合性来看，我更偏向于 Cannon.js ，所以下面主要讲讲 Cannon.js。 Cannon.js 的特性以下是 Cannon.js 的特性，基本可以满足大部分的 3D 物理开发场景。 使用 Cannon.js我们以官方的一个平面加球刚体的例子来快速上手 Cannon.js。在线例子 1、初始化物理世界使用 Cannon.js 前需要创建 CANNON.World 对象，CANNON.World 对象是负责管理对象和模拟物理的中心。 创建完 CANNON.World 对象后，接着设置物理世界的重力，这里设置了负 Y 轴为 10 m/s²。 12let world = new CANNON.World()world.gravity.set(0, -10, 0) Cannon.js 提供了 Broadphase、NaiveBroadphase 两种碰撞检测阶段，默认是 NaiveBroadphase。 1world.broadphase = new CANNON.NaiveBroadphase() 2、创建动态球体创建 Body 分三个步骤： 创建形状 为形状添加刚体 将刚体添加到世界 12345678let sphereShape = new CANNON.Sphere(1) // Step 1 let sphereBody = new CANNON.Body(&#123; // Step 2 mass: 5, position: new CANNON.Vec3(0, 10, 0), shape: sphereShape&#125;)world.add(sphereBody) // Step 3 第一步创建了半径为 1 的球形，第二步创建球的刚体，如果刚体的 mass 属性设置为 0，刚体则会处于静止状态，静止的物体不会和其他静止的物体发生碰撞，我们这里为球的刚体设置了 5kg，球会处于动态的状态，会受的重力的影响而移动，会与其他物体发生碰撞。 3、创建静态平面和动态球体1234567891011// 平面 Bodylet groundShape = new CANNON.Plane()let groundBody = new CANNON.Body(&#123; mass: 0, shape: groundShape&#125;)// setFromAxisAngle 旋转 X 轴 -90 度groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -1.5707963267948966)world.add(groundBody) 创建平面形状，接着是刚体，这里设置了平面刚体的 mass 为 0，保证刚体处于静止状态。默认情况下平面的方向是朝向 Z 方向的（竖立着），可以通过 Body.quaternion.setFromAxisAngle 对平面进行旋转。 4、创建平面和球的网格前面创建的刚体在场景中并没有实际的视觉效果，这一步创建平面、球的网格。 1234567891011121314// 平面网格let groundGeometry = new THREE.PlaneGeometry(20, 20, 32)let groundMaterial = new THREE.MeshStandardMaterial(&#123; color: 0x7f7f7f, side: THREE.DoubleSide&#125;)let ground = new THREE.Mesh(groundGeometry, groundMaterial)scene.add(ground)// 球网格let sphereGeometry = new THREE.SphereGeometry(1, 32, 32)let sphereMaterial = new THREE.MeshStandardMaterial(&#123; color: 0xffff00 &#125;)let sphere = new THREE.Mesh(sphereGeometry, sphereMaterial)scene.add(sphere) 5、模拟世界接着我们为物理世界开启持续更新，并且将创建的球刚体与球网格关联起来。 123456789function update() &#123; requestAnimationFrame(update) world.step(1 / 60) if (sphere) &#123; sphere.position.copy(sphereBody.position) sphere.quaternion.copy(sphereBody.quaternion) &#125;&#125; 通过这几步，一个简单的物理场景就完成了，另外更多官方例子可以点击这里，可以查看到 Cannon.js 各个约束、摩擦力、模拟汽车等特性的例子。 其他：1、自定义物理材质需关联还是上面的例子，现在场景中刚体的物理特性都为默认的，我希望球的恢复系数高一点，即掉落时弹跳的更高。首先需要通过 CANNON.Material 实例物理材质，刚体使用该物理材质，最后通过 CANNON.ContactMaterial 来定义两个刚体相遇后会发生什么。 123456789101112131415161718192021// 平面let ground_cm = new CANNON.Material() // Step 1 : 实例 CANNON.Materiallet groundBody = new CANNON.Body(&#123; ... material: groundMaterial // Step 2 : 使用该物理材质 ...&#125;)// 球let sphere_cm = new CANNON.Material()let sphereBody = new CANNON.Body(&#123; ... material: sphere_cm ...&#125;)let sphere_ground = new CANNON.ContactMaterial(ground_cm, sphere_cm, &#123; // Step 3 : 定义两个刚体相遇后会发生什么 friction: 1, restitution: 0.4&#125;)world.addContactMaterial(sphere_ground) // Step 4 : 添加到世界中 2、刚体添加位移动画时需取消速度值比如我使用 GSAP 库对某个刚体进行 Y 轴向上移动，在 update 阶段需要将刚体的重力加速度设置为 0，否则动画结束后刚体会出现向下砸的效果。 12345678910111213let tween = new TimelineMax()tween.to(boxBody.position, 2, &#123; x: 0, y: 10, z: 0, update: function() &#123; // 归 0 设置 boxBody.velocity.setZero() boxBody.initVelocity.setZero() boxBody.angularVelocity.setZero() boxBody.initAngularVelocity.setZero() &#125;&#125;) 3、只检测碰撞，不发生物理效果允许只检测是否碰撞，实际不发生物理效果，需要为刚体添加以下属性： 1boxBody.collisionResponse = false 4、缩放刚体如果刚体需要缩放，则需要为刚体添加此属性，来更新刚体大小。 123456boxBody.updateMassProperties()let tween = new TimelineMax()tween.to(sphereBody.shapes[0], 2, &#123; radius: 0.2 // 缩放至 0.2&#125;) 点击交互在 3D 的世界中不能像我们在 DOM 中为一个节点绑定点击事件那么容易，在 Three.js 中提供了 THREE.Raycaster 方法处理点击交互，使用鼠标或者手指点击屏幕时，会将二维坐标进行转换，发射一条射线判断与哪个物体发生了碰撞，由此得知点击了哪个物体。点击这里官方例子 12345678910111213141516let raycaster = new THREE.Raycaster()let mouse = new THREE.Vector2()function onTouchEnd(ev) &#123; // 点击获取屏幕坐标 var event = ev.changedTouches[0] mouse.x = (event.clientX / window.innerWidth) * 2 - 1 mouse.y = -(event.clientY / window.innerHeight) * 2 + 1 raycaster.setFromCamera(mouse, camera) let intersects = raycaster.intersectObjects(scene, true) for (let i = 0; i &lt; intersects.length; i++) &#123; console.log(intersects[i]) // 与射线发生碰撞的物体 &#125;&#125; 性能方面模型精细程度在 Web 端由于性能的限制，在开发过程中要尽量避免做一些损耗性能较大的事情。 首先是模型的精细程度，在保证效果的前提下，尽量降低模型面的数量，也就是说采用低模模型，一些模型的凹凸褶皱感也可以通过凹凸贴图的方式去实现，越是复杂的模型在实时渲染的过程中就越占用手机性能。 光源与阴影另外一方面光源、阴影也是占性能，尤其是阴影。光源一般会使用平行光或者聚光灯，这种光源照射在物体上更为真实，使用半球光会稍微提升帧数，但效果略差些，阴影效果前面提到过要遍历每一个子 Mesh 接收产生阴影 castShadow 和接收阴影 receiveShadow，这相当耗费性能，开启后对阴影的精细程度以及阴影类型进行参数优化，在 Android 系统性能不太好，iOS 系统基本能保证流畅运行，所以建议根据设备系统优化。 12var n = navigator.userAgentif (/iPad|iPhone|iPod/.test(n) &amp;&amp; !window.MSStream) &#123; &#125; // 针对 iOS 系统使用阴影 抗锯齿与像素比抗锯齿是让模型的边缘效果更加圆滑不粗糙，也会占用一些性能，默认是关闭的，视情况开启。 1renderer.antialias = true // 开启抗锯齿 另外像素比 setPixelRatio，移动端由于 Retina 屏的缘故，一般会设置为 2，所以使用 window.devicePixelRatio 获取实际设备像素比动态设置的话，部分大屏手机的像素比有 3 的情况，所有会因为像素比过高造成性能问题。 12renderer.setPixelRatio(2) // 推荐renderer.setPixelRatio(window.devicePixelRatio) // 不推荐 工具推荐最后推荐一些在开发过程中常用的工具： OrbitControls 轨道控制器OrbitControls 是用于调试 Camera 的方法，实例化后可以通过鼠标拖拽来旋转 Camera 镜头的角度，鼠标滚轮可以控制 Camera 镜头的远近距离，旋转和远近都会基于场景的中心点，在调试预览则会轻松许多。 1new THREE.OrbitControls(camera, renderer.domElement) glTF Viewer 模型快速预览工具在设计师建模完成导出后，设计师并不知道在 Three.js 最终会呈现一个什么效果或者开发者也想快速的查看模型是否存在问题，glTF 官方贴心的提供了一款快速预览的工具，提供了两个版本：Web 版本和 Desktop 版本。 将 .gltf、.bin、.jpg/.png 文件拖拽到工具中，可以调试预览到模型的动画、变形目标、背景、线框模式、自动旋转、光源等功能。 Helper 相关调试模式Camera Helper 摄像机调试模式开启 Camera Helper 调试模式后，可以直观的看到 Camera 的 Fov、 Nera、Far 的参数效果。 1234let camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000)let helper = new THREE.CameraHelper(camera)scene.add(helper) Light Helper 光源调试模式聚光灯开启 Light Helper 调试模式后，可以直观的看到 distance、angle 的参数效果。 1234let light = new THREE.DirectionalLight(0xffffff)let helper = new THREE.DirectionalLightHelper(0xffffff)scene.add(helper) AxesHelper 坐标轴调试模式AxesHelper 是在场景的中心点，添加一个坐标轴（红色：X 轴、绿色：Y 轴、蓝色：Z 轴），方便辨别方向。 12let axesHelper = new THREE.AxesHelper(10)scene.add(axesHelper) Cannon.js 3D 物理引擎调试模式Cannon.js 3D 物理引擎提供的调试模式需引入 Debug renderer for Three.js，可以将创建的物理盒子、球、平面等显示线框，便于在使用过程中实时查看效果。 123456let cannonDebugRenderer = new THREE.CannonDebugRenderer(scene, world)function render() &#123; requestAnimationFrame(render) cannonDebugRenderer.update() // Update the debug renderer&#125; dat.GUI 图形用户界面调试工具在开发过程中，常常需要对参数变量进行微调，针对这个 Three.js 提供了 dat.GUI，dat.GUI 是一个轻量级的图形用户界面调试工具，使用后在右上角会出现一个 GUI 可视化参数配置区域，通过修改数值来实时查看结果。 123456789101112131415161718let opts = &#123; x: 0, y: 0, scale: 1&#125;let gui = new dat.GUI()gui.add(opts, 'x', -3, 3)gui.add(opts, 'y', -3, 3)gui.add(opts, 'scale', 1, 3)function loop() &#123; cube.position.x = opt.x cube.position.y = opt.y cube.scale.set(opts.scale, opts.scale, opts.scale) requestAnimationFrame()&#125; Stats 调试工具Stats 工具可以实时查看： FPS：最后一秒的帧数，越大越流畅 MS：渲染一帧需要的时间（毫秒），越低越好 MB：占用的内存信息 CUSTOM：自定义面板 123456789var stats = new Stats()stats.showPanel(1)document.body.appendChild(stats.dom)function animate() &#123; requestAnimationFrame(animate)&#125;requestAnimationFrame(animate) 尾巴最后，希望本篇文章所讲到的内容能帮助你更好的开发 3D 项目。另外，如果你有更好的实现思路，也欢迎你在下方评论区留言，感谢您的阅读。 参考 《Learning Three.js》 threejs babylonjs glTF 2.0 README Cannon.js Debug renderer for Three.js three-gltf-viewer stats.js","pubDate":"Thu, 18 Oct 2018 01:20:00 GMT","guid":"https://aotu.io/notes/2018/10/18/cannonjs/","category":"H5游戏开发"},{"title":"多端统一开发框架 Taro 1.0 正式发布","link":"https://aotu.io/notes/2018/09/18/taro-1-0-0/","description":"在 2018.6.7 我们对外开源了 多端统一开发框架——Taro。 Taro 是一个多端统一开发框架，它支持使用 React 的开发方式来编写可以同时在微信小程序、Web 、React Native 等多个平台上运行的应用，帮助开发者提升开发效率，改善开发体验，降低多端研发成本。 自开源以来，Taro 一直广受业界关注，其原理与思想也得到了广泛开发者的认可，这对于我们来说无疑是一件令人振奋的事。但是由于初期 Taro 测试与实现方式的不足，导致在开源期间 Bug 较多，受到了一些质疑。为此，我们痛定思痛，积极接受了开源社区的意见与帮助，并努力探索提升 Taro 稳定性与性能的方式。经过不断地迭代完善，已经让 Taro 浴火重生。 1.0.0 真的来了Taro 开源到现在 3 个月时间，累计发布 70 余日常版本及 20 余 Taro 1.0.0 的 beta 版本，经过近百个版本的迭代优化，我们亲身体会到 Taro 的 BUG 反馈越来越少，Taro 越来越健壮且完善，因此，我们有信心推出 1.0.0 正式版。 Taro 1.0.0 正式版在延续了之前版本优秀特性的同时，增加了更加丰富的特性与功能，并进行了多项小程序端/H5端的转换优化，同时带来了对 React Native 的转换支持。 全新的小程序组件化开源之初，由于种种原因，Taro 的微信小程序端组件化采用的是小程序 &lt;template /&gt; 标签来实现的，利用小程序 &lt;template /&gt; 标签的特性，将组件 JS 文件编译成 JS + WXML 模板，在父组件（页面）的模板中通过 &lt;template /&gt; 标签引用子组件的 WXML 模板来进行拼接，从而达到组件化的目的。 实践证明，Template 模板方案是一个失败的组件化方案，Taro 开源初期的 Bug 主要来源于此。因为这一方案将 JS 逻辑与模板拆分开了，需要手工来保证 JS 与模板中数据一致，这样在循环组件渲染、组件多重嵌套的情况下，要保证组件正确渲染与 props 正确传递的难度非常大，实现的成本也非常高。而且，囿于小程序 &lt;template /&gt; 标签的缺陷，一些功能（例如自定义组件包含子元素，等）无法实现。 所以，在经过艰辛的探索与实践之后，我们采用了小程序原生组件化来作为 Taro 的小程序端组件化方案，并且通过一些处理，绕开了小程序组件化的诸多限制，为 Taro 的稳定性打下了坚实基础，并带来了以下好处： 小程序端组件化更加健壮 尽可能减少由于框架带来的性能问题 依托官方组件化，方便以后解锁更多可能 全面支持小程序生态为了更好地帮助开发者使用 Taro 开发小程序，在 1.0.0 版本中，我们加强了对小程序生态的支持，主要提现在以下几个方面。 支持引用小程序端第三方组件库受益于小程序组件化重构，我们在 Taro 中支持了直接引用小程序端第三方组件库，让 Taro 可以融入到小程序生态中，为开发者提供更多便利。 目前实测已经支持了如下知名第三方组件库 echarts-for-weixin，ECharts 的微信小程序版本 iview-weapp，iview 的微信小程序版本 vant-weapp，轻量、可靠的小程序 UI 组件库 wxParse，微信小程序富文本解析自定义组件，支持HTML及markdown解析 当然，Taro 不仅仅只支持上述组件库，只要是按原生小程序规范编写的组件库都能在 Taro 中正常使用。 支持 Taro 代码与原生小程序代码混写与此同时，Taro 支持原生小程序代码与 Taro 代码混写，因此，可以使用 Taro 愉快地将旧的小程序项目慢慢地改造成 Taro 项目了。 支持小程序端分包加载以及插件引用我们在 Taro 中也加入对原生小程序分包加载功能的支持，配置的方式与原生小程序基本一致，只需要在 app.js 入口文件中加入 subPackage 字段即可。 123456789101112131415161718import Taro, &#123; Component &#125; from '@tarojs/taro'class App extends Component &#123; config = &#123; pages: [ 'pages/index', 'pages/logs' ], subPackages: [ &#123; root: 'moduleA', pages: [ 'pages/rabbit', 'pages/squirrel' ] &#125; ] &#125;&#125; 同时，Taro 也支持了使用小程序的插件功能，可以在 Taro 中直接引用第三方的插件 1234567891011121314151617import Taro, &#123; Component &#125; from '@tarojs/taro'import &#123; View &#125; from '@tarojs/Components'class PageA extends Component &#123; config = &#123; usingComponents: &#123; 'hello-component': 'plugin://myPlugin/hello-component' &#125; &#125; render () &#123; return ( &lt;View&gt; &lt;hello-component&gt;&lt;/hello-component&gt; &lt;/View&gt; ) &#125;&#125; 小程序 setState 性能优化在最初的开源版本中，小程序端 setState 仅仅是对小程序 setData 做了一次异步封装，最终调用 setData 更新的时候还是传入了完整数据。 但众所周知，小程序的视图层目前使用 WebView 作为渲染载体，而逻辑层是由独立的 JavascriptCore 作为运行环境，在架构上，WebView 和 JavascriptCore 都是独立的模块，并不具备数据直接共享的通道。在调用 setData 之后，会将数据使用 JSON.stringify 进行序列化，再拼接成脚本，然后再传给视图层渲染，这样的话，当数据量非常大的时候，小程序就会变得异常卡顿，性能很差。 Taro 在框架级别帮助开发者进行了优化，在 setData 之前进行了一次数据 Diff，找到数据的最小更新路径，然后再使用此路径来进行更新。例如 1234567891011121314151617181920// 初始 statethis.state = &#123; a: [0], b: &#123; x: &#123; y: 1 &#125; &#125;&#125;// 调用 this.setStatethis.setState(&#123; a: [1, 2], b: &#123; x: &#123; y: 10 &#125; &#125;&#125;) 在优化之前，会直接将 this.setState 的数据传给 setData，即 12345678this.$scope.setData(&#123; a: [1, 2], b: &#123; x: &#123; y: 10 &#125; &#125;&#125;) 而在优化之后的数据更新则变成了 12345this.$scope.setData(&#123; 'a[0]': 1, 'a[1]': 2, 'b.x.y': 10&#125;) 这样的优化对于小程序来说意义非常重大，可以避免因为数据更新导致的性能问题。 更加丰富的 JSX 语法支持前面已经提到 Taro 使用 React 语法规范来开发多端应用，这样就必然是采用 JSX 来作为模板，所以 Taro 需要将 JSX 编译成各个端支持的模板，其中以小程序端最为复杂，Taro 需要将 JSX 编译成小程序的 WXML 模板。 在开源的过程中，Taro 支持的 JSX 写法一直在不断完善，力求让开发体验更加接近于 React，主要包括以下语法支持： 支持 Ref，提供了更加方便的组件和元素定位方式 支持 this.props.children 写法，方便进行自定义组件传入子元素 在循环体内执行函数和表达式 定义 JSX 作为变量使用 支持复杂的 if-else 语句 在 JSX 属性中使用复杂表达式 在 style 属性中使用对象 只有使用到的变量才会作为 state 加入到小程序 data，从而精简小程序数据 目前，除了 Taro 官方 ESLint 插件 eslint-plugin-taro 中限制的语法之外，其他 JSX 语法基本都支持，而在原生组件化的帮助下，未来将会把 ESLint 的限制也逐条取消。 React Native 端转换支持在 Taro 1.0.0 中，我们将正式推出 React Native 端的转换支持，可以将现有 Taro 项目转换成 RN 版本，但需要注意对样式的处理，因为 RN 支持的样式非常有限，它是属于 CSS 的子集，具体请移步 RN 端转换注意事项。 Taro 的 RN 端基于 Expo 来进行编译构建 RN 程序，开发方式和编译命令与其他端类似，代码目录结构与现有 Taro 项目也基本一致 RN 编译预览模式 123456# npm script$ npm run dev:rn# 仅限全局安装$ taro build --type rn --watch# npx用户也可以使用$ npx taro build --type rn --watch 执行完命令之后，Taro 将会开始编译文件，最终获得 RN 端的编译指引，并且启动你的应用了 React Native 端完整开发流程请移步 React Native 开发流程介绍。 更加健全的 TypeScript 支持 随着前端项目的复杂度和规模的增加，近年来越来越多的项目开始使用 TypeScript 进行开发。Taro 也注意到了这一趋势，在开源之初就提供了对 TypeScript 的支持。在社区的帮助下，Taro 对 TypeScript 的支持也更加健全和完善： @tarojs/cli 可以直接创建 TypeScript 项目 @tarojs/components 包含了所有组件的类型定义 @tarojs/taro 的所有 API 也都包含了类型定义 @tarojs/redux 和 taro-ui 也都全部内置了类型定义 构建系统的编译器从 Babel 切换到原生 TypeScript 编译器，支持所有 TypeScript 语法 H5 端转换优化同时，Taro 在 H5 端的转换中，也进行诸多转换优化，修复了之前版本 H5 下诸多 Bug，让 H5 端路由系统更加健壮，同时开放了 Webpack 配置，可以让开发者自由地进行相关配置。 最后，附上 Taro 完整的 迭代历程。 重生之路正如上文提到，Taro 1.0.0 带来许多新的优秀特性，而同时，在社区内的 Bug 反馈已经愈来愈少，这也是开源期间不断努力打磨的结果。 从 6.7 到行文截止，Taro 一共经历了 1800 余次提交，平均每天近 20 次，最多的一天达 30 次。每一次提交都是进步，每一次提交都让 Taro 更加强大。经过这么多次迭代之后，已经让 Taro 获得重生，尤其是小程序组件化重构完成之后，Taro 从旧版架构的泥潭中一跃而出，成为更加健壮的开发框架。 在我们自己不断反思、优化的同时，也积极融入开源社区，依托社区的力量去建设 Taro。 GitHub ISSUES 是检验一个开源项目靠谱程度的标准之一，到目前为止，一共收到了 500 余个 ISSUES，已关闭近 400 个，关闭率在 80% 左右，未关闭的也大部分是一些功能的迭代需求。在 Taro 开发团队内部更是要求每一个 ISSUE 的响应时间不能超过 24 小时。正是因为这些 ISSUES ，让我们不断意识到 Taro 的不足，让我们知道如何去进行迭代。 同时，我们也一直鼓励社区的开发者积极提 PR，一个优秀的开源项目需要依靠整个社区的力量才能完善起来，到目前为止，一共收到了 120 余个 PR，已几近全部合入，这些 PR 为 Taro 注入了许多新鲜血液，让 Taro 更加健壮，我们也期望能有更多的开发者可以加入进来，一起来让 Taro 更加美好。 在 GitHub 上交流之余，我们也为开发者们开通了官方微信群供大家一起讨论 Taro 与技术，目前已有超过 1700 位开发者在关注、使用 Taro ，期待更多开发者的加入。 开发者生态完善在开源之初，Taro 一直处于封闭的状态，没有适配的 UI 库，也无法使用第三方组件库，而这些对开发效率的桎梏非常严重，社区内对此反馈较多。 所以，在 1.0.0-beta 版本开发期间，Taro 团队开发了多端 UI 库打包功能，提供了 taro build --ui 命令来将按照一定规则组织的代码打包成可以在 Taro 中使用的多端 UI 库。 并且，基于这一功能，我们推出了首个可以跨多端使用的多端 UI 库 Taro UI，目前已经支持了微信小程序与 H5 端，不久之后将完成 React Native 端的适配，可以同步提供给 React Native 端使用。 目前，多端 UI 库打包功能还处于内测阶段，在 Taro 1.0.0 发布之后，这一功能将同步发布，这样更多开发者就可以为 Taro 开发更丰富的多端组件库和 UI 库了。 未来规划Taro 将会继续保持迭代，目前已经规划了如下重要功能。 便捷测试在编译时与运行时提供代码诊断的功能，分析代码优劣，判定代码写法是否规范，以便帮助开发者规避一些由于写法带来的问题。 同时将提供一套测试方案，方便开发者书写并运行组件测试用例，提升代码质量。 多端同步调试目前 Taro 只能一次调试一个端，这对于开发多端应用来说效率略低，所以，计划提供微信小程序/ H5 / React Native 端同时调试的功能，可以一键启动多端同时编译，从而获得多端同步预览。 微信小程序/H5 代码转 Taro 代码目前已支持 Taro 代码到小程序代码、 H5 代码的转换，在未来，将提供逆向转换功能，帮助开发者将原本就存在的小程序/H5 项目直接转换成 Taro 项目，从而让原本只能运行在一端的项目获得多端运行的能力，降低开发者的重构成本。 与 React 新特性保持同步Taro 是遵循 React 语法规范的，但是 React 一直在迭代在变化，Taro 作为 React 的追随者也将会保持与 React 新特性同步，让 Taro 最大程度接近 React 开发体验。 快应用端支持目前 Taro 已经完成了快应用端组件库与 API 的适配，快应用端的文件转换与模板转换也正在开发中，不久的将来就会发布支持快应用端转换的版本。 支付宝小程序与百度智能小程序支持已预研支付宝小程序与百度智能小程序转换的可行性，即将进入开发。 多端可视化拖拽搭建目前 Taro 是依靠开发者手工编写代码来获得多端应用的，Taro 未来计划提供一个多端可视化拖拽搭建的功能，可以通过拖拽组件的方式来生成多端应用。 同时，Taro 将联合各大公司小程序开发团队，推出丰富的行业模板，为各行业应用可视化搭建提供完整的解决方案。 使用案例在开源期间，随着 Taro 的逐步完善，越来越多的开发者加入到 Taro 的使用、开发中，产生了更多更优秀的使用案例。 特别鸣谢Taro 的发展离不开广大开源爱好者的帮助，在此特别鸣谢广大 Taro 的使用者以及 Taro 主要贡献者（排名不分先后）。 aijiacy AlexStacker AsukaSong atzcl Boshen Bless-L beidan Chen-jj cuitianze dogbutcat finian frontlich guotie icodytan JerrySir js-newbee jas0ncn jinjinjin0731 kdong007 kenberkeley Lizhooh Littly lolipop99 lijinke666 looch ladjzero limichange leeenx luckyadam ly525 Manjiz mclockw Mr-Prune missmimia mushan0x0 Pines-Cheng rojer95 ronffy Songkeys Simbachen smoothdvd soulhat thewei wowlusitong xunge0613 YikaJ yuche zaaack zacksleo ZodiacSyndicate zuoge85 zuorichongxian","pubDate":"Tue, 18 Sep 2018 08:00:00 GMT","guid":"https://aotu.io/notes/2018/09/18/taro-1-0-0/","category":"小程序"},{"title":"Taro 在京东购物小程序上的实践","link":"https://aotu.io/notes/2018/09/11/taro-in-jd/","description":"Taro 简介Taro 是一个基于 React 语法规范的多端统一开发框架，大家可以通过 taro.aotu.io 进一步了解。而前段时间 Taro 发布后，京东购物小程序就开始了部分页面基于 Taro 的重构工作，本文便是对商品分类页使用 Taro 进行代码重构的一些实践分享。 混合开发模式过去的京东购物小程序未使用任何第三方框架，而是在原生小程序模式的基础上，进行了页面/组件基类、网络请求、本地存储、页面跳转等模块的封装。由于项目庞大（涉及 100 多个页面），把整个项目直接改造成 Taro 的开发方式肯定是不可行的，于是采用这么一种原生小程序与 Taro 相混合的开发模式，将部分旧页面使用 Taro 重构，部分新的页面则直接使用 Taro 进行开发。这里以商品分类页为例，先来看下原京东购物小程序项目的目录结构： 1234567891011121314151617181920├── dist│ ├── app.js│ ├── app.json│ ├── app.wxss│ ├── assets/│ ├── common/│ ├── libs/│ └── pages│ ├── cate│ │ ├── components/│ │ ├── index.js│ │ ├── index.json│ │ ├── index.wxml│ │ └── index.wxss│ └── index/├── src/├── README.md├── gulpfile.js├── package.json└── node_modules/ 1. 初始化 Taro在项目根目录处运行命令 taro init jdwxa-taro 进行初始化，完成后会新增一个名为 jdwxa-taro 的目录，Taro 相关的源代码就写在该目录中： 123456789101112131415161718├── dist/├── src/└── jdwxa-taro ├── config │ ├── dev.js │ ├── index.js │ └── prod.js ├── node_modules/ ├── package.json ├── project.config.json └── src ├── app.js ├── app.scss ├── index.html └── pages └── cate ├── index.js └── index.scss 2. Taro 配置独立的 Taro 项目会将包括 app.js、app.json、app.wxss 及页面文件均生成在 dist/ 目录中，而混合开发模式下只需要生成单个页面，这里需要对 Taro 进行一些配置，打开并编辑 config/index.js 文件： 1234567891011const config = &#123; outputRoot: '../dist', weapp: &#123; appOutput: false, npm: &#123; dir: '../../dist/common', name: 'taro' &#125; &#125;, // ...&#125; 如代码所示，outputRoot 字段为生成目标页面的存放路径，这里把它指向顶层（即原项目）的 dist/ 目录；weapp 部分，我们把 appOutput 设置成 false, 这样就不会生成 app.js、app.json、app.wxss 三个文件了，npm 字段则表示 Taro 运行时框架文件的存放目录，这里遵循原项目的规范，把它指定为 common/ 目录。这样 Taro 编译生成的目标文件就完美地融入进了原小程序项目。 3. 页面开发页面开发过程中，跟原生小程序最大的不同就是 React + JSX 的编码方式了，习惯了原生小程序的同学可能要一些适应过程，具体的编码就不细说了，这里提几点注意事项： 与小程序的 setData 方法不同，Taro 用于更新页面数据的 setState 是异步的，相关代码的执行时序需要特别注意； 为了方便 JSX 模板的书写，原先很长的 WXML 内容建议拆分成一些小的组件； 关于旧组件的复用，无论是小程序原生组件、普通 JS 模块、样式文件或是第三方组件库，都能很好的进行引入调用，这点无需担心； 目前对于 Taro 编译生成的目标代码，调试起来会有些困难，但对 SourceMap 的支持正在积极开发中。 4. 最终效果如今重构后的商品分类页已经在线上稳定运行有一段时间了，可以扫描下面的小程序码进行体验： Taro 带来的收益多端运行最大的收益便是可以生成多端版本，避免重复工作、节省开发成本。以分类页为例，只需运行 npm run build:h5 便可生成 H5 版本的分类页，运行效果和小程序一致，大家可以扫描下面的二维码进行体验： 注：以上仅为 Taro 生成的示例页面，由于一些业务组件尚未完全适配两端，所以 H5 版本暂时没有正式投入使用。 性能提升小程序项目中遇到的性能问题，大多是频繁地调用 setData 造成的，这是由于每调用一次 setData，小程序内部都会将该部分数据在逻辑层（运行环境 JSCore）进行类似序列化的操作，将数据转换成字符串形式传递给视图层（运行环境 WebView），视图层通过反序列化拿到数据后再进行页面渲染，这个过程下来有一定性能开销。 所以开发过程中，我们建议尽量对 setData 进行合并，减少调用次数，例如： 123this.setData(&#123; foo: 'Strawberry' &#125;)this.setData(&#123; foo: 'Strawberry', bar: 'Fields' &#125;)this.setData(&#123; baz: 'Forever' &#125;) 以上代码调用了 3 次 setData，造成不必要的性能开销，应对其进行合并： 12345this.setData(&#123; foo: 'Strawberry', bar: 'Fields', baz: 'Forever',&#125;) 而使用 Taro 之后，更新数据时调用的 setState 为异步方法，它会自动地对同一事件循环里的多次 setState 调用进行合并处理，此外还会进行数据 diff 优化，自动剔除那些未变更的数据，从而有效避免了此类性能问题。例如： 12345678910111213141516171819202122232425262728// 初始时this.state = &#123; foo: '1967', bar: &#123; foo: 'Strawberry', bar: 'Fields', baz: 'Forever', &#125;&#125;// 第一次更新this.setState(&#123; bar: &#123; foo: 'Norwegian', bar: 'Fields', baz: 'Forever', &#125;&#125;)// 紧接着进行第二次更新this.setState(&#123; foo: '1967', bar: &#123; foo: 'Norwegian', bar: 'Wood', baz: 'Forever', &#125;&#125;) 以上代码虽然经过两次 setState，但只有 bar.foo 和 bar.bar 的数据更新了，此时 Taro 内部会自动对数据进行合并、并剔除重复数据，最终执行代码为： 12345// this.$scope 在小程序环境中为 page 实例this.$scope.setData(&#123; 'bar.foo': 'Norwegian', 'bar.bar': 'Wood',&#125;) 其他收益比起原生小程序开发，Taro 带来了许多激动人心的特性（如支持 TypeScript、NPM、丰富的 JSX 语法、更高级的 ES 特性等等），不仅提升了开发体验，对自动化测试、持续构建等也会有不小的帮助。 举个例子，京东购物小程序里封装了一个 getImg 方法，该方法接受一个图片 url 及可选的宽高作为参数，然后根据设备类型决定是否使用 webp 格式、根据当前网络环境应用适当的图片压缩率、自动处理协议头和域名转换，最后生成符合目标大小的图片 url。我们要求所有的图片都必须经过 getImg 方法处理后才能进行展示，但由于 JS 方法只能在逻辑层进行调用，处理好后再传递给 WXML 进行展示，使得很难在自动化工具中进行检测，及时发现未调用 getImg 输出图片的情况。 而使用 Taro 之后，可以直接在 JSX 模板的 Image 标签输出时对 src 调用 getImg 方法进行处理，将此种写法作为规范明确后，就很容易通过自动化工具进行检测了： 123render () &#123; return &lt;Image src=&#123;getImg(url, 750)&#125; /&gt;&#125; So 对于现有项目来说，不需要进行整体重构，也能很好的将 Taro 集成进去。还等什么，赶紧试试吧~","pubDate":"Tue, 11 Sep 2018 09:00:00 GMT","guid":"https://aotu.io/notes/2018/09/11/taro-in-jd/","category":"小程序"},{"title":"首个多端 UI 组件库 - Taro UI 发布","link":"https://aotu.io/notes/2018/08/27/the-birth-of-taro-ui/","description":"前言Taro 是由凹凸实验室倾力打造的多端开发解决方案，旨在让一套代码在多端运行。Taro 1.0 版本发布后，也开始支持引用第三方的小程序组件库，如 iView、vant-weapp、echarts-for-weixin，然而目前市场仍然缺少一套由 Taro 编写而成的多端 UI 组件库。为了进一步丰富 Taro 的开发生态，让开发者有更好的开发体验和更快的开发速度，凹凸实验室自主设计了一套 UI 组件库，经过两个多月的精雕细琢，终于跟随 Taro 1.0 版本正式发布。 Taro UITaro UI 是一款由凹凸实验室打造、基于 Taro 编写的多端 UI 组件库。除了高颜值，Taro UI 最大的亮点就是支持多端运行。Taro UI 借助 Taro 支持多端运行的特点，只需解决不同平台 CSS 的表现差异问题，就可以在微信小程序/ H5 / ReactNative 等多端适配运行。 Github：https://github.com/NervJS/taro-ui 文档：https://taro-ui.aotu.io/ H5 版本预览： 微信小程序预览： 第一版组件共有六个模块、三十三个组件，未来还将继续丰富组件，增加一些常用业务组件。 特性 简单易用：支持 npm 安装，自动处理 npm 资源之间的依赖关系 框架支持：基于 Taro 开发组件，与 Taro 无缝衔接 多端适配：一套组件可以在微信小程序/ H5 / ReactNative 等多端适配运行 样式美观：小明哥(AT-UI 设计者、主程)亲自设计，细节把关，符合现代扁平化设计审美 组件丰富：提供丰富的基础组件，覆盖大部分使用场景，满足各种功能需求 按需引用：可按需使用独立的组件，不必引入所有文件，可最小化注入到项目中 多套主题：内置多套主题颜色，任君选择（将在 1.1 版本开放此特性） 快速开始安装 Taro安装 Taro 开发工具 @tarojs/cli 使用 npm 或者 yarn 全局安装，或者直接使用 npx 12$ npm install -g @tarojs/cli$ yarn global add @tarojs/cli 初始化项目使用命令创建模板项目1$ taro init myApp 安装 Taro UI12$ cd myApp$ npm i taro-ui 使用在代码中 import 组件并按照文档说明进行使用 import { AtButton } from &#39;taro-ui&#39; 示例在 /myApp/src/pages/index/index.jsx 文件添加以下代码1234567891011121314151617import Taro, &#123; Component, Config &#125; from '@tarojs/taro'import &#123; View &#125; from '@tarojs/components'import &#123; AtButton &#125; from 'taro-ui'import './index.scss'export default class Index extends Component &#123; config: Config = &#123; navigationBarTitleText: '首页' &#125; render () &#123; return ( &lt;View className='index'&gt; &lt;AtButton type='primary'&gt;按钮文案&lt;/AtButton&gt; &lt;/View&gt; ) &#125;&#125; 编译并预览进入项目目录开始开发，可以选择小程序预览模式，或者 H5 预览模式，若使用微信小程序预览模式，则需要自行下载并打开微信开发者工具，选择预览项目根目录。 微信小程序编译预览模式 123456# npm script$ npm run dev:weapp# 仅限全局安装$ taro build --type weapp --watch# npx用户也可以使用$ npx taro build --type weapp --watch H5编译预览模式 123456# npm script$ npm run dev:h5# 仅限全局安装$ taro build --type h5 --watch# npx用户也可以使用$ npx taro build --type h5 --watch 意见反馈如果有任何的意见或者建议，欢迎在 Github 创建 issue，感谢你的支持和贡献。","pubDate":"Mon, 27 Aug 2018 13:53:41 GMT","guid":"https://aotu.io/notes/2018/08/27/the-birth-of-taro-ui/","category":"小程序"},{"title":"为何我们要用 React 来写小程序 - Taro 诞生记","link":"https://aotu.io/notes/2018/06/25/the-birth-of-taro/","description":"在互联网不断发展的今天，前端程序员们也不断面临着新的挑战，在这个变化多端、不断革新自己的领域，每一年都有新的美好事物在发生。从去年微信小程序的诞生，到今年的逐渐火热，以及异军突起的轻应用、百度小程序等的出现，前端可以延伸的领域已经越来越广，当然也意味着业务在不断扩大。这时候，如何通过技术手段来提升开发效率，应对不断增长的业务，就是一个值得探索的话题。本文将对 Taro 诞生的故事，进行深入浅出地介绍，记录下这个忙碌的春夏之交发生的故事。 让人又爱又恨的微信小程序自 2017-1-9 微信小程序（以下简称小程序）诞生以来，就伴随着赞誉与争议不断。从发布上线时的不被大多数人看好，到如今的逐渐火热，甚至说是如日中天也不为过，小程序用时间与实践证明了自己的价值。同时于开发者来说，小程序的生态不断在完善，许多的坑已被踩平，虽然还是存在一些令人诟病的问题，但已经足见微信的诚意了。这个时候要是还没有上手把玩过小程序，就显得非常OUT了。 小程序对于前端程序员来说应该算得上是福音了，用前端相关的技术，获得丝般顺滑的 Native 体验，前端们又可以在产品小姐姐面前硬气一把了。可以说小程序给前端程序员打开了一扇新的大门，大家都应该感谢微信，但是从开发的角度来说，小程序的开发体验就非常值得商榷了，不仅语法上显得有些不伦不类，而且有些莫名其妙的坑也经常让人不经意间感叹一下和谐社会，从市面上层出不穷的小程序开发框架就可见一斑。以下就盘点部分小程序开发的痛点。 代码组织与语法在小程序中，一个页面 page 可能拥有 page.js、page.wxss、page.wxml 、page.json 四个文件 这样在开发的时候就需要来回进行文件切换，尤其是在同时开发模板和逻辑的时候，切来切去会显得尤其麻烦，影响开发效率，但小程序原生只支持这么写，就显得比较尴尬了。 而在语法上，小程序的语法可以说既像 React ，又像 Vue，不能说显得有点不伦不类吧，但在使用上总是感觉有些别扭，对于开发者来说，等于又要学习一套新的语法，提升了学习成本。而且，小程序的模板由于没有编辑器插件的支持，书写的时候也没有智能提示与 lint 检查，书写起来显得有些麻烦。 命名规范在小程序中到处可见规范不统一的情况 例如组件的属性，以最简单的 &lt;button /&gt; 组件为例，在小程序官方文档中，该组件的属性部分截图如下，大家可以感受下 &lt;button /&gt; 组件属性名既有以中划线分割多个单词的情况 session-form，也有多个单词连写的情况 bindgetphonenumber。当然这也不是最严重的，你可以说事件绑定的规范就是 bind + 事件名 ，而其他属性的规范就是中划线分割单词，我一度以为小程序就是这个作为标准，直到我看到了 &lt;progress /&gt; 组件 这和说好的不一样啊喂！ 同样的情况也出现在 页面 与 组件 的生命周期方法中，页面 的生命周期方法有 onLoad、onReady、onUnload 等，但到了 组件 中则是 created、attached 、ready 等，这样规范又不统一了，为啥 页面 的生命周期方法是 on+Xxx 的格式，但到了 组件 里缺不一样了呢，有点费解。 开发方式小程序官方提供了 微信开发工具 作为开发编译工具，而对于代码本身没有提供一个类似 webpack 的工程化开发工具，来解决开发中的一些问题，所以小程序原生的开发方式显得不那么现代化，这也是很多小程序开发框架致力于解决的问题。例如，在小程序开发中 不能使用 npm 管理依赖，在小程序中需要手动把第三方代码文件下载到本地，然后再 reuqire 进行使用，显得不那么优雅 不能使用 Sass 等 CSS 预处理器，由于没有预编译的概念，小程序开发中无法使用市面上流行的 CSS 预处理器，这样会使得样式代码难以管理 不完整的 ES Next 语法支持，小程序默认只能支持极少一部分 ES6 规范的语法，而 ES 是不断往前发展的，一些非常优秀的新语法特性就不能使用了 手动的文件处理，像图片压缩、代码压缩等等的一些文件操作，必须手工来处理，显得有些繁琐 以上就是从开发者的角度看到的一些小程序的开发问题，不过纵然有千般困难，我们总要面对，作为新时代的前端开发工程师，我们不能一味忍受问题，要保持技术的头脑，以技术作为武器，用技术手段去提升的我们开发体验。 突发奇想：我能不能用React来写小程序目前前端界言及前端框架，必离不开依然保持着统治地位的 React 与 Vue，这两个都是非常优秀的前端 UI 框架，而且在网上也经常能看到两个框架的粉丝之间热情交流，碰撞出一些思想火花，显得社区异常活跃。 而我们团队也在去年勇敢地抛弃了历史包袱，非常荣幸地引入了 React 开发方式，让我们团队丢掉了煤油灯，开始通上了电。而且也研发出了一款优秀的类 React 框架 Nerv ，让我们和 React 开发思想结合得更深。 与小程序的开发方式相比，React 明显显得更加现代化、规范化，而且 React 天生组件化更适合我们的业务开发，JSX 也比字符串模板有更强的表现力。那么这时候我们就在思考，我们能不能用 React 来写小程序？ 理性地探索类比通过对比体验 小程序和 React ，我们还是能发现两者之间相似的地方 生命周期小程序的生命周期和 React 的生命周期，在很大程度上是类似的，我们甚至能找到他们之间的对应关系 app 及页面的生命周期 小程序 React onLaunch componentWillMount onLoad componentWillMount onReady componentDidMount onShow 不支持，需要特殊处理 onHide 不支持，需要特殊处理 onUnload componentWillUnmount 可以看出，对于 app 及 页面 来说，除了 onShow 与 onHide 两个方法，其他方法都能在 React 中找到对应。 数据更新方式在 React 中，组件的内部数据是用 state 来进行管理的，而在小程序中组件的内部数据都是用 data 来进行管理，两者具有一定相似性。而同时在 React 中，我们更新数据使用的是 setState 方法，传入新的数据或者生成新数据的函数，从而更新相应视图。在小程序中，则对应的有 setData 方法，传入新的数据，从而更新视图。 两者都是以数据驱动视图的方式进行更新，而且 api 神似。 事件绑定小程序中绑定事件使用的是 bind + 事件名 的方式，例如点击事件，小程序中是 bindtap 1&lt;view bindtap=\"handlClick\"&gt;1&lt;/view&gt; 而在 React 里，则是 on + 事件名 的方式，例如点击事件， React web 中是 onClick 1&lt;View onClick=&#123;this.handlClick&#125;&gt;1&lt;/View&gt; 虽然看上去不一样，但其实是可以类比的，我们只需要在编译时将 on + 事件名 的形式编译成 bind + 事件名 的形式就可以了。 如此看来，两者之间有些相似，用 React 来写小程序貌似是可行的，但接下来我们就发现了巨大的差异。 巨大的差异React 与小程序之间最大的差异就是他们的模板了，在 React 中，是使用 JSX 来作为组件的模板的，而小程序则与 Vue 一样，是使用字符串模板的。这样两者之间就有着巨大的差异了。 JSX 12345678910render () &#123; return ( &lt;View className='index'&gt; &#123;this.state.list.map((item, idx) =&gt; ( &lt;View key=&#123;idx&#125;&gt;&#123;item&#125;&lt;/View&gt; ))&#125; &lt;Button onClick=&#123;this.goto&#125;&gt;走你&lt;/Button&gt; &lt;/View&gt; )&#125; 小程序模板 1234&lt;view class=\"index\"&gt; &lt;view wx:key=&#123;idx&#125; wx:for=\"&#123;&#123;list&#125;&#125;\" wx:for-item=\"item\" wx:for-index=\"idx\"&gt;&#123;&#123;item&#125;&#125;&lt;/view&gt; &lt;view bindtap=\"goto\"&gt;走你&lt;/view&gt;&lt;/view&gt; 众所周知，JSX 其实本质上就是 JS，我们可以在里面写任意的逻辑代码，这样一来就比字符串模板的表现力与操作性要强多了，况且，小程序的字符串模板功能比较羸弱，只有一些比较基本的功能。那这样的话，要如何来实现用 JSX 来写小程序模板呢。 编译原理的力量我们可以仔细来分析我们的需求，我们期望使用 JSX 来书写小程序模板，但小程序显然是不支持执行 JSX 代码的（要是支持的话，Taro 应该也就不存在了吧），我们也不能期望微信能给我们开个后门来跑 JSX。那么这个时候我们就想，我们要是能够将 JSX 编译成小程序模板就好了。 事实上在我们平时的开发中，这种编译的操作到处可见，babel 就是我们最常用的 JS 代码编译器，一般浏览器是不能支持一些非常新的语法特性的，但我们又想使用它们，这个时候就可以借助 babel 来将我们的高版本的 ES 代码，编译成浏览器可以运行的 ES 代码。而我们像要将 JSX编译成小程序模板，也是同样的道理。我们首先来了解一下 Babel 的运行机制。 Babel 作为一个 代码编译器 ，能够将 ES6/7/8 的代码编译成 ES5 的代码，其核心利用的就是计算中非常基础的编译原理知识，将输入语言代码，通过编译器执行，输出目标语言的代码。编译原理的一般过程就是，输入源程序，经过词法分析、语法分析，构造出语法树，再经过语义分析，理解程序正确与否，再对语法树做出需要的操作与优化，最终生成目标代码。 Babel 的编译过程亦是如此，主要包含三个阶段 解析过程，在这个过程中进行词法、语法分析，以及语义分析，生成符合 ESTree 标准 虚拟语法树(AST) 转换过程，针对 AST 做出已定义好的操作，babel 的配置文件 .babelrc 中定义的 preset 、 plugin 就是在这一步中执行并改变 AST 的 生成过程，将前一步转换好的 AST 生成目标代码的字符串 为了更好地理解这些过程，大家可以利用 Ast Explorer 这个网站接一下自己的代码，感受一下每一部分代码所对应的 AST 结构。 可以看到，一份源码经过编译器解析后，会变成类似如下的结构 1234567891011121314&#123; type: \"Program\", start: 0, end: 78, loc: &#123; start, end &#125; sourceType: \"module\", body: [ &#123; type: \"VariableDeclaration\", ... &#125;, &#123; type: \"VariableDeclaration\", ... &#125;, &#123; type: \"FunctionDeclaration\", ... &#125;, &#123; type: \"ExpressionStatement\", ... &#125; ] ...&#125; 其中，body 里包含的就是我们示例代码的语法树结构，第一个 VariableDeclaration 对应的是 const a = 1，第三个 FunctionDeclaration 对应的则是 function sum (a, b) { }，分别就是 JS 中的变量定义与函数定义，每一个树节点里都会包含许多子节点，这样就形成了一个树形结构，更多的节点类型，请参考 babel types。 当然我们在这儿只是简单介绍下编译原理与 babel，编译原理是一门非常深奥的课程， babel 也是一个非常优秀的工具，希望在后续的文章中能和大家再详细探讨这一部分内容。 再次回到我们的需求，将 JSX 编译成小程序模板，非常幸运的是 babel 的核心编译器 babylon 是支持对 JSX 语法的解析的，我们可以直接利用它来帮我们构造 AST，而我们需要专注的核心就是如何对 AST 进行转换操作，得出我们需要的新 AST，再将新 AST 进行递归遍历，生成小程序的模板。 JSX 代码 123456789&lt;View className='index'&gt; &lt;Button className='add_btn' onClick=&#123;this.props.add&#125;&gt;+&lt;/Button&gt; &lt;Button className='dec_btn' onClick=&#123;this.props.dec&#125;&gt;-&lt;/Button&gt; &lt;Button className='dec_btn' onClick=&#123;this.props.asyncAdd&#125;&gt;async&lt;/Button&gt; &lt;View&gt;&#123;this.props.counter.num&#125;&lt;/View&gt; &lt;A /&gt; &lt;Button onClick=&#123;this.goto&#125;&gt;走你&lt;/Button&gt; &lt;Image src=&#123;sd&#125; /&gt;&lt;/View&gt; 编译生成小程序模板 123456789101112&lt;import src=\"../../components/A/A.wxml\" /&gt;&lt;block&gt; &lt;view class=\"index\"&gt; &lt;button class=\"add_btn\" bindtap=\"add\"&gt;+&lt;/button&gt; &lt;button class=\"dec_btn\" bindtap=\"dec\"&gt;-&lt;/button&gt; &lt;button class=\"dec_btn\" bindtap=\"asyncAdd\"&gt;async&lt;/button&gt; &lt;view&gt;&#123;&#123;counter.num&#125;&#125;&lt;/view&gt; &lt;template is=\"A\" data=\"&#123;&#123;...$$A&#125;&#125;\"&gt;&lt;/template&gt; &lt;button bindtap=\"goto\"&gt;走你&lt;/button&gt; &lt;image src=\"&#123;&#123;sd&#125;&#125;\" /&gt; &lt;/view&gt;&lt;/block&gt; 这时候，聪明的你应该就能发现问题的难点所在了，要知道小程序的模板只是字符串，而 JSX 则是真正的 JS 代码扩展，其语法之丰富，显然不是字符串模板所能比，在这一步中，我们要做的操作，包括但不仅限于如下 理解三目运算符与逻辑表达式，例如三目运算符 abc ? : &lt;View&gt;1&lt;/View&gt; : &lt;View&gt;2&lt;/View&gt; 需要编译成 &lt;view wx:if=&quot;&quot;&gt;1&lt;/view&gt;&lt;view wx:else&gt;2&lt;/view&gt; 理解数组 map 语法，例如 map 的使用 abc.map(item =&gt; &lt;View&gt;item&lt;/View&gt;) 需要编译成 &lt;view wx:for=&quot;&quot; wx:for-item=&quot;item&quot;&gt;item&lt;/view&gt; 等等 以上仅仅是我们转换规则的冰山一角，JSX 的写法极其灵活多变，我们只能通过穷举的方式，将常用的、React 官方推荐的写法作为转换规则加以支持，而一些比较生僻的，或者是不那么推荐的写的写法则不做支持，转而以 eslint 插件的方式，提示用户进行修改。目前我们支持的 JSX 转换规则，大致能覆盖到 JSX 80% 的写法操作。 关于 JSX 转小程序模板这一部分，我们将在后续的技术原理分析系列文章中，详细为大家介绍。 还能不能干点别的经过我们一次次的探索，以及一波波猛如虎的操作，我们已经可以将类 React 代码转成小程序可以跑的代码了，也就是说我们已经可以正式以 React 的方式来写小程序的代码了。喜大普奔！但是我们激动之余，冷静下来继续思考，我们还能不能干点别的有意思的事情呢。 分析一下需求我们发现，在平常的工作中，我们业务通常有一些多端的需求，就是要求小程序要有，H5 要有，甚至 RN 也能有就最好了，我猜产品经理还看不上快应用，不然肯定要求我们快应用也上一套吧，反正你们不是经常号称代码优秀、高度可复用么。这个时候，你就会发现，差不多的界面和逻辑，你可能需要重复写上好几轮，这时候要是有个多端代码生成工具就好了，只写一份代码，可以多端运行。Write once, run anywhere，相信是所有工程师的梦想。 依然编译原理的力量这时候我们回忆一下前文的内容，将一份代码编译成多端代码，这不正是编译原理干的事么，我们可以输入一份源代码，针对不同的端设定好对应的转换规则，再一键转换出对应端的代码。而且由于我们已经遵循 React 语法了，那我们再转成 H5 端（使用 Nerv）与 RN 端（使用 React）也就有了天然的优势。 设计思路补完但是仔细思考我们又会发现，仅仅将代码按照对应语法规则转换过去后，还远远不够，因为不同端会有自己的原生组件，端能力 API 等等，代码直接转换过去后，可能不能直接执行。例如，小程序中普通的容器组件用的是 &lt;view /&gt;，而在 H5 中则是 &lt;div /&gt;；小程序中提供了丰富的端能力 API，例如网络请求、文件下载、数据缓存等，而在 H5 中对应功能的 API 则不一致。 所以，为了弥补不同端的差异，我们需要订制好一个统一的组件库标准，以及统一的 API 标准，在不同的端依靠它们的语法与能力去实现这个组件库与 API，同时还要为不同的端编写相应的运行时框架，负责初始化等等操作。通过以上这些操作，我们就能实现一份一键生成多端的需求了。在 Taro 最初的设计中，我们组件库与 API 的标准就是源自小程序的，因为我们觉得既然已经有定义好的组件库与 API 标准，那为啥不直接拿来使用呢，这样不仅省去了定制标准的冥思苦想，同时也省去了为小程序开发组件库与 API 的麻烦，只需要让其他端来向小程序靠齐就好。 可能有些人会有疑问，既然是为不同的端实现了对应的组件库与端能力 API （小程序除外，因为组件库和 API 的标准都是源自小程序），那么是怎么能够只写一份代码就够了呢？因为我们有编译的操作，在书写代码的时候，只需要引入标准组件库 @tarojs/components 与运行时框架 @tarojs/taro ，代码经过编译之后，会变成对应端所需要的库。 既然组件库以及端能力都是依靠不同的端做不同实现来抹平差异，那么同样的，如果我们想为 Taro 引入更多的功能支持的话，有时候也需要按照这个套路来。例如，为了提升开发便利性，我们为 Taro 加入了 Redux 支持，我们的做法就是，在小程序端，我们实现了 @tarojs/redux 这个库来作为小程序的 Redux 辅助库，并且以他作为基准库，它具有和 react-redux 一致的 API，在书写代码的时候，引用的都是 @tarojs/redux ，经过编译后，在 H5 端会替换成 nerv-redux（Nerv的 Redux 辅助库），在 RN 端会替换成 react-redux。这样就实现了 Redux 在 Taro 中的多端支持。 以上就是 Taro 的整体设计思路，里面还有很多细节没有展开去阐述，可能大家会觉得有些意犹未尽，后续我们将会产出一系列的文章来阐述 Taro 的技术细节，例如 《Taro 开发工具原理分析》、《Taro 代码编译的背后》、《深入浅出 JSX 转小程序模板》等等。 最后的最后Taro 从立项之初到现在已经差不多有了三个月左右的时间，从最初的激烈讨论方案，各种思想的碰撞，到方案逐渐成型，进入火热的开发迭代，再到现在的小程序端和 H5 端顺利支持，从而决定走向开源。这一路走来，收获颇丰，既有跟团队小伙伴一起创造的激动，也有无数个日夜加班的苦思。Taro 是凹凸实验室的诚意之作，我们也将会一直维护下去，希望 Taro 能越来越好，帮助更多人创造更多价值。 项目官网：https://taro.aotu.io/ 项目 GitHub：https://github.com/NervJS/taro 同时，有任何关于 Taro 希望沟通交流的，欢迎~","pubDate":"Mon, 25 Jun 2018 04:53:41 GMT","guid":"https://aotu.io/notes/2018/06/25/the-birth-of-taro/","category":"小程序"},{"title":"多端统一开发框架 - Taro","link":"https://aotu.io/notes/2018/06/07/Taro/","description":"Taro - 多端开发框架Taro 是什么？Taro 是由凹凸实验室打造的一套遵循 React 语法规范的多端统一开发框架。 现如今市面上端的形态多种多样，Web、App 端(React Native)、微信小程序等各种端大行其道，当业务要求同时在不同的端都要求有所表现的时候，针对不同的端去编写多套代码的成本显然非常高，这时候只编写一套代码就能够适配到多端的能力就显得极为需要。 使用 Taro，我们可以只书写一套代码，再通过 Taro 的编译工具，将源代码分别编译出可以在不同端（微信小程序、H5、App 端等）运行的代码。同时 Taro 还提供开箱即用的语法检测和自动补全等功能，有效地提升了开发体验和开发效率。 Taro 能提供什么？一次编写，多端运行既然是一个多端解决方案，Taro 最重要的能力当然是写一套代码输出多端皆可运行的代码。目前 Taro 已经支持一套代码同时生成 H5 和小程序，App端(React Native)端也即将支持，同时诸如快应用等端也将得到支持。 同时 Taro 也已经投入到了生产环境使用，目前已经支撑了一个 3 万行代码小程序 TOPLIFE 的开发并上线。京东购物 小程序和 一起有局 小程序也在使用 Taro 部分重构中，即将上线。未来也将接入更多业务。 现代前端开发流程和微信自带的小程序框架不一样，Taro 积极拥抱社区现有的现代开发流程，包括但不限于： NPM 包管理系统 ES6+ 语法 自由的资源引用 CSS 预处理器和后处理器（SCSS、Less、PostCSS） 对于微信小程序的编译流程，我们从 Parcel 得到灵感，自研了一套打包机制将 AST 不断传递，因此代码分析的速度得到了很大的提高。一台 2015 年 的 15寸 RMBP 在编译上百个组件时仅需要大约 15 秒左右。 和 React 完全一致的 API 和组件化系统在 Taro 中，你不用像小程序一样区分什么是 App 组件，什么是 Page 组件，什么是 Component 组件，Taro 全都是 Component 组件，并且和 React 的生命周期完全一致。可以说，一旦你掌握了 React，那就几乎掌握了 Taro。而学习 React 的资源也几乎是汗牛充栋，完全不用担心学不会。 Taro 和 React 一样，同样使用声明式的 JSX 语法。相比起字符串的模板语法，JSX 在处理精细复杂需求的时候会更得心应手。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 一个典型的 Taro 组件import Taro, &#123; Component &#125; from '@tarojs/taro'import &#123; View, Button &#125; from '@tarojs/components'export default class Home extends Component &#123; constructor (props) &#123; super(props) this.state = &#123; title: '首页', list: [1, 2, 3] &#125; &#125; componentWillMount () &#123;&#125; componentDidMount () &#123;&#125; componentWillUpdate (nextProps, nextState) &#123;&#125; componentDidUpdate (prevProps, prevState) &#123;&#125; shouldComponentUpdate (nextProps, nextState) &#123; return true &#125; add = (e) =&gt; &#123; // dosth &#125; render () &#123; const &#123; list, title &#125; = this.state return ( &lt;View className='index'&gt; &lt;View className='title'&gt;&#123;title&#125;&lt;/View&gt; &lt;View className='content'&gt; &#123;list.map(item =&gt; &#123; return ( &lt;View className='item'&gt;&#123;item&#125;&lt;/View&gt; ) &#125;)&#125; &lt;Button className='add' onClick=&#123;this.add&#125;&gt;添加&lt;/Button&gt; &lt;/View&gt; &lt;/View&gt; ) &#125;&#125; 良好的开发效率和体验鉴于 Taro 的语法和 React 完全一样，因此编辑器/IDE 能够对 Taro 的支持和 React 是几乎一样的。现代的编辑器默认都对 JSX 进行了支持，如果没有，找一个插件也是非常容易的事情。但毕竟我们做 Taro 就是为了提升开发效率和开发体验，而真正使用 Taro 的人就是我们自己或正坐在我们旁边的同事。因此在此基础上，我们又对 Taro 开发体验进行了进一步加强。 自定义 ESLint 规则我们之前提到过，当学会了 React，其实也差不多会 Taro 了。其中很重要的一个原因就是我们对 Taro 不支持的语法和特性单独写了 ESLint 规则：开发者只管写代码，写到不支持的语法/特性编辑器会报错，并给出报错信息和一个文档地址描述。 类型安全和运行时检测JSX 的本质就是 JavaScript 的语法增强，所以例如没有 import 组件等语法错误在编译期就能发现。开发者也可以使用 TypeScript 或 Flow 来对代码的可靠性进一步增强，或使用 PropsType 在运行时进一步保障代码的鲁棒性。 高效的自动补全和 ES6+ 语法Taro 的所有 API（包括微信小程序等端能力接口）都有智能的提醒和自动补全，包括接口的参数和返回值。 Taro 的设计思路我们的初心就是做一款能够适配多端的解决方案，结合业务场景、技术选型和前端历史发展进程，我们的解决方案必须满足下述要求： 代码多端复用，不仅能运行在时下最热门的 H5、微信小程序、React Native，对其他可能会流行的端也留有余地和可能性。 完善和强大的组件化机制，这是开发复杂应用的基石。 与目前团队技术栈有机结合，有效提高效率。 学习成本足够低 背后的生态强大 同时满足这几个需求并不容易，在我们经过充分地调研和思考之后发现只有 React 体系能够满足我们的需求。而对于微信小程序而言，使用 React 完全没有办法进行开发——直到我们从 codemod 得到灵感： 在一个优秀且严格的规范限制下，从更高抽象的视角（语法树）来看，每个人写的代码都差不多。 也就是说，对于微信小程序这样不开放不开源的端，我们可以先把 React 代码分析成一颗抽象语法树，根据这颗树生成小程序支持的模板代码，再做一个小程序运行时框架处理事件和生命周期与小程序框架兼容，然后把业务代码跑在运行时框架就完成了小程序端的适配。 对于 React 已经支持的端，例如 Web、React Native 甚至未来的 React VR，我们只要包一层组件库再做些许样式支持即可。鉴于时下小程序的热度和我们团队本身的业务侧重程度，组件库的 API 是以小程序为标准，其他端的组件库的 API 都会和小程序端的组件保持一致。 技术选型与权衡在我们前面社区已经有多个优秀的框架以小程序为核心对多端适配进行了探索，我们将各个开发框架的主要特点和特性进行了对比并制成图表。大家可以结合团队技术栈、技术需求以及框架特点、特性进行选型和权衡。 结语经过数个月的开发，Taro 从第一次 commit 到发展成包括 16 个包，十多位同学共同参与的大型项目。与此同时，Taro 也在生产环境支撑了数个复杂业务线上项目的开发，将来也会支撑更多业务。 Taro 的技术方案和实现也根植于社区，我们也希望为技术社区的发展壮大贡献一份自己的力量。秉持着凹凸实验室长久以来开源、开放、共享的优良传统，我们今天将 Taro 全部代码开源，为广大开发者快速开发多端项目提供一整套技术解决方案。未来，我们也将继续拓展 Taro 现有能力，支持更多端能力，继续完善开发者体验，提高开发者效率，帮助更多开发者，同时也从社区中汲取养分，让 Taro 变得更加强大。 官网：http://taro.aotu.io/ GitHub: http://github.com/nervjs/taro 如果你还没听过 Nerv，可以来这里看看：https://nerv.aotu.io/","pubDate":"Thu, 07 Jun 2018 03:04:27 GMT","guid":"https://aotu.io/notes/2018/06/07/Taro/","category":"小程序"},{"title":"图像处理 - ImageMagick 简单介绍与案例","link":"https://aotu.io/notes/2018/06/06/ImageMagick_intro/","description":"在客户端我们可以用 PhotoShop 等 GUI 工具处理静态图片或者动态 GIF 图片，不过在服务器端对于 WEB 应用程序要处理图片格式转换，缩放裁剪，翻转扭曲，PDF解析等操作， GUI 软件就很难下手了，所以此处需要召唤命令行工具来帮我们完成这些事。 ImageMagick: 是一款创建、编辑、合成，转换图像的命令行工具。支持格式超过 200 种，包括常见的 PNG, JPEG, GIF, HEIC, TIFF, DPX, EXR, WebP, Postscript, PDF, SVG 等。功能包括调整，翻转，镜像(mirror)，旋转，扭曲，修剪和变换图像，调整图像颜色，应用各种特殊效果，或绘制文本，线条，多边形，椭圆和贝塞尔曲线等。 官网：https://www.imagemagick.org 下面放个小标识。 安装 ImageMagick 支持 Linux, Windows, Mac OS X, iOS, Android OS 等平台https://www.imagemagick.org/script/download.php 因为我是 MAC 机器，演示一下 brew 的安装方式咯1brew install imagemagick 基本命令与格式1、基本命令 ImageMagick 包括一组命令行工具来操作图片，安装好 ImageMagick 后，终端就可以使用如下命令了。 magick: 创建、编辑图像，转换图像格式，以及调整图像大小、模糊、裁切、除去杂点、抖动 ( dither )、绘图、翻转、合并、重新采样等。convert: 等同于 magick 命令。identify: 输出一个或多个图像文件的格式和特征信息，如分辨率、大小、尺寸、色彩空间等。mogrify: 与 magick 功能一样，不过不需要指定输出文件，自动覆盖原始图像文件。composite: 将一个图片或多个图片组合成新图片。montage: 组合多个独立的图像来创建合成图像。每个图像都可以用边框，透明度等特性进行装饰。 compare: 从数学和视觉角度比较源图像与重建图像之间的差异。display: 在任何 X server 上显示一个图像或图像序列。animate: 在任何 X server 上显示图像序列。import: 保存 X server 上的任何可见窗口并把它作为图像文件输出。可以捕捉单个窗口，整个屏幕或屏幕的任意矩形部分。conjure: 解释并执行 MSL ( Magick Scripting Language ) 写的脚本。stream: 一个轻量级工具，用于将图像或部分图像的一个或多个像素组件流式传输到存储设备。在处理大图像或原始像素组件时很有用。 2、命令格式基本命令的使用，遵循 Unix 风格的标准格式：1command [options] input_image output_image 比如我们将一张宽高 300x300 的图片 goods.png 转换成 200x200 的goods.jpg，可以这样用1convert -resize 200x200 goods.png goods.jpg -resize 定义图片尺寸，ImageMagick 所有的选项参数都在这个【命令行选项手册】。 但是随着功能的复杂，命令缓慢扩大成了这样的格式：1command [options] image1 [options] image2 [options] output_image 于是上面的命令也可以写成这样1convert goods.png -resize 200x200 goods.jpg 笔记：个人建议，如果转换的是一张图片，那么用第一种格式，因为像 -density 等一些选项必须放在 command 与 input_image 之间，所以为了省记都不写错，都写在 command 与 input_image 之间岂不很好。但是如果是多张图片转换，就需要按第二种格式，正确输出命令选项了。 提示：如果上面的工具命令在计算机上不可以使用，则可以把它们当作 magick 命令的子命令使用，例如1magick identify goods.png 3、指定文件格式默认情况下 ImageMagick 会读取图像中唯一标识格式的签名来确定文件格式，如果没有，则根据文件的扩展名来确定格式，如 image.jpg 被认为 jpeg 格式文件，如果都获取不到，则需要手动指定文件的格式。命令格式为 format:input_or_output_image。 输入文件一般情况应该不需要手动指定文件格式，输出文件的时候，png 格式分 png8、png24 等格式，如果 png8 格式的文件能够满足需求，指定合理的格式可以缩小文件的大小，示例如下。12convert goods.png png8:goods_8.pngconvert goods.png png24:goods_24.png 实际案例 文中案例基于 ImageMagick 7.0.7 1、生成缩略图需求：将一张宽高为 900x600 的图片 goods.jpg 生成宽高为 150x100 的缩略图 thumbnail.jpg 1convert -resize 150x100 -quality 70 -strip goods.jpg thumbnail.jpg 解释： -resize 150x100：定义输出的缩略图尺寸为 150x100。 -quality 70：降低缩略图的质量为 70，取值范围 1 ( 最低图像质量和最高压缩率 ) 到 100 ( 最高图像质量和最低压缩率 )，默认值根据输出格式有 75、92、100，选项适用于 JPEG / MIFF / PNG。 -strip：让缩略图移除图片内嵌的所有配置文件，注释等信息，以减小文件大小。 -resize 延伸解读，如下。 上面的例子中，输入的图片和输出的图片比例是一致的，所以不会有特殊情况出现，但是遇到比例不同的时候，上面的写法并不会得到 150x100 的图像，而是会根据图像的宽高比例，取最大值，得出来的结果可能是 150 宽和更小的高，或者 100 高和更小的宽；所以 IamgeMagick 提供了几种符号来定义缩放。123convert -resize '150x100!' goods.jpg thumbnail.jpgconvert -resize '150x100&gt;' goods.jpg thumbnail.jpgconvert -resize '150x100&lt;' goods.jpg thumbnail.jpg !：不管图片宽高如何，都缩放成 150x100 这样的尺寸。&gt;：只有宽高均大于 150x100 的图片才缩放成该尺寸 ( 按比例取最大值 )，小于的图片不做处理。&lt;：与 &gt; 功能相反。 提示：因为有些字符是 Linux shell 或其他系统的特殊字符，所以需要用引号包裹起来或者用反斜线 \\ 转义，另外，不同平台可能引号都是有差异的。 2、添加水印需求 ① ：给图片居中加上透明文本水印。 12convert -draw 'text 0,0 \"JD.COM\"' -fill 'rgba(221, 34, 17, 0.25)' -pointsize 36 \\-font 'cochin.ttc' -gravity center joy.jpg watermark.jpg 解释： -draw：绘图选项，text 声明绘制文本， 0,0 声明文本距离图片左上角的偏移值， JD.COM 声明绘制的文本，最好用引号包裹起来，避免输入特殊字符引起错误。绘制文本的格式为 text x,y string，当然还可以绘制其他类型，诸如圆 ( circle )、折线 ( polyline )。 -fill：对文本填充颜色，貌似 ImageMagick 命令中前面的选项是用来控制后面的选项的，所以应该把这样的修饰选项放到 -draw 前面比较好，很重要，后面的案例就是这样的。 -pointsize：指定文本的字体大小。 -font：指定字体。 -gravity：设置文本在图片里的排列方式 ( 类似 CSS 里的 align-items + justify-content )，center 表示水平垂直都居中，其他值还可以是：NorthWest, North, NorthEast, West, East, SouthWest, South, SouthEast，不记大小写。 \\：反斜线也是类 Unix 系统的续行字符，当一个命令很长时，我们可以把它写成多行，以便视觉上的美观和直观。 需求 ② ：给图片加上倾斜平铺透明文本水印。 1234convert -size 100x100 xc:none \\-fill '#d90f02' -pointsize 18 -font 'cochin.ttc' \\-gravity center -draw 'rotate -45 text 0,0 \"JD.COM\"' \\-resize 60% miff:- | composite -tile -dissolve 25 - joy.jpg watermark.jpg 解释：文本平铺水印其实是将文本画成一张 png 图片，然后用这张透明图片在目标图片上进行平铺。 -size：设置画布的大小。 xc:：全称 X Constant Image，是 canvas: 的别名，定义一张画布，用来绘图，常用格式为 xc:color，none 或者 transparent 设置画布为透明底，默认为白色。 -resize：该选项还可以指定百分比，意为缩放至原图像的百分之几。貌似 -pointsize 小于 14 后，-draw 里的 rotate 会不生效，所以用 -resize 来把平铺图案变得更小。 miff:-： miff: 声明输出 ImageMagick ( IM ) 自己的图像文件格式：MIFF，主要用途是以复杂的方式处理图像时当做中间保存格式，适用于从一个 IM 命令向另一个 IM 命令传递图像元数据和其他关联属性。 - 在管道符前面意为将 IM 命令执行的结果作为标准输出，在管道符后面则表示从标准输入中读取这个数据，如在管道符后面的 composite 中使用 - 读取刚刚生成的透明图像。 |：Linux shell 管道符，用于将上一个命令的标准输出传递到下一个命令作为标准输入。这里将生成的水印图案传递给 composite 命令。 -tile：顾名思义，让图案平铺。 -dissolve：设置平铺图案的透明度。 图释： 3、绘制验证码大概逻辑如下： 随机生成 4 个英文字母或数字。 创建一个宽高 100x40 的画布。 设置字体大小为 16，每个字符的宽高也就是 16 左右了，依次计算出每个字符的 x, y 坐标，再增加一丁点旋转。 随机创建一条透明曲线，加上噪点，增加图片被破解的难度（在保证肉眼能看得清楚的用户体验下）。 如果需要安全性更高的验证码，请了解验证码破解原理并做合理调整。 如果加上随机计算，可能代码会比较多，所以这里写成固定值，方便理解。 1234567891011convert 'xc:[100x40!]' -pointsize 20 -font 'cochin.ttc' \\-gravity NorthWest -strokewidth 1 \\-fill '#b72b36' -stroke '#b72b36' -draw 'translate 13,19 rotate 10 text -5,-8 \"5\"' \\-fill '#821d70' -stroke '#821d70' -draw 'translate 36,13 rotate -8 text -8,-8 \"C\"' \\-fill '#c7960a' -stroke '#c7960a' -draw 'translate 60,23 rotate 5 text -5,-8 \"2\"' \\-fill '#03610a' -stroke '#03610a' -draw 'translate 85,25 rotate 13 text -8,-8 \"E\"' \\-strokewidth 2 -stroke 'rgba(248, 100, 30, 0.5)' -fill 'rgba(0, 0, 0, 0)' \\-draw 'bezier -20,30 -16,10 20,2 50,20' \\-draw 'bezier 50,20 78,42 138,36 140,16' \\+noise Impulse \\captcha.jpg 结果： 鉴于字体比较细，可以用 strokewidth 加边框来加粗，或者使用字体的粗体版本，这里使用了第一种方式。 解释： xc:[100x40!]：设置画布大小的一种简写方式，方括号里写入画布宽高，注意要加 !，否则会出乎意料哟。 文本定位与旋转 画布宽 100px，平均分成 4 分，每份 25px, 文字宽 16px, 得文字 x 的坐标左右摆动范围为 +0px, +9px，y 坐标同理，用于设置 translate 值。 实际上字体本身并没有填充满整个 16x16 的区域，根据字体的不同，填满的区域可能各有不同，所以根据cochin 字体的特性，上面稍微将字体大小调整为 20，实际渲染出来的字母才是 16x16 左右大小，数字大概是 10x16，所以设置数字的 x,y 为 -5,-8，结合下面两个属性解释 x,y 的计算方式。 translate: 设置文本的横纵向偏移值。 rotate：设置文本旋转，单位 degrees。根据 gravity 的设置坐标系统有一丁点变化，所以请设置为 西北(NorthWest) ，表示以画布 0,0 坐标旋转，跟 HTML 5 Canvas 坐标系统一致。 根据这样的坐标系统，如果要文字按自身的中心旋转，得配合 translate 和 text 的 x,y 一起使用，原理可参考这篇文章[图像旋转的实现]，注意 translate 与 rotate 的顺序。 strokewidth：设置文本的边框宽度或线条宽度。 stroke：设置文本的边框颜色或线条颜色。 -fill &#39;rgba(0, 0, 0, 0)&#39;：上面设置了文本的填充颜色，会影响下面的贝塞尔曲线，所以这里指定一个透明的填充色以覆盖上面的设定，使曲线没有填充。 bezier：绘制贝塞尔曲线，一两句话我怕解释不清楚，所以请大家参考一下维基百科的解释或者这篇中文文章的解释，最后再参考一下 IM 官方示例的描述。上面两条三次贝塞尔曲线的坐标分别表示 起始点，起始点的控制点，结束点的控制点，结束点。 +noise：增加噪点，可以使用 convert -list noise 查看当前系统支持哪些算法的噪点，大概有 Gaussian, Impulse, Laplacian, Multiplicative, Poisson, Random, Uniform。 4、克隆及拼合图像 这个案例主要了解几个基本操作的 API。 12345convert \\\\( -crop 300x300+10+25 joy.jpg \\) \\\\( -resize 400x400 -crop 300x300+50+0 logo: \\) -swap 0,1 +append \\\\( -clone 0 -flop -flip \\) -append \\-resize 200x200 combined.jpg 结果如下： 解释： 圆括号 \\( ... \\)：图像堆栈 ( image stack )，相当于创建了一个独立作用域处理图像，这个可以使图像之前的处理互不干扰。圆括号需用反斜杠转义，才能不被 Shell 当做特殊字符处理，并且每个圆括号两边需要用空格隔开。不必要的圆括号会使 IM 增加少许额外的工作，但是却让命令更清晰不容易出错。 -crop：裁剪出图像的一个或多个矩形区域，格式为 {size}{+-}x{+-}y，如果不指定偏移值 x,y，则会被解释为按指定宽高切割图像成多少份（多图像）。 logo:：IM 内置图像，这个就是上图中拿着魔法棒的主人公了，本身宽高 640x480，其他内置图像还有：rose:，granite:等，看这里。 -swap： 交换图像的位置，格式 -swap index,index。 IM 在图像处理操作时，实际上很可能是在处理一个图像列表，当新图像被读入或者创建时，IM 会将该新图像添加到当前图像列表的末尾。 如上，本来我们的图像列表里有 2 张图，第一张是 joy，但是 -swap 0,1 的意思是交换第一张图与第二张图的位置，所以 joy 变成跑到后面了。 +append：水平连接当前图像列表的图像来创建单个较长的图像。 -append：垂直连接当前图像列表的图像来创建单个较长的图像。 -clone：克隆图像，格式为 -clone {index_range_list}。 -clone 0：表示克隆图像列表里的第一张图像。 -clone 1-2：表示克隆图像列表里的第二张到第三张图像。 -clone 0--1：0 表示第一张图像，-1 表示最后一张图像，所以整句命令则表示克隆整个图像列表。 -clone 2,0,1：表示克隆第三张，第一张，第二张图像，顺序根据指定的索引决定，用逗号分隔。 -flop：将图像水平翻转。 -flip：将图像垂直翻转。 笔记： 选项之间的顺序很重要。 与 -clone 雷同的选项还有诸如：-delete, -insert, -reverse, -duplicate，用于操作图像列表，功能与单词意思相同。 5、GIF 与图片互转5.1、GIF 转图片1convert -coalesce rain.gif frame.jpg -coalesce：根据图像 -dispose 元数据的设置覆盖图像序列中的每个图像，以重现动画序列中每个点的动画效果。下面用一张结果对比图来解释这句话。 原始图 ( rain.gif ) ： 结果对比： 5.2、定义输出文件名上面默认输出的文件名为：frame-0.jpg, frame-1.jpg, frame-2.jpg ...，如果想使用下划线作为符号，输出为 frame_0.jpg, frame_1.jpg, frame_2.jpg ...，则可以如下设置。 1convert -coalesce rain.gif frame_%d.jpg 或者 1convert -coalesce -set filename:n '%p' rain.gif 'frame_%[filename:n].jpg' 解释： 第一种方式 %d 是 C 语言 printf() 中表示输出一个整数，参考 -adjoin 选项。 第二种为常规方式。 -set：设置图像属性，格式为 -set key value filename:n &#39;%p&#39;：以 filename: 开头的 key 用于设置输出文件名的相关信息，如这里使用 filename:n，在输出文件名时，则可以使用 %[filename:n] 拿到刚刚的设置，而设置的内容则是 &#39;%p&#39;。&#39;%p&#39; 表示图像在图像列表中的索引值，更多百分比选项 ( Percent Escapes ) 参考。 5.3、解析特定帧如果只想拿到 GIF 的第一帧，可以这样设置。 1convert -coalesce 'rain.gif[0]' first_frame.jpg 拿到某些帧，如同 -clone 的写法。 1convert -coalesce 'rain.gif[0-2]' some_frames_%d.jpg 5.4、获取页数通过 identify 命令我们可以简要得到文件的信息，如下。1identify rain.gif 通过换行符分割，简单封装一个 Node.js 函数获取页数。 123456789101112// parser.jsconst util = require('util')const exec = util.promisify(require('child_process').exec)exports.numberOfPages = async (filePath) =&gt; &#123; try &#123; const &#123; stdout &#125; = await exec(`identify '$&#123;filePath&#125;'`) return stdout.trim().split('\\n').length &#125; catch (err) &#123; throw new Error(err) &#125;&#125; 1234567// main.jsconst &#123; numberOfPages &#125; = require('./parser');(async function start () &#123; const pages = await numberOfPages('rain.gif') console.log('pages:', pages)&#125;()) 5.5、图片转 GIF1convert -loop 0 'frame-*.jpg' rain_animation.gif 将所有与 frame-*.jpg 模式匹配的图像转换成一张 GIF 图像，如 frame-0.jpg，frame-1.jpg等。-loop 设置动画循环次数，0 表示无限循环。设置每张图像的播放速度可以使用 -delay 选项。 笔记： 在 IM 读取系列文件时，frame-10.jpg 会排在 frame-2.jpg 前面，为获得图像正确的读取顺序，可以为文件名设置前导零 ( leading zeros )。如：frame-000.jpg, frame-001.jpg, frame-002.jpg ... frame-010.jpg。 所以在生成图像时，我们可以使用 %03d 获得三位前导零。1convert -coalesce rain.gif frame-%03d.jpg 6、PDF 与图片互转PDF 与图片互转跟 GIF 很相似，稍微有些格式自身需要注意的区别。IM 本身是不具备解析 PDF 的功能的，需要依赖专门解析这种格式的外部程序，如官方指明的 ghostscript 解析程序。首先安装 gs，还是演示 Mac OS 安装：brew install ghostscript。 以 这个PDF 为例，把它转换成图片，有两种方式达到我们想要的结果:1① convert -density 150 -flatten 'download.pdf[0]' first_page.jpg 1② convert -density 150 -background white -alpha remove download.pdf download.jpg 解释： 当转换 PDF 成 JPG 格式图像时，某些情况得到的 JPG 图片会出现黑色背景（转换成 PNG 不会），所以可以使用 -flatten 选项让其保持白色背景，但加上这个选项，多页 PDF 不会分成多个 JPG 图像，第二种方式 -background white -alpha remove 则可以一次命令转换多页 PDF 成多个图像并保持白色背景。 第二种方式 IM 内部应该是一页一页的转换，所以一个 10 页的 PDF 耗时会比较久，采用第一种方式让 Node.js 多进程同时转换该 PDF 可以提升速率。 -density：指定输出图像的分辨率 ( DPI )，在 Mac OS 上，默认的分辨率 ( 72 ) 输出的图像字迹不清，需要更高分辨率获得清晰的图像。 在 Node.js 中应用 直接通过 child_process 模块执行相应的命令即可，如下。 只需要结果可以使用 exec，1234567891011const util = require('util')const exec = util.promisify(require('child_process').exec);(async function start () &#123; try &#123; await exec(`convert -resize '150x100!' -strip goods.jpg thumbnail.jpg`) console.log('convert completed.') &#125; catch (err) &#123; console.log('convert failed.', err) &#125;&#125;()) 流式输入输出可以使用 spawn，1234567891011121314const cp = require('child_process')const fs = require('fs')const args = [ '-', // 使用标准输入 '-resize', '150x100!', '-strip', 'jpg:-', // 输出到标准输出]const streamIn = fs.createReadStream('/path/to/goods.jpg')const proc = cp.spawn('convert', args)streamIn.pipe(proc.stdin)proc.stdout.pipe(HttpResponse)","pubDate":"Wed, 06 Jun 2018 12:30:35 GMT","guid":"https://aotu.io/notes/2018/06/06/ImageMagick_intro/","category":"Web开发"},{"title":"Nerv实战 - 京东首页改版小结","link":"https://aotu.io/notes/2018/04/24/jdindex_2017/","description":".post strong { font-weight: bold; }","pubDate":"Tue, 24 Apr 2018 12:10:00 GMT","guid":"https://aotu.io/notes/2018/04/24/jdindex_2017/","category":"项目总结"},{"title":"Nerv - 京东高性能前端框架","link":"https://aotu.io/notes/2018/03/22/nerv/","description":"Nerv 是一款由京东凹凸实验室打造的类 React 前端框架。目前已广泛运用在京东商城（JD.COM）核心业务及TOPLIFE全站。Nerv 基于React标准，使用 Virtual Dom 技术，拥有和 React 一致的 API 与生命周期，如果你已经对 React 使用非常熟悉，那么使用 Nerv 开发对你来说绝对是零学习成本。 与此同时，相比于 React 以及市面其他同类型框架，Nerv 更具体积轻量，性能高效的特点。并且，它符合当下国情，可以完美兼容 IE8 及以上浏览器。 官网：https://nerv.aotu.io/ 文档：https://nervjs.github.io/docs/ GitHub：https://github.com/NervJS/nerv 特性 更小的体积：Gzip 后仅有9k，不到 React 三分之一的体积，低性能设备也能高速地加载并解析执行。 更高的性能：高效、同步的 diff 算法和诸多优化策略使得 Nerv 成为性能最高的前端框架之一。 完备的生态：无需 nerv-compat，只需要在稍稍设置就能享受整个 React 生态的共同成果。 更一致的渲染：不仅在浏览器上能高效地渲染，在服务器上 Nerv 同样能高效地运行。 更优的兼容：和大多数现代框架不同，Nerv 将继续保持对 IE8 的兼容。 更具说服力的案例：不管是京东首页的高流量，还是 Toplife 的复杂业务，Nerv 都经受住了来自于真实业务的考验。 性能在 Nerv 开发过程中，我们针对虚拟 Dom 算法做了一次升级，将并行的虚拟 Dom diff 过程替换成同步的，边 diff 边 patch ，这样大幅度提升了虚拟 Dom 更新的速度。同时我们还对diff算法进行了探索升级，参照目前市面上最快的虚拟 Dom 算法对我们的代码进行了改造。 经过重构升级后，我们的框架性能大幅提升，如下可见。 更多性能数据详见官网。 项目背景是的，我们又造了一个轮子，也是一次抛离传统开发模式的技术革新。同行们或许有疑问，目前市面上已经有非常多的同类型技术框架，为什么我们还要不厌其烦地打造一个呢？这当然不是在做无用功。 日常开发中，相对于 Vue ，我们更倾向于选择 React 模式作为我们的开发标准，因为 React 天生组件化且函数式编程的方式，更加灵活且便于维护。然而，React 仍然有一些不能满足我们需求的地方： IE8 浏览器兼容性：当前环境所限，即便很不情愿，我们仍然要支持 IE8。 体积：React 大概 130kb 的体积。在低网速 / 低版本浏览器 / 低配置设备的加载速度和解析速度都不能让我们满意。 性能：React 的 Virtual Dom 算法（React 自己叫 Reconciler）并没有做太多的优化。 而我们的新轮子 —— Nerv，它完全能提供上述 React 的所有优点，并且它也能完全满足我们自己的需求：更好的兼容性、更小的体积、更高的性能。 安装推荐使用 npm 的方式进行开发，享受 Node 生态圈和 Webpack 工具链带来的便利。 1npm install nervjs --save 简单示例下面是一个计时器的例子。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import Nerv from 'nervjs'class Counter extends Nerv.Component &#123; setTime = () =&gt; &#123; const date = new Date() const year = date.getFullYear() const month = date.getMonth() + 1 const day = date.getDay() const hour = date.getHours() const minute = date.getMinutes() const sec = date.getSeconds() this.setState(&#123; year, month, day, hour, minute, sec &#125;) &#125; componentWillMount () &#123; this.setTime() &#125; componentWillUnmount () &#123; clearInterval(this.interval) &#125; componentDidMount () &#123; this.interval = setInterval(this.setTime, 1000) &#125; componentWillReceiveProps () &#123; this.setTime() &#125; render () &#123; const &#123; year, month, day, hour, minute, sec &#125; = this.state return ( &lt;div className='counter'&gt; &lt;span&gt;The time is&lt;/span&gt;&#123;year&#125;-&#123;month&#125;-&#123;day&#125; &#123;hour&#125;:&#123;minute&#125;:&#123;sec&#125; &lt;/div&gt; ) &#125;&#125;export default Counter 更多详细例子可阅读文档NervJs了解。 写在最后秉承万维网的开放精神，以及开源世界的信条，我们接受各种评价和讨论，最终目标是为开源世界贡献我们的一份力，感恩！欢迎各位同行使用 Nerv，如果你在使用过程中遇到问题，或者有好的建议，欢迎给我们提Issue 或者 Pull Request。 结尾小彩蛋&gt;&gt; 一个视频带你看懂Nerv","pubDate":"Thu, 22 Mar 2018 04:00:00 GMT","guid":"https://aotu.io/notes/2018/03/22/nerv/","category":"Web开发"},{"title":"动画：从 AE 到 Web","link":"https://aotu.io/notes/2018/03/06/ae2web/","description":"呃~貌似好久没写文章了，感觉有点奇怪。废话不多说，但还是加点前戏吧。 不想听废话，直入主题&gt;&gt; 前戏为何要写这篇文章 接下来因工作调整，应该就很少接触 H5 开发了。借此机会总结对动画的一些个人思考。 本文贴合实战，会结合笔者为数不多的开发案例进行讲解🤣。最后，也会提供相应文件让你实践。 为何“别人”实现的动效恰到好处？同一份设计稿给到不同开发者，结果可能千差万别。而结果主要由两部分体现——内在与外在。『内在』指的是代码质量、性能优化，『外在』则指的是视觉还原度和动效（交互）。 其中对于更直观的『外在』来说，视觉还原度高是前提，真正体现差距的是『动效』。因为设计师一般只给到“静态”的视觉稿，而无动画演示，更不用说提供动效搞（如 AE）了。 在这种情况下，页面的动效更多是由前端开发者自由发挥。因此对动效有钻研的同学优势尽显。他们积累了一定理论知识和经验。我也曾问过这些同学，他们大多回答是：“多试多调”。因此，在设计师无『动效稿』提供的情况下，都需要花时间慢慢调整，以达到各方（自己、设计师、产品和需求方等）满意。若没有设计、动效等相关知识的学习与积累，恐怕是一只『没头苍蝇』。 关于动画的理论方面，笔者并没有积累，但推荐一些不错的资料（或许需要梯子）。同时也希望得到读者们的有效补充： 动画的十二原则——12 Principles of Animation (Official Full Series) 动画的第一步是『观察』——Exploring Animation And Interaction Techniques With WebGL (A Case Study)，译文&gt;&gt; 其实可以把『锅』扔给设计师大多数前端开发者在设计和动效方面并没有太多积累，因而难以做出令人拍手称赞的效果。其实，这是设计师（或动效设计师）所擅长的领域，可从下表查看两者的对比： * 设计师 前端开发 备注 是否擅长动画 大部分 少部分 如何生产动画 GUI 工具，如 AE 编写代码 效益 高 低 体现在以下几个方面： 1. 专业度 2. 实现效率：可视化 &gt; 编写代码 3. 沟通成本 4. 各方满意度 5. … 从上表可得，将『动效设计』交给设计师能显著提高效益。从实际工作流程上说： 设计师与前端开发的排期由『线性』变为『部分重叠』：设计师交付静态视觉稿后，前端开发就能进行视觉还原，设计师此时即可进入动效设计。 设计师将动效设计导出为视频，提前取得各方满意度，避免开发期间的反复沟通修改。 假设达成以上共识后，剩下的问题就是：如何还原『动效稿』？ 补间动画——Apple 逐帧动画——洗衣机 设计师输出的动效演示 注：全文『动效稿』均基于 Adobe After Effects（简称 AE）设计。 AE 到 Web 实现其实，与『制造业』一样，实现方式就两种： 机械：通过工具直接导出 手工：手动取参数，通过掌握的 Web 技术实现 两者的优缺点比较： * 机械 手工 效率 高 低 精度 高 视情况而定 定制化 低 高 情怀 无 因人而异 机械实现机械代表着“未来、高效”。业界出现了很多优秀的工具，使得在浏览器渲染复杂动效成为了可能，且极大地提高了效率。 代表工具有： Bodymovin 是 AE 的一个插件，用于将 AE 导出为 Web 动画（HTML、SVG 或 Canvas），仅支持 AE 部分特性。 lottie-web 是 Airbnb 团队的一个用于在 Web、Android、iOS 和 React Native 渲染 AE 动画的库。 可是『世界上本来就没有十全十美的东西』。机械化生产可能未必满足所有要求，生产环境上的要求就更加苛刻了。主要体现在：机械化生产导致介入难度高。若出现以下问题就难以解决： 兼容性 在动画过程中插入自定义逻辑 工具自身的不完善 文件体积要求 … 无论如何，『机械化』是未来，期待它以完美的姿态到来。 手工实现手工代表着“自定义、可控性”。无论世界如何工具化，总有一些人保持着对『手工』的热情。 『手工』意味着从无到有的过程。需要我们参与这个过程的每一步。这也就使得我们拥有了很强的自定义能力。这恰恰是『机械化』目前所不具备的特性。这也是本文重点阐述的内容。 基于 AE 手工实现 Web 动画的主要工作有两个： 在动效稿上拿到元素的参数信息，如 x/y/z、rotation 等 通过适当的 Web 技术进行实现，如 CSS3/Canvas/SVG 等 如何手工取参Web 动画一般分为 逐帧动画 和 补间动画。 显然，对于取参操作来说，逐帧动画比补间动画的工作量要大得多，但两者操作一致。所以下面以 补间动画 Apple 为例： 打开 apple.aep 文件，AE 界面如下： AE 界面 点击『信息模块』预览面板的播放按钮或拖动『时间轴模块』的 标记3 即可预览动画。 根据 CSS3 animation 属性，我们需要获取以下信息： 动画持续时间 animation-duration 关键帧之间的缓动函数 animation-timing-function 动画延时时间 animation-delay 为了方便阐述，我们选取整个 Apple 动画中一个小圆圈（共 60 个）为代表，其余元素同理。另外，由于该动画是一次性的，无需设置/获取动画的重复次数（animation-iteration-count）、运动方向（animation-direction）。 现在我们把目光投向『图层、运动模块』的 标记1： 标记1——FPS 由上图可得，FPS 为 12，即 1 秒 12 帧， 1 帧 0.0833 秒。 由上面 Apple 动画 可看出，每个圆的延时时间（animation-delay）、缓动函数（animation-timing-function）和持续时间（animation-duration）均不相同。换句话说，每个圈都是一个独立的补间动画，所有元素组合起来才是一个完整的补间动画。 双击『标记 2』，进入编组以查看每个圆的信息。 子元素——圆 在『查看器』或『图层、运动模块』任意选中一个圆，展开其 变换 属性并单击 位置（标记1），即可显示右侧的元素运动路径（标记2）。同时这也反映了属性的变化速率（即缓动函数（animation-timing-function），这方面会在后面详解。 位置 前面的时钟图标为蓝色时，代表有过渡动画。 某个圆的时间轴 结合上面知识，可从上图得出以下信息点： 该元素共有 4 个关键帧 只有 Y 轴上发生位移运动（绿线），X 轴上则是静止状态（红线） 延时时间为 1 帧 中间停留时间（第2、3 关键帧之间）为 1 帧 过渡时间为 42 帧（3 * 12 + 7 - 1）。注意要减去延时时间（1），因为 02:03 包含了它。下同。 因此，我们基于 CSS3 animation 实现该元素的补间动画： 1&lt;div class=\"circle-29\"&gt;&lt;/div&gt; 123456789101112131415161718192021222324252627282930/* 默认定位在第2（或3）帧以让元素默认显示屏幕内，便于开发调试。 */.circle-29 &#123; width: 60px; height: 60px; background-color: rgba(0, 224, 93, .7); position: absolute; left: 473px; top: 348px; border-radius: 50%; animation-name: circle29; animation-duration: 3.5s; /* 42 * (1 / 12) */ animation-delay: 0.0833s; /* 1 * (1 / 12) */ animation-fill-mode: both; animation-timing-function: ease-in-out;&#125;@keyframes circle29 &#123; 0% &#123; transform: translate3d(0, 1175px, 0); &#125; 61.90% &#123; /* (2 * 12 + 3 - 1) / 42，注意要减去延时时间（1），因为 02:03 包含了它。下同。*/ transform: translate3d(0, 0, 0); &#125; 64.29% &#123; transform: translate3d(0, 0, 0); &#125; 100% &#123; transform: translate3d(0, -1225px, 0); &#125;&#125; 这样就完成了某个圆的补间动画了。虽然繁琐，但是省去反复试验的时间，基本做到一次开发即可使各方满意的效果。 See the Pen ae2web-circle by Jc (@JChehe) on CodePen. 其余元素按照以上步骤执行即可完成整个动画。 假设没有动画演示和动效稿，仅凭借着个人感觉，编码完成一个由 60 多个元素组成的动画，简直难于上青天（对于笔者来说）。 也许你对 animation-timing-function 存在误解细心的读者可能发现：如果第 1、2 帧和第 3、4 帧的缓动函数不相同时，该怎么办？ 首先部分人可能对 animation-timing-function 存在误解：它是作用于整个 @keyframes 规则的。❌ 其实缓动函数是作用于 @keyframes 规则内的关键帧。若未为关键帧指定 animation-timing-function，则会从其元素取得 animation-timing-function。 更严格地说，缓动函数是应用在属性上，从定义该属性的关键帧到下一个指定同样属性的关键帧。若后续无指定该属性的关键帧则到动画结束。因此，在 100% 或 to 关键帧上指定 animation-timing-function 是无用的。 举个例子：12345678910111213141516171819202122.box &#123; width: 100px; height: 100px; background-color: #6190e8; animation: move 2s ease both;&#125;@keyframes move &#123; 0% &#123; animation-timing-function: linear; transform: translateX(0); opacity: 1; &#125; 50% &#123; opacity: .5; &#125; 100% &#123; transform: translateX(100px); opacity: 1 animation-timing-function: ease-in-out; /* 无用多余 */ &#125;&#125; 在 0% 关键帧中指定的 animation-timing-function: linear 是对 transform 和 opacity 属性有效。但因为 50% 关键帧未指定 transform 属性，所以 animation-timing-function: linear 对它生效至有指定 transform 属性的关键帧，即 100%。 另外，由于 50% 关键帧未指定 animation-timing-function，所以它会使用 .box 元素上指定的 ease 缓动函数。 总上所述，可在关键帧上指定不同的缓动函数，以满足关键帧间属性的不同变化速率。 更强大的 cubic-bezier细心的读者可能又发现：缓动函数碰巧是 预定义的关键字，如果是以下这种情况呢？ 显然浏览器预定义的关键字无法表示该类型的缓动函数，但浏览器提供了强大的 cubic-bezier() 方法。翻译过来就是三次贝塞尔曲线。因此，我们可以通过该方法自定义缓动函数。 想了解贝塞尔曲线的更多知识，可阅读 《贝塞尔曲线扫盲》。 AE 时间轴 上呈现的是属性的变化路径，其未必与变化速率（即缓动函数）完全一致。因为它们的 X/Y 轴含义不同。 如上图所示，AE 是属性随着时间而变，CSS3 animation 是动画进度随着时间而变。然而属性的变化是有方向的，动画进度是永远向前的。 举个例子： AE：AE 属性变化是有方向的 对应 CSS3 animation-timing-function：动画进度永远是向前的 如上面二图所示，下图是上图的速率变化（缓动函数）。理清 AE 与 CSS3 animation 的对应关系后，剩下的问题就是：如何通过 cubic-bezier() 表示图中的 CurveA 与 CurveB。 也许有工具可从 AE 直接导出（欢迎读者们提供链接），但本文为了简单起见，推荐使用 Ceasar 或 Cubic-Bezier.com 这类可视化工具直接模拟生成。 因此，上述补间动画的缓动函数可表示为： 12345678910111213141516@keyframes ae2css &#123; 0% &#123; animation-timing-function: ease-out; &#125; 23% &#123; animation-timing-function: ease-in; &#125; 50% &#123; animation-timing-function: cubic-bezier(0.5, 0, 0.5, 1.5); &#125; 76% &#123; animation-timing-function: cubic-bezier(0, 0, 0, 1); &#125; 100% &#123; &#125;&#125; 总结本文基于实际案例总结出 AE 到 Web 动画的实现方法。相对于『无动效稿』的反复编码尝试，该方法无疑能提高效益。当然，『手工』不能胜任复杂的动画（如 SVG 的变形动画（Morphing）），并且低效。因此，业界也在『机械/工具化』方面不断推陈出新，涌现出许多优秀的工具，让复杂的动画在各终端上得以表现。无论如何，学习更多知识总没错! 最后，感谢你的阅读！ 案例演示以下案例演示未完全按 AE 动效稿的参数。若感觉不太对劲，那也许是正常的吧!？ Apple 补间动画整体效果演示（一次性动画，请点击 “RERUN” 按钮重播）： See the Pen ae2css-apple by Jc (@JChehe) on CodePen. 洗衣机逐帧动画同理（主要针对背景图的 3D 旋转进行处理）：链接&gt;&gt; 移动端体验地址： Apple 洗衣机 素材下载 Apple 补间动画 AE 文件 参考资料 Making the transition from animating in After Effects to CSS. MDN: animation-timing-function","pubDate":"Tue, 06 Mar 2018 04:00:00 GMT","guid":"https://aotu.io/notes/2018/03/06/ae2web/","category":"Web开发"},{"title":"H5游戏开发：FC小蜜蜂","link":"https://aotu.io/notes/2018/01/28/galaxian/","description":"前言说起任天堂 FC 那是充满我们童年寒暑假的回忆，那时候没有正版红白机，玩的是几十块一台的山寨小霸王，十块一张的卡带，玩着魂斗罗、马里奥、淘金者、快打旋风、打鸭子等等。 进入正题，今天我们来说说怎么做一个 FC 小蜜蜂游戏，游戏玩法是通过操控飞机，通过发射子弹对蜜蜂造成伤害，蜜蜂全部歼灭则视为胜利。 初始化本次游戏采用 Phaser 引擎进行开发，Phaser 是一个快速、免费、易于维护的开源 2D 游戏框架，支持 JavaScript 和 TypeScript 两种语言开发，采用 Pixi.js 引擎作为底层渲染，内置了物理引擎、粒子动画、骨骼动画等效果。 在 Phaser 中有一个重要的概念，我们需要通过状态（State）来管理游戏中各个不同的场景，这也是 Phaser 官方建议的游戏代码组织方式，场景可以通过 Phaser.Game.state 来添加（add）和启动（start），每个场景有初始化（init）、预加载（preload）、准备就绪（create）、更新周期（update）、渲染完毕（render） 五种状态，按照顺序依次执行，同一时间只能存在一个场景，并且每个场景中至少包含五种状态中的一个。 比如我们的小蜜蜂游戏一共会分为四个场景：开始场景、游戏场景、获胜场景、失败场景 1234567891011121314151617181920212223var game = new Phaser.Game(750, 1206, Phaser.AUTO, 'wrapper')var states = &#123;&#125;states.start = &#123; // 开始场景 preload: function() &#123; ... game.load.image('example-1', 'images/example-1.png') ... &#125;, create: function() &#123; game.state.start('play') // 加载完成后切换到游戏场景 &#125;&#125;states.play = &#123; ... &#125; // 游戏场景states.victory = &#123; ... &#125; // 胜利场景states.defeat = &#123; ... &#125; // 失败场景game.state.add('start', states.load)game.state.add('play', states.play)game.state.add('victory', states.victory)game.state.add('defeat' states.defeat)game.state.start('start') 无限滚屏在无限滚屏中，游戏背景沿着 x 轴或者 y 轴重复的滚动，从而实现飞机一直在向前飞的错觉，我们通过创建两个背景，分别初始定位到一屏和二屏的位置，在绘制（update）的过程中持续移动两张背景图的 y 轴，当监听到两个背景超出特定位置后重新定位，从而达到无限循环背景的效果。 1234567891011var bg1 = game.add.image(0, 0, 'background'), bg2 = game.add.image(0, -bg1.height, 'background')update: function() &#123; // 持续的移动 bg1.y += 2 bg2.y += 2 // 超出屏幕判断 if (bg1.y &gt;= 1206) &#123; bg1.y = 0 &#125; if (bg2.y &gt;= 0) &#123; bg2.y = -bg1.height &#125;&#125; 当然，还有更为简便的方式，Phaser 提供了 TileSprite 平铺纹理，非常适合于这类平铺的背景，再结合 autoScroll() 方法，两行代码解决，另外还有一种叫 TileMaps 平铺的瓦片地图，很适合制作 FC 马里欧这类游戏，以后有机会再开一篇文章讲讲。 12var bg = game.add.tileSprite(0, 0, 750, 1206, 'background')bg.autoScroll(0, 200) // 水平滚动速度、垂直滚动速度 创建一架飞机飞机的移动我们通过键盘方向键进行控制，通过修改 x、y 值来实现位移，为了有更好的灵活性，我们使用 vx 和 vy 来控制 Sprite 的移动，vx 用于设置 Sprite 在 x 轴上的速度和方向，vy 用于设置 Sprite 在 y 轴上的速度和方向，不直接修改 Sprite 的 x 和 y 值，而是先更新速度值，然后再将这些速度值分配给 Sprite。 123456789...airplane.vx = 0airplane.vy = 0update: function() &#123; airplane.x += airplane.vx airplane.y += airplane.vy&#125;... 接着监听键盘事件，需要注意的就是在弹起状态的时候要判断反向的键是否也已经弹起，避免造成互相干扰。 1234...left.onDown.add(function() &#123; airplane.vx = -8 &#125;)left.onUp.add(function() &#123; if (!right.isDown) &#123; airplane.vx = 0 &#125; &#125;)... 最后是限制飞机的移动范围，我们要限制飞机只在屏幕范围内移动，类似空气墙效果，通过持续监听飞机上下左右四个方向是否碰触到边缘，对坐标进行归位，具体实现代码请看 contain 方法。 生成子弹在游戏中，我们需要不断的发射子弹，这就存在一个问题，如何管理子弹？ 因为子弹越多会越占用我们的内存，游戏会发现越来越卡，我们使用对象池的方式生成子弹，并且在子弹击中蜜蜂或者超出屏幕时进行销毁。 对象池的本质是复用，通过 Group 和 getFirstExists 来实现。在优化前，我们每次创建子弹都会 new Sprite，使用一次后就丢掉，优化后是创建子弹后会放入对象池中，每次使用从对象池中取，如果对象池中有则使用对象池中的子弹。 12345678910this.bullets = game.add.group() // 创建对象池var bullet = this.bullets.getFirstExists(false) // 从对象池中取非存活状态的子弹if (bullet) &#123; // 对象池中存在则复用 bullet.reset(this.airplane.x + 16, this.airplane.y - 20)&#125; else &#123; // 对象池中不存在则创建一个放入对象池中 bullet = game.add.sprite(this.airplane.x + 27, this.airplane.y - 15, 'bullet') this.bullets.addChild(bullet)&#125; 创建一群蜜蜂整体移动创建 5 x 5 小蜜蜂是采用 Group 将所有的小蜜蜂对象放入其中，持续移动 Group，检测 Group 左右是否碰壁，进行反方向移动，但你会发现小蜜蜂的左右的某一列被歼灭后，Group 的宽度会随着小蜜蜂列数的变化而变化，而 Group 的 X 轴坐标还是以原来的宽度输出 X 坐标，这就导致我们在计算碰撞墙壁的时候出现问题。 因此我们改为通过 Group 来控制整体移动，小蜜蜂负责碰撞检测，当检测到小蜜蜂碰撞后，进行反方向移动，并跳出循环。 1234567for (var i = 0; i &lt; galaxians.length; i++) &#123; var cur = galaxians[i] if (cur.x + cur.parent.x &lt; 0 || cur.x + cur.parent.x + cur.width &gt; game.world.width) &#123; // 反向移动 break &#125;&#125; 随机自杀式袭击在间隔一段时间后随机小蜜蜂发起攻击，间隔不采用 setInterval 的方式，因为 setInterval 即使在页面最小化或非激活状态依然执行，我们采用 Phaser 提供的 Time 进行间隔触发避免此问题。 1234game.time.events.loop(Phaser.Timer.SECOND * 1.5, function() &#123; // 每两秒随机一只小蜜蜂 var now = galaxians[(Math.floor(Math.random() * galaxians.length)]&#125;) 如何计算小蜜蜂向飞机发起攻击的运动轨迹，这里要借助三角函数的力量来解决，通过飞机位置和蜜蜂位置，获得对边（a）和邻边（b）的长度，根据勾股定理求出斜边（c）长度，知道各边长度后就能得到三角比。另外有一点，Group 的 X 轴在持续的移动，小蜜蜂会受 Group 影响，所以在移动小蜜蜂时要注意。 12345678var a = airplane.x + airplane.width / 2 - now.x + now.width /2 // 获取 a 边长度var b = airplane.y + airplane.height / 2 - now.y + now.height / 2 // 获取 b 边长度var c = Math.sqrt(a * a + b * b) // 求出斜边 c 长度var speedX = a / c * 8var speedY = b / c * 8now.x += speedXnow.y += speedY 碰撞检测在游戏中，我们需要检测子弹与蜜蜂的碰撞和检测蜜蜂与飞机的碰撞，在 2D 游戏中，常用的有轴对齐包围盒（简称 AABB）就是一个每条边都平行于 X 轴或者 Y 轴的矩形。 AABB 可以用两个点表示：最大点和最小点，在 2D 中，最小点就是左下角的点，而最大点则是右上角的点。 通过判断 AABB 与 AABB 是否有存在交叉即可得知是否有碰撞。 12345function hitTestRectangle(a, b) &#123; var hit = (a.max.x &lt; b.min.x) || (b.max.x &lt; a.min.x) || (a.max.y &lt; b.min.y) || (b.max.y &lt; a.min.y) &#123; return !hit &#125;&#125; 以上就是 AABB 与 AABB 碰撞检测的原理，当然，你也可以省事采用 Phaser 提供的物理引擎，在 Phaser 中内置了三种物理引擎，分别是：Arcade Physics、P2 Physics 和 Ninja Physics。 Arcade Physics：是三个中最为简单、性能最快的物理引擎，因为它的碰撞都是采用 AABB 与 AABB 的碰撞，所有的碰撞都是基于一个矩形边界（hitbox）来计算的，所有如果你想碰撞一个圆形的 Sprite，碰撞的则是它的矩形边界，而不是圆形本身，并且支持摩擦力、重力、弹跳、加速等物理效果，适合应用于精度要求不高，较为简单的游戏中。 P2 Physics：它是一个更为复杂和逼真的物理引擎，使用 P2 你可以创建弹簧、钟摆、马达等东西，它唯一的缺点在于运算量大，对于性能有较高的要求。 Ninja Physics：比 Arcade Physics 要复杂一点，最初是为 Flash 游戏而创造的，而现在由 Phaser 的作者 Richard Davey 移植到 JavaScript，它与其他物理引擎最大的区别在于支持斜坡碰撞。 下面简单介绍一下 Arcade Physics 的使用方法，首先要启动物理引擎 1game.physics.startSystem(Phaser.Physics.ARCADE); 接着是需要为每个对象开启物理效果，显然一个个创建、添加对象并不高效，我更建议的是通过 Group 的形式添加，这样在 Group 上创建的对象都可以开启物理效果。 12345game.physics.arcade.enable(airplane) // 单独开启方式var platforms = game.add.group()platforms.enableBody = true // 组开启方式platforms.create(0, 0, 'airplane') 完成这些以后就可以在 update 阶段使用碰撞检测，overlap 方法可传入两个游戏对象，对象可以是 Sprites、Groups 或者 Emitters，可以执行 Sprite 与 Sprite、Sprite 与 Group、Group 与 Group 的碰撞检测，与 collide 方法不同，该方法的物体不会执行任何的物理效果，它只负责碰撞检测。 123update: function() &#123; game.physics.arcade.overlap(object1, object2, overlapCallback, processCallback, callbackContext)&#125; 到此碰撞检测介绍就到这，关于物理引擎的更多使用方法可移步至官网查看。 体验地址【点击这里体验】键盘方向键控制移动，空格发射子弹，暂时只支持 PC 端体验，另外游戏还有很多可增加的功能，比如：关卡设计（蜜蜂血量、速度、分数）、蜜蜂发射子弹、蜜蜂贝塞尔曲线移动、蜜蜂归位、音乐音效、爆炸动画等等。 尾巴如果你希望入门 H5 游戏开发，不妨拿这个练练手，源码你可以在体验地址中查看到，Phaser 是很适合作为你入门 H5 游戏开发的一款游戏引擎，等你熟练使用也希望你能阅读源码，了解其中的原理，本文较为简单，感谢你的阅读。 我们会定期更新关于「H5游戏开发」的文章，欢迎关注我们的知乎专栏。 参考资料Learning Pixi.jsPhaserSetting up Ninja Physics in Phaser《游戏编程算法与技巧》","pubDate":"Sun, 28 Jan 2018 14:37:01 GMT","guid":"https://aotu.io/notes/2018/01/28/galaxian/","category":"H5游戏开发"},{"title":"H5游戏开发：消灭星星","link":"https://aotu.io/notes/2018/01/17/popstar/","description":"「消灭星星」是一款很经典的「消除类游戏」，它的玩法很简单：消除相连通的同色砖块。 1. 游戏规则「消灭星星」存在多个版本，不过它们的规则除了「关卡分值」有些出入外，其它的规则都是一样的。笔者介绍的版本的游戏规则整理如下： 1. 色砖分布 10 x 10 的表格 5种颜色 —— 红、绿、蓝，黄，紫 每类色砖个数在指定区间内随机 5类色砖在 10 x 10 表格中随机分布 2. 消除规则 两个或两个以上同色砖块相连通即是可被消除的砖块。 3. 分值规则 消除总分值 = n * n * 5 奖励总分值 = 2000 - n * n * 20 「n」表示砖块数量。上面是「总」分值的规则，还有「单」个砖块的分值规则： 消除砖块得分值 = 10 * i + 5 剩余砖块扣分值 = 40 * i + 20 「i」表示砖块的索引值（从 0 开始）。简单地说，单个砖块「得分值」和「扣分值」是一个等差数列。 4. 关卡分值 关卡分值 = 1000 + (level - 1) * 2000；「level」即当前关卡数。 5. 通关条件 可消除色块不存在 累计分值 &gt;= 当前关卡分值 上面两个条件同时成立游戏才可以通关。 2. MVC 设计模式笔者这次又是使用了 MVC 模式来写「消灭星星」。星星「砖块」的数据结构与各种状态由 Model 实现，游戏的核心在 Model 中完成；View 映射 Model 的变化并做出对应的行为，它的任务主要是展示动画；用户与游戏的交互由 Control 完成。 从逻辑规划上看，Model 很重而View 与 Control 很轻，不过，从代码量上看，View 很重而 Model 与 Control 相对很轻。 3. Model10 x 10 的表格用长度为 100 的数组可完美映射游戏的星星「砖块」。 123456789101112[ R, R, G, G, B, B, Y, Y, P, P, R, R, G, G, B, B, Y, Y, P, P, R, R, G, G, B, B, Y, Y, P, P, R, R, G, G, B, B, Y, Y, P, P, R, R, G, G, B, B, Y, Y, P, P, R, R, G, G, B, B, Y, Y, P, P, R, R, G, G, B, B, Y, Y, P, P, R, R, G, G, B, B, Y, Y, P, P, R, R, G, G, B, B, Y, Y, P, P, R, R, G, G, B, B, Y, Y, P, P] R - 红色，G - 绿色，B - 蓝色，Y - 黄色，P - 紫色。Model 的核心任务是以下四个： 生成砖墙 消除砖块 （生成砖块分值） 夯实砖墙 清除残砖 （生成奖励分值） 3.1 生成砖墙砖墙分两步生成： 色砖数量分配 打散色砖 理论上，可以将 100 个格子可以均分到 5 类颜色，不过笔者玩过的「消灭星星」都不使用均分策略。通过分析几款「消灭星星」，其实可以发现一个规律 —— 「色砖之间的数量差在一个固定的区间内」。 如果把传统意义上的均分称作「完全均分」，那么「消灭星星」的分配是一种在均分线上下波动的「不完全均分」。 笔者把上面的「不完全均分」称作「波动均分」，算法的具体实现可以参见「波动均分算法」。 「打散色砖」其实就是将数组乱序的过程，笔者推荐使用「 费雪耶兹乱序算法」。 以下是伪代码的实现：1234567// 波动均分色砖waveaverage(5, 4, 4).forEach( // tiles 即色墙数组 (count, clr) =&gt; tiles.concat(generateTiles(count, clr)); ); // 打散色砖shuffle(tiles); 3.2 消除砖块「消除砖块」的规则很简单 —— 相邻相连通相同色即可以消除。 前两个组合符合「相邻相连通相同色即可以消除」，所以它们可以被消除；第三个组合虽然「相邻相同色」但是不「相连通」所以它不能被消除。 「消除砖块」的同时有一个重要的任务：生成砖块对应的分值。在「游戏规则」中，笔者已经提供了对应的数学公式：「消除砖块得分值 = 10 * i + 5」。 「消除砖块」算法实现如下：1234567891011121314151617181920function clean(tile) &#123; let count = 1; let sameTiles = searchSameTiles(tile); if(sameTiles.length &gt; 0) &#123; deleteTile(tile); while(true) &#123; let nextSameTiles = []; sameTiles.forEach(tile =&gt; &#123; nextSameTiles.push(...searchSameTiles(tile)); makeScore(++count * 10 + 5); // 标记当前分值 deleteTile(tile); // 删除砖块 &#125;); // 清除完成，跳出循环 if(nextSameTiles.length === 0) break; else &#123; sameTiles = nextSameTiles; &#125; &#125; &#125;&#125; 清除的算法使用「递归」逻辑上会清晰一些，不过「递归」在浏览器上容易「栈溢出」，所以笔者没有使用「递归」实现。 3.3 夯实砖墙砖墙在消除了部分砖块后，会出现空洞，此时需要对墙体进行夯实： 向下夯实 向左夯实 向左下夯实（先下后左） 一种快速的实现方案是，每次「消除砖块」后直接遍历砖墙数组（10x10数组）再把空洞夯实，伪代码表示如下： 123456789101112131415for(let row = 0; row &lt; 10; ++row) &#123; for(let col = 0; col &lt; 10; ++col) &#123; if(isEmpty(row, col)) &#123; // 水平方向（向左）夯实 if(isEmptyCol(col)) &#123; tampRow(col); &#125; // 垂直方向（向下）夯实 else &#123; tampCol(col); &#125; break; &#125; &#125;&#125; But… 为了夯实一个空洞对一张大数组进行全量遍历并不是一种高效的算法。在笔者看来影响「墙体夯实」效率的因素有： 定位空洞 砖块移动（夯实） 扫描墙体数组的主要目的是「定位空洞」，但能否不扫描墙体数组直接「定位空洞」？ 墙体的「空洞」是由于「消除砖块」造成的，换种说法 —— 被消除的砖块留下来的坑位就是墙体的空洞。在「消除砖块」的同时标记空洞的位置，这样就无须全量扫描墙体数组，伪代码如下： 123456function deleteTile(tile) &#123; // 标记空洞 markHollow(tile.index); // 删除砖块逻辑 ...&#125; 在上面的夯实动图，其实可以看到它的夯实过程如下： 空洞上方的砖块向下移动 空列右侧的砖块向左移动 墙体在「夯实」过程中，它的边界是实时在变化，如果「夯实」不按真实边界进行扫描，会产生多余的空白扫描： 如何记录墙体的边界？把墙体拆分成一个个单独的列，那么列最顶部的空白格片段就是墙体的「空白」，而其余非顶部的空白格片段即墙体的「空洞」。 笔者使用一组「列集合」来描述墙体的边界并记录墙体的空洞，它的模型如下： 12345678910111213/* @ count - 列砖块数 @ start - 顶部行索引 @ end - 底部行索引 @ pitCount - 坑数 @ topPit - 最顶部的坑 @ bottomPit - 最底部的坑*/ let wall = [ &#123;count, start, end, pitCount, topPit, bottomPit&#125;, &#123;count, start, end, pitCount, topPit, bottomPit&#125;, ...]; 这个模型可以描述墙体的三个细节： 空列 列的连续空洞 列的非连续空洞 123456789101112// 空列if(count === 0) &#123; ...&#125;// 连续空洞else if(bottomPit - topPit + 1 === pitCount) &#123; ...&#125;// 非连续空洞else &#123; ...&#125; 砖块在消除后，映射到单个列上的空洞会有两种分布形态 —— 连续与非连续。 「连续空洞」与「非连续空洞」的夯实过程如下： 其实「空列」放大于墙体上，也会有「空洞」类似的分布形态 —— 连续与非连续。 它的夯实过程与空洞类似，这里就不赘述了。 3.4 消除残砖上一小节提到了「描述墙体的边界并记录墙体的空洞」的「列集合」，笔者是直接使用这个「列集合」来消除残砖的，伪代码如下： 1234567891011function clearAll() &#123; let count = 0; for(let col = 0, len = this.wall.length; col &lt; len; ++col) &#123; let colInfo = this.wall[col]; for(let row = colInfo.start; row &lt;= colInfo.end; ++row) &#123; let tile = this.grid[row * this.col + col]; tile.score = -20 - 40 * count++; // 标记奖励分数 tile.removed = true; &#125; &#125;&#125; 4. ViewView 主要的功能有两个： UI 管理 映射 Model 的变化（动画） UI 管理主要是指「界面绘制」与「资源加载管理」，这两项功能比较常见本文就直接略过了。View 的重头戏是「映射 Model 的变化」并完成对应的动画。动画是复杂的，而映射的原理是简单的，如下伪代码： 1234567891011121314151617181920212223update(&#123;originIndex, index, clr, removed, score&#125;) &#123; // 还没有 originIndex 或没有色值，直接不处理 if(originIndex === undefined || clr === undefined) return ; let tile = this.tiles[originIndex]; // tile 存在，判断颜色是否一样 if(tile.clr !== clr) &#123; this.updateTileClr(tile, clr); &#125; // 当前索引变化 ----- 表示位置也有变化 if(tile.index !== index) &#123; this.updateTileIndex(tile, index); &#125; // 设置分数 if(tile.score !== score) &#123; tile.score = score; &#125; if(tile.removed !== removed) &#123; // 移除或添加当前节点 true === removed ? this.bomb(tile) : this.area.addChild(tile.sprite); tile.removed = removed; &#125;&#125; Model 的砖块每次数据的更改都会通知到 View 的砖块，View 会根据对应的变化做对应的动作（动画）。 5. ControlControl 要处理的事务比较多，如下： 绑定 Model &amp; View 生成通关分值 判断通关条件 对外事件 用户交互 初始化时，Control 把 Model 的砖块单向绑定到 View 的砖块了。如下： Object.defineProperties(model.tile, { originIndex: { get() {...}, set(){ ... view.update({originIndex}) } }, index: { get() {...}, set() { ... view.update({index}) } }, clr: { get() {...}, set() { ... view.update({clr}) } }, removed: { get() {...}, set() { ... view.update({removed}) } }, score: { get() {...}, set() { ... view.update({score}) } } }) 「通关分值」与「判断通关条件」这对逻辑在本文的「游戏规则」中有相关介绍，这里不再赘述。 对外事件规划如下： name detail pass 通关 pause 暂停 resume 恢复 gameover 游戏结束 用户交互 APIs 规划如下： name type deltail init method 初始化游戏 next method 进入下一关 enter method 进入指定关卡 pause method 暂停 resume method 恢复 destroy method 销毁游戏 6. 问题在知乎有一个关于「消灭星星」的话题：popstar关卡是如何设计的？ 这个话题在最后提出了一个问题 —— 「无法消除和最大得分不满足过关条件的矩阵」。 「无法消除的矩阵」其实就是最大得分为0的矩阵，本质上是「最大得分不满足过关条件的矩阵」。 最大得分不满足过关条件的矩阵求「矩阵」的最大得分是一个 「背包问题」，求解的算法不难：对当前矩阵用「递归」的形式把所有的消灭分支都执行一次，并取最高分值。但是 javascript 的「递归」极易「栈溢出」导致算法无法执行。 其实在知乎的话题中提到一个解决方案： 网上查到有程序提出做个工具随机生成关卡，自动计算，把符合得分条件的关卡筛选出来 这个解决方案代价是昂贵的！笔者提供有源码并没有解决这个问题，而是用一个比较取巧的方法：进入游戏前检查是事为「无法消除矩阵」，如果是重新生成关卡矩阵。 注意：笔者使用的取巧方案并没有解决问题。 7. 结语下面是本文介绍的「消灭星星」的线上 DEMO 的二维码： 游戏的源码托管在：https://github.com/leeenx/popstar 感谢耐心阅读完本文章的读者。本文仅代表笔者的个人观点，如有不妥之处请不吝赐教。如果对「H5游戏开发」感兴趣，欢迎关注我们的专栏。 参考资料 Knapsack problem NP-completeness popstar关卡是如何设计的？ 费雪耶兹乱序算法 波动均分算法","pubDate":"Wed, 17 Jan 2018 13:53:01 GMT","guid":"https://aotu.io/notes/2018/01/17/popstar/","category":"H5游戏开发"},{"title":"波动均分算法","link":"https://aotu.io/notes/2018/01/11/waveaverage/","description":"「波动」和「均分」大部分读者朋友是知道的，但看到「波动均分」应该是一头雾水的。其实，这个名词是笔者拼凑出来的。 什么是「波动均分」？ 把指定的数值 A，分成 N 份，此时每份的数值在一个固定的区间 [max, min] 内。 从视觉上看，每份的数量在平均线上下波动，并带有随机性： 这种分配不是严格意义上的「均分」，但它却跟「均分」很相似，按笔者的理解给这个算法取个名字 —— 「波动均分」。 波动均分算法应该具备的特征如下： 分配数量 波峰高度 波谷深度 随机分配 组合全面 前三个特征是提供对外配置的接口，保证算法的使用者可以指定分配的数量和定制波动的波峰和波谷（尽管大部分情况下，波峰 = 波谷）；「随机分配」表示算法的结果是随机的；「 组合全面」表示算法的结果是可以覆盖所有可能的结果。 接下来，笔者将介绍两种实现「波动均分」的算法： 穷举法 快速分配 备注：本文算法中使用到的平均值是0 穷举法「穷举法」顾名思义就是列举所有可能出现的组合，再随机抽取一个组合作为输出结果。 下面是一个「波动均分」任务： 有一张 10x10 的表格，需要对格子上5种颜色并要求每种颜色的数量在区间 [18, 22] 内。 由上述可得：每种颜色都会有5种分配结果（18, 19, 20, 21, 22）。穷举这些颜色分配数量的组合其实就是建设一棵高度为 6 的 5 叉树的过程。 第 6 层的叶子数就是「所有可能出现的组合」的总数。换而言之，从树的第六层的一片叶子到第二层节点的路径即是一种分配组合。 以下是「穷举法」的代码实现：12345678910111213141516171819202122232425262728293031323334function exhaustWave(n = 5, crest = 4, trough = 4) &#123; let root = &#123;parent: null, count: null, subtotal: 0&#125;; // 根节点 let leaves = [root]; // 叶子（数组） let level = 0; // 层数 // 检查当前组合是否合法 let isOK = subtotal =&gt; &#123; if(level &lt; n - 1) &#123; if(-subtotal &lt;= (n - level) * crest || subtotal &lt;= (n - level) * trough) return true; &#125; else if(subtotal === 0) return true; else return false; &#125; // 生成组合树 while(level &lt; n) &#123; let newLeaves = []; // 存储最新叶子 leaves.forEach(node =&gt; &#123; for(let count = -trough; count &lt;= crest; ++count) &#123; let subtotal = node.subtotal + count; isOK(subtotal) &amp;&amp; newLeaves.push( &#123;parent: node, count: count, subtotal: subtotal&#125; ); &#125; &#125;); leaves = newLeaves, ++level; &#125; // 随机取一片叶子 let leaf = leaves[Math.random() * leaves.length &gt;&gt; 0]; let group = [leaf.count]; for(let i = 0; i &lt; 4; ++i) &#123; leaf = leaf.parent; group.push(leaf.count); &#125; return group; &#125; 穷举法的局限： 「无穷集合」不适用 穷举算法效率低下 由于「穷举法」的这两个致命限制，所以它不是适用于业务。事实上，笔者主要是使用「穷举法」校验「快速分配」方案的全面性。 快速分配「快速分配」方案的思路： 获取可分配波动范围； 在波动范围内随机取值 代码的实现过程如下：123456789101112131415161718192021222324252627282930313233343536function quickWave(n = 5, crest = 4, trough = 4, isInteger = true) &#123; let list = []; // 无法进行波动均分，直接返回完全平分 if(crest &gt; (n - 1) * trough || trough &gt; (n - 1) * crest) &#123; return new Array(n).fill(0); &#125; let base = 0; // 最少需要消除的高度 let wave = 0; // 波动量 let high = crest; // 高位 let low = -trough; // 低位 let sum = 0; // 累计量 let count = n; // 剩余数量 while(--count &gt;= 0) &#123; // 动态当前的波动量 if(crest &gt; count * trough - sum) &#123; high = count * trough - sum; &#125; if(trough &gt; count * crest + sum) &#123; low = -sum - count * crest; &#125; base = low; wave = high - low; let rnd; // 随机波动量 if(count &gt; 0) &#123; rnd = base + Math.random() * (wave + 1); // 随机波动 &#125; else &#123; rnd = -sum; &#125; if(isInteger === true) &#123; rnd = Math.floor(rnd); &#125; sum += rnd; list.push(rnd); &#125; return list; &#125; 波动均分的「快速分配」方案在算法效率上是高效的，并且「快速分配」适用于「无穷集合」。 如何使用「穷举法」校验「快速分配」的全面性？「穷举法」能直接返回分配组合的总数，而「快速分配」只能随机返回一次组合，笔者是通过大数量地调用「快速分配」算法并累积不重复组合来验证「快速分配」的全面性。代码如下： 1234567console.log(exhaustWave(5, 4, 4)); // 组合总数: 3951let res = &#123;&#125;, count = 0, len = 10000; for(let i = 0; i &lt; len; ++i) &#123; let name = quickWave(5, 4, 4).join(\"_\"); res[name] !== true &amp;&amp; (res[name] = true, ++count); &#125;console.log(count); // len次快速分配后的组合总数 通过调整变量 len 可以发现，当 len 越来越大输出的结果就越逼近 3951，当到达一定量级后，输出的结果就是 3951。 结语可能网上有类似的算法存在，不过笔者学识太浅没有找到对应的算法，所以自己生造了这个算法，如果有何不妥之处欢迎指正。 如果对「H5游戏开发」感兴趣，欢迎关注我们的专栏。","pubDate":"Thu, 11 Jan 2018 03:49:03 GMT","guid":"https://aotu.io/notes/2018/01/11/waveaverage/","category":"Web开发"},{"title":"H5游戏开发：套圈圈","link":"https://aotu.io/notes/2018/01/04/waterful/","description":"前言虽然本文标题为介绍一个水压套圈h5游戏，但是窃以为仅仅如此对读者是没什么帮助的，毕竟读者们的工作生活很少会再写一个类似的游戏，更多的是面对需求的挑战。我更希望能举一反三，给大家在编写h5游戏上带来一些启发，无论是从整体流程的把控，对游戏框架、物理引擎的熟悉程度还是在某一个小难点上的思路突破等。因此本文将很少详细列举实现代码，取而代之的是以伪代码展现思路为主。 游戏 demo 地址：http://jdc.jd.com/fd/demo/waterful/game.html 希望能给诸位读者带来的启发 技术选型 整体代码布局 难点及解决思路 优化点 技术选型一个项目用什么技术来实现，权衡的因素有许多。其中时间是必须优先考虑的，毕竟效果可以减，但上线时间是死的。 本项目预研时间一周，真正排期时间只有两周。虽然由项目特点来看比较适合走 3D 方案，但时间明显是不够的。最后保守起见，决定采用 2D 方案尽量逼近真实立体的游戏效果。 从游戏复杂度来考虑，无须用到 Egret 或 Cocos 这些“牛刀”，而轻量、易上手、团队内部也有深厚沉淀的 CreateJS 则成为了渲染框架的首选。 另外需要考虑的是是否需要引入物理引擎，这点需要从游戏的特点去考虑。本游戏涉及重力、碰撞、施力等因素，引入物理引擎对开发效率的提高要大于学习使用物理引擎的成本。因此权衡再三，我引入了同事们已经玩得挺溜的 Matter.js。（ Matter.js 文档清晰、案例丰富，是切入学习 web 游戏引擎的一个不错的框架） 整体代码布局在代码组织上，我选择了面向对象的手法，对整个游戏做一个封装，抛出一些控制接口给其他逻辑层调用。 伪代码： 1234&lt;!-- index.html --&gt;&lt;!-- 游戏入口 canvas --&gt;&lt;canvas id=\"waterfulGameCanvas\" width=\"660\" height=\"570\"&gt;&lt;/canvas&gt; 123456789101112131415161718192021222324252627282930313233343536// game.js/** * 游戏对象 */class Waterful &#123; // 初始化函数 init () &#123;&#125; // CreateJS Tick，游戏操作等事件的绑定放到游戏对象内 eventBinding () &#123;&#125; // 暴露的一些方法 score () &#123;&#125; restart () &#123;&#125; pause () &#123;&#125; resume () &#123;&#125; // 技能 skillX () &#123;&#125;&#125;/** * 环对象 */class Ring &#123; // 于每一个 CreateJS Tick 都调用环自身的 update 函数 update () &#123;&#125; // 进针后的逻辑 afterCollision () &#123;&#125;&#125; 12345// main.js// 根据业务逻辑初始化游戏，调用游戏的各种接口const waterful = new Waterful()waterful.init(&#123;...&#125;) 初始化游戏的初始化接口主要做了4件事情： 参数初始化 CreateJS 显示元素（display object）的布局 Matter.js 刚体（rigid body）的布局 事件的绑定 下面主要聊聊游戏场景里各种元素的创建与布局，即第二、第三点。 一、CreateJS 结合 Matter.js阅读 Matter.js 的 demo 案例，都是用其自带的渲染引擎 Matter.Render。但是由于某些原因（后面会说到），我们需要使用 CreateJS 去渲染每个环的贴图。 不像 Laya 配有和 Matter.js 自身用法一致的 Render，CreateJS 需要单独创建一个贴图层，然后在每个 Tick 里把贴图层的坐标同步为 Matter.js 刚体的当前坐标。 伪代码： 123createjs.Ticker.addEventListener('tick', e =&gt; &#123; 环贴图的坐标 = 环刚体的坐标&#125;) 使用 CreateJS 去渲染后，要单独调试 Matter.js 的刚体是非常不便的。建议写一个调试模式专门使用 Matter.js 的 Render 去渲染，以便跟踪刚体的运动轨迹。 二、环本游戏的难点是要以 2D 去模拟 3D，环是一点，进针的效果是一点，先说环。 环由一个圆形的刚体，和半径稍大一些的贴图层所组成。如下图，蓝色部分为刚体： 伪代码： 12345678class Ring &#123; constructor () &#123; // 贴图 this.texture = new createjs.Sprite(...) // 刚体 this.body = Matter.Bodies.circle(...) &#125;&#125; 三、刚体为什么把刚体半径做得稍小呢，这也是受这篇文章 推金币 里金币的做法所启发。推金币游戏中，为了达到金币间的堆叠效果，作者很聪明地把刚体做得比贴图小，这样当刚体挤在一起时，贴图间就会层叠起来。所以这样做是为了使环之间稍微有点重叠效果，更重要的也是当两个紧贴的环不会因翻转角度太接近而显得留白太多。如图： 为了模拟环在水中运动的效果，可以选择给环加一些空气摩擦力。另外在实物游戏里，环是塑料做成的，碰撞后动能消耗较大，因此可以把环的 restitution 值调得稍微小一些。 需要注意 Matter.js 中因为各种物理参数都是没有单位的，一些物理公式很可能用不上，只能基于其默认值慢慢进行微调。下面的 frictionAir 和 restitution 值就是我慢慢凭感觉调整出来的： 1234this.body = Matter.Bodies.circle(x, y, r, &#123; frictionAir: 0.02, restitution: 0.15&#125;) 四、贴图环在现实世界中的旋转是三维的，而 CreateJS 只能控制元素在二维平面上的旋转。对于一个环来说，二维平面的旋转是没有任何意义的，无论如何旋转，都只会是同一个样子。 想要达到环绕 x 轴旋转的效果，一开始想到的是使用 rotation + scaleY。虽然这样能在视觉上达到目的，但是 scaleY 会导致环有被压扁的感觉，图片会失真： 显然这样的效果是不能接受的，最后我采取了逐帧图的方式，最接近地还原了环的旋转姿态： 注意在每个 Tick 里需要去判断环是否静止，若非静止则继续播放，并将贴图的 rotation 值赋值为刚体的旋转角度。如果是停止状态，则暂停逐帧图的播放： 123456789101112131415// 贴图与刚体位置的小数点后几位有点不一样，需要降低精度const x1 = Math.round(texture.x)const x2 = Math.round(body.position.x)const y1 = Math.round(texture.y)const y2 = Math.round(body.position.y)if (x1 !== x2 || y1 !== y2) &#123; texture.paused &amp;&amp; texture.play() texture.rotation = body.angle * 180 / Math.PI&#125; else &#123; !texture.paused &amp;&amp; texture.stop()&#125; texture.x = body.position.xtexture.y = body.position.y 五、舞台舞台需要主要由物理世界、背景图，墙壁，针所组成。 1. 物理世界为了模拟真实世界环在水中的向下加速度，可以把 y 方向的 g 值调小： 1engine.world.gravity.y = 0.2 左右重力感应对环的加速度影响同样可以通过改变 x 方向的 g 值达到： 12345678// 最大倾斜角度为 70 度，让用户不需要过分倾斜手机// 0.4 为灵敏度值，根据具体情况调整window.addEventListener('deviceorientation', e =&gt; &#123; let gamma = e.gamma if (gamma &lt; -70) gamma = -70 if (gamma &gt; 70) gamma = 70 this.engine.world.gravity.x = (e.gamma / 70) * 0.4&#125;) 2. 背景图本游戏布景为游戏机及海底世界，两者可以作为父容器的背景图，把 canvas 的位置定位到游戏机内即可。canvas 覆盖范围为下图的蓝色蒙层： 3. 墙壁因为环的刚体半径比贴图半径小，因此墙壁刚体需要有一些提前位移，环贴图才不会溢出，位移量为 R - r（下图红线为墙壁刚体的一部分）： 4. 针为了模拟针的边缘轮廓，针的刚体由一个矩形与一个圆形所组成。下图红线描绘了针的刚体： 为什么针边缘没有像墙壁一样有一些提前量呢？这是因为进针效果要求针顶的平台区域尽量地窄。作为补偿，可以把环刚体的半径尽可能地调得更大，这样在视觉上环与针的重叠也就不那么明显了。 进针进针是整个游戏的核心部分，也是最难模拟的地方。 进针后两个二维平面的物体交错是不能产生“穿过”效果的： 除非把环分成前后两部分，这样层级关系才能得到解决。但是由于环贴图是逐帧图，分两部分的做法并不合适。 最后找到的解决办法是利用视觉错位来达到“穿过”效果： 具体做法是，当环被判定成功进针时，把环刚体去掉，环的逐帧图逐渐播放到平放的那一帧，rotation 值也逐渐变为 0。同时利用 CreateJS 的 Tween 动画把环平移到针底。 进针后需要去掉环刚体，平移环贴图，这就是上文为什么环的贴图必须由 CreateJS 负责渲染的答案。 伪代码： 123456789101112131415161718192021222324252627282930313233343536373839404142// Object RingafterCollision (waterful) &#123; // 平移到针底部 createjs.Tween.get(this.texture) .to(&#123;y: y&#125;, duration) // 消去刚体 Matter.World.remove(waterful.engine.world, this.body) this.body = null // 接下来每一 Tick 的更新逻辑改变如下 this.update = function () &#123; const texture = this.texture if 当前环贴图就是第 0 帧（环平放的那一帧）&#123; texture.gotoAndStop(0) &#125; else &#123; 每 5 个 Tick 往前播放一帧（相隔多少 Tick 切换一帧可以凭感觉调整，主要是为了使切换到平放状态的过程不显得太突兀） &#125; // 使针大概在环中央位置穿过 if (texture.x &lt; 200) ++texture.x if (texture.x &gt; 213 &amp;&amp; texture.x &lt; 300) --texture.x if (texture.x &gt; 462) --texture.x if (texture.x &gt; 400 &amp;&amp; texture.x &lt; 448) ++texture.x // 把环贴图尽快旋转到水平状态 let rotation = Math.round(texture.rotation) % 180 if (rotation &lt; 0) rotation += 180 if (rotation &gt; 0 &amp;&amp; rotation &lt;= 90) &#123; texture.rotation = rotation - 1 &#125; else if (rotation &gt; 90 &amp;&amp; rotation &lt; 180) &#123; texture.rotation = rotation + 1 &#125; else if (frame === 0) &#123; this.update = function () &#123;&#125; &#125; &#125; // 调用得分回调函数 waterful.score()&#125; 进针判断进针条件1. 到达针顶到达针顶是环进针成功的必要条件。 2. 动画帧环必须垂直于针才能被顺利穿过，水平于针时应该是与针相碰后弹开。 当然条件可以相对放宽一些，不需要完全垂直，下图红框内的6帧都被规定为符合条件： 为了降低游戏难度，我规定超过针一半高度时，只循环播放前6帧： 1234567this.texture.on('animationend', e =&gt; &#123; if (e.target.y &lt; 400) &#123; e.target.gotoAndPlay('short') &#125; else &#123; e.target.gotoAndPlay('normal') &#125;&#125;) 3. rotation 值同理，为了使得环与针相垂直，rotation 值不能太接近 90 度。经试验后规定 0 &lt;= rotation &lt;= 65 或 115 &lt;= rotation &lt;= 180 是进针的必要条件。 下图这种过大的倾角逻辑上是不能进针成功的： 初探一开始我想的是把三维的进针做成二维的“圆球进桶”，进针的判断也就归到物理事件上面去，不需要再去考虑。 具体做法如下图，红线为针壁，当环刚体（蓝球）掉入桶内且与 Sensor （绿线）相碰，则判断进针成功。为了使游戏难度不至于太大，环刚体必须设置得较小，而且针壁间距离要比环刚体直径稍大。 这种模拟其实已经能达到不错的效果了，但是一个技能打破了这种思路的可能性。 产品那边想做一个放大技能，当用户使用此技能时环会放大，更容易套中。但是在桶口直径不变的情况下，只是环贴图变大并不能降低游戏难度。如果把环刚体变小，的确容易进了，但相近的环之间的贴图重叠范围会很大，这就显得很不合理了。 改进“进桶”的思路走不通是因为不兼容放大技能，而放大技能改变的是环的直径。因此需要找到一种进针判断方法在环直径小时，进针难度大，直径大时，进针难度小。 下面两图分别为普通环和放大环，其中红色虚线表示水平方向的内环直径： 在针顶设置一小段探测线（下图红色虚线），当内环的水平直径与探测线相交时，证明进针成功，然后走进针后的逻辑。在环放大时，内环的水平直径变长，也就更容易与探测线相交。 伪代码： 123456789101112131415161718192021222324252627282930313233343536// Object Ring// 每一 Tick 都去判断每个运动中的环是否与探测线相交update (waterful) &#123; const texture = this.texture // 环当前中心点坐标 const x0 = texture.x const y0 = texture.y // 环的旋转弧度 const angle = texture.rotation // 内环半径 const r = waterful.enlarging ? 16 * 1.5 : 16 // 根据旋转角度算出内环水平直径的开始和结束坐标 // 注意 Matter.js 拿到的是 rotation 值是弧度，需要转成角度 const startPoint = &#123; x: x0 - r * Math.cos(angle * (Math.PI / 180)), y: y0 - r * Math.sin(angle * (Math.PI / 180)) &#125; const endPoint = &#123; x: x0 + r * Math.cos(-angle * (Math.PI / 180)), y: y0 + r * Math.sin(angle * (Math.PI / 180)) &#125; // mn 为左侧探测线段的两点，uv 为右侧探测线段的两点 const m = &#123;x: 206, y: 216&#125;, n = &#123;x: 206, y: 400&#125;, u = &#123;x: 455, y: 216&#125;, v = &#123;x: 455, y: 400&#125; if (segmentsIntr(startPoint, endPoint, m, n) || segmentsIntr(startPoint, endPoint, u, v)) &#123; // 内环直径与 mn 或 uv 相交，证明进针成功 this.afterCollision(waterful) &#125; ...&#125; 判断线段是否相交的算法可以参考这篇文章：谈谈”求线段交点”的几种算法 这种思路有两个不合常理的点： 1.当环在针顶平台直到静止时，内环水平直径都没有和探测线相交，或者相交了但是 rotation 值不符合进针要求，视觉上给人的感受就是环在针顶上静止了： 解决思路一是通过重力感应，因为设置了重力感应，只要用户稍微动一下手机环就会动起来。二是判断环刚体在针顶平台完全静止了，则给它施加一个力，让它往下掉。 2.有可能环的运动轨迹是在针顶划过，但与探测线相交了，此时会给玩家一种环被吸下来的感觉。可以通过适当设置探测线的长度来减少这种情况发生的几率。 优化资源池资源回收复用，是游戏常用的优化手法，接下来通过讲解气泡动画的实现来简单介绍一下。 气泡动画是逐帧图，用户点击按钮时，即创建一个 createjs.Sprite。在 animationend 时，把该 sprite 对象从 createjs.Stage 中 remove 掉。 可想而知，当用户不停点击时，会不断的创建 createjs.Sprite 对象，非常耗费资源。如果能复用之前播放完被 remove 掉的 sprite 对象，就能解决此问题。 具体做法是每当用户按下按钮时，先去资源池数组找有没有 sprite 对象。如果没有则创建，animationend 时把 sprite 对象从 stage 里 remove 掉，然后 push 进资源池。如果有，则从资源池取出并直接使用该对象。 当然用户的点击操作事件需要节流处理，例如至少 300ms 后才能播放下一个气泡动画。 伪代码： 123456789101112131415// Object WaterfulgetBubble = throttle(function () &#123; // 存在空闲泡泡即返回 if (this._idleBubbles.length) return this._idleBubbles.shift() // 不存在则创建 const bubble = new createjs.Sprite(...) bubble.on('animationend', () =&gt; &#123; this._stage.removeChild(bubble) this._idleBubbles.push(bubble) &#125;) return bubble&#125;, 300) 环速度过快导致飞出边界Matter.js 里由于没有实现持续碰撞检测算法（CCD），所以在物体速度过快的情况下，和其他物体的碰撞不会被检测出来。当环速度很快时，也就会出现飞出墙壁的 bug。 正常情况下，每次按键给环施加的力都是很小的。当用户快速连续点击时，y 方向累积的力也不至于过大。但还是有玩家反应游戏过程中环不见了的问题。最后发现当手机卡顿时，Matter.js 的 Tick 没有及时触发，导致卡顿完后把卡顿时累积起来的力一次性应用到环刚体上，环瞬间获得很大的速度，也就飞出了游戏场景。 解决方法有两个： 给按钮节流，300ms才能施加一次力。 每次按下按钮，只是把一个标志位设为 true。在每个 Matter.js 的 Tick 里判断该标志位是否为 true，是则施力。保证每个 Matter.js 的 Tick 里只对环施加一次力。 伪代码： 1234567891011121314btn.addEventListener('touchstart', e =&gt; &#123; this.addForce = true&#125;)Events.on(this._engine, 'beforeUpdate', e =&gt; &#123; if (!this.addForce) return this.addForceLeft = false // 施力 this._rings.forEach(ring =&gt; &#123; Matter.Body.applyForce(ring.body, &#123;x: x, y: y&#125;, &#123;x: 0.02, y: -0.03&#125;) Matter.Body.setAngularVelocity(ring.body, Math.PI/24) &#125;)&#125;) 结语如果对「H5游戏开发」感兴趣，欢迎关注我们的专栏","pubDate":"Thu, 04 Jan 2018 07:27:00 GMT","guid":"https://aotu.io/notes/2018/01/04/waterful/","category":"H5游戏开发"},{"title":"H5游戏开发：游戏引擎入门推荐","link":"https://aotu.io/notes/2017/12/27/h5-game-engine-recommend/","description":"前言很多刚刚接触到游戏开发，准备大展拳脚的小鲜肉们，往往在技术选型这第一关就栽了跟头。毕竟网络上的游戏引擎良莠不齐，官网上相关资料也比较少，而选择一个适合的游戏引擎是一个项目最基础，也是很核心的一部分。试想一下，在游戏开发进行到中后期的时候，才发现项目引入的游戏引擎与需求相悖，这时候不管是重新做一些修修补补的工作或者更换游戏引擎，这都是相当耗费人力物力的一件事。为了避免这种情况的出现，在前期选择适合项目需求的游戏引擎显得尤为重要。接下来我们来聊一聊如何去选择适合项目的 JS 游戏引擎。 游戏场景分类在刚接到游戏需求时，我们可以从以下几个方面进行考量，分析出游戏需求场景所属，从而作为我们选择游戏引擎的依据。 游戏效果呈现方式（ 2D ？ 3D ？ VR ？）这与游戏引擎能够支持的渲染方式直接挂钩。现在的 H5 游戏渲染方式一般有 2D 渲染、3D 渲染、VR 渲染三种。而 2D 渲染一般也有三种：Dom 渲染、Canvas 渲染、WebGL 渲染。Dom 由于性能原因，一般只适合做一些动画效果较少，交互较少的小游戏，本文主要针对 Canvas 和 WebGL 展开介绍。一般来说，对于 2D 小游戏来说，Canvas 渲染已经足够。然而 Canvas 渲染由于底层封装层次多，不足以支撑起大型游戏的性能要求，因此大型游戏最好选择 WebGL 渲染或者浏览器内嵌 Runtime 。 游戏复杂度这与游戏引擎能够支持的功能，提供的API，性能等方面关系比较大。 游戏引擎推荐笔者从业界较流行的一些框架，进行以下几个方面对比，希望能从客观数据上给大家的技术选型带来建议和参考。 引擎支持的渲染方式 github上的 star 数 更新时间 文档详细度 周边产品 2D，3D，VR 都支持的游戏引擎 name2D渲染（Canvas）2D渲染(WebGL)3D渲染（WebGL）VRgithub star 数文档详细程度周边产品备注EgretYESYESYESYES2k（最新更新2017.12）▪ 有中文文档▪ 例子充足▪ 社区活跃游戏开发过程中的每个环节基本都有工具支撑。不仅仅提供了一个基于HTML5技术的游戏引擎，更是提供了原生打包工具和众多周边产品LayaAirYESYES（优先）YESYES0.7k（最新更新2017.12）▪ 有中文文档▪ 例子充足▪ 社区活跃提供开发工具和可视化编辑器支持2D、3D、VR，能开发超大游戏，forgame的醉西游，腾讯的QQ农场，乐动卓越的浪漫h5这些大作就是用它开发 Egret Egret 周边产品 白鹭引擎是企业级游戏引擎，有团队维护。Egret 在工作流的支持上做的是比较好的，从 Wing 的代码编写，到 ResDepot 和 TextureMerger 的资源整合，再到 Inspector 调试，最后到原生打包（支持 APP 打包），游戏开发过程中的每个环节基本都有工具支撑。官网上的示例，教程也是比较多。值得一提的是，今年5月白鹭引擎支持了 WebAssembly ，这对于性能的提升又是一大里程碑。 LayaAir在渲染模式上，LayaAir 支持 Canvas 和 WebGL 两种方式；在工具流的支持程度上，主要是提供了 LayaAir IDE。LayaAir IDE 包括代码模式与设计模式，支持代码开发与美术设计分离，内置了 SWF 转换、图集打包、JS 压缩与加密、APP 打包、Flash 发布等实用功能。 下图是主要支持2D游戏的游戏引擎 name2D渲染（Canvas）2D渲染(WebGL)3D渲染（WebGL）VRgithub star 数文档详细程度周边产品备注Pixi.jsYESYESNONO16.8k(最新更新2017.12)▪ 英文文档▪ 例子充足▪ 英文社区无依赖于canvas的WebGL渲染器PhaserYESYESNONO16.9k（最新更2017.07）▪ 英文文档▪ 例子充足▪ 英文社区提供在线编辑器Phaser SandboxCreateJsYESYESNONO6.5k（最新更新2017.12）▪ 英文文档▪ 例子充足▪ 有博客无官方推荐TweenJS，SoundJS，PreloadJS配合使用HiloYESYESYES(Hilo3D)NO4.2k（最新更新2017.12）▪ 有中文文档▪ 例子充足提供资源下载和管理工具阿里巴巴集团推出，适合开发营销小游戏，以Chipmunk为2D物理引擎，与主流物理引擎兼容Cocos2d-xYESYESNONO11.2k（最新更新2017.12）▪ 有中文文档▪ js例子不多，c++例子较多▪ 社区活跃Cocos Creator编辑器，打包工具等提供的功能相当完整lufylegend.jsYESNONONO0.4k（最新更新2016.03）▪ 有中文文档▪ 社区活跃无仿ActionScript3.0的语法，支持Google Chrome，Firefox，Opera，IE9，IOS，Android等多种热门环境，可以配合Box2dWeb制作物理游戏，内置了LTweenLite缓动类等 Pixi.js一般来说，WebGL 的渲染速度都会比 Canvas 快，这是由俩者的绘制路径决定的。Pixi 最大的特点在于，Pixi 具有完整的 WebGL 支持，却并不要求开发者掌握 WebGL 的相关知识，并在需要时无缝地回退到 Canvas 。相较于很多同类产品，它的渲染能力是比较强大的。然而，Pixi 也有不足的地方，Pixi 对于动画的支持是比较缺乏的，在实际开发中，常常需要引进额外的动画库，如 GSAP。 PhaserPhaser 在渲染方面直接封装了 Pixi；架构方面，Phaser 内嵌了3个物理引擎（Arcade Physics、Ninja、p2.js），提供粒子系统、动画、预下载和设备适配方案；兼容性方面，Phaser 的焦点是放在移动端浏览器上的；API 方面，Phaser 能实现丰富的游戏功能，适合复杂度高的游戏开发。 CreateJS CreateJs 周边产品 CreateJS 官方提供了 TweenJS 支持动画开发，同时通过 SoundJS 和 PreLoadJS 提供了音频和预下载的支持，对于 H5 游戏基础功能的支持是足够的。在兼容性方面，CreateJS 支持 PC 端和移动端几乎所有的浏览器。此外，CreateJS 还支持用 flash CC 开发导出由 CreateJS 渲染的 H5 游戏。 HiloHilo 是阿里团队推出的一个开源项目，支持模块化开发，同时提供了多种模块范式的包装版本和跨终端解决方案，适合用来开发营销小游戏。其体积也是比较轻量的，只有70kb左右。Hilo 支持 DOM 渲染，Canvas 渲染和 WebGL 渲染，同时集成了 Hilo Audio， Hilo Preload。其后推出的 Hilo 3D 也是其亮点之一。 Cocos2d-xCocos2d-x 是业界比较老牌的游戏引擎了，同时支持 C++ ，Lua 和 JavaScript 三种开发语言，官方用例来看更倾向于 C++ 开发，适合做一些中大型游戏开发。Cocos2d-x 提供 Cocos Creator 游戏开发工具，组件化，脚本化，数据驱动，跨平台发布。 lufylegend.jslufylegend.js 的最新更新是在16年，不过其社区还是十分活跃的，如果遇到什么开发问题，可以很方便地在社区上找到解决的方案。lufylegend.js 可以支持基础的游戏功能，但是其可拓展性不是很强。 主要支持3D游戏的游戏引擎 name2D渲染（Canvas）2D渲染(WebGL)3D渲染（WebGL）VRgithub star 数文档详细程度周边产品备注Three.jsNONOYES（倾向）NO37.6k（最新更新2017.12）▪ 英文文档▪ 例子充足▪ 英文社区无默认Ammo.js为默认物理引擎，基于JavaScript语言的3D库，耗性能，加载慢，效果一般PlayCanvasNONOYESYES3k（最新更新2017.12）▪ 英文文档▪ 例子充足▪ 英文社区提供了在线编辑器，发布托管等教程较为详细，入门快 Three.js Three.js 示例案例 相信对于很多有关注 3D 游戏的开发者来说，Three.js 早已经耳熟能详了。实际上，Three.js 官方定位并不是游戏引擎，而是一个 JS 3D 库。Three.js 更倾向于展示型的视觉呈现，比较少直接拿 Three.js 来开发 H5 游戏。渲染环境上，Three.js 支持 WebGL 和 CSS3D 两种渲染模式。 PlayCanvas从渲染支持程度来看，PlayCanvas 不仅支持 3D WebGL渲染，同时保持到 VR 的支持，拥有比较好的拓展性。在工具流的支持上，提供了在线编辑器和发布托管等服务。从官方教程上看，教程也是比较详细的。 结语现在市场上的 H5游戏引擎很多，很难去直接定义哪个引擎的好坏，只能说每个引擎都有自己的特性，在某方面跟项目的契合程度比较高，笔者根据现在市场上比较热门的几大引擎做了几点比较，希望能给刚入门的你做技术选型的时候有一点帮助，找到适合项目的引擎，更快、更准、更高效率地完成项目需求。 感谢各位耐心读完，希望能有所收获，有考虑不足的地方欢迎留言指出。 如果对「H5游戏开发」感兴趣，欢迎关注我们的专栏。 参考资料目前有哪些比较成熟的 HTML5 游戏引擎？ HTML5游戏引擎深度测评 现在 TypeScript 的生态如何？","pubDate":"Wed, 27 Dec 2017 03:20:35 GMT","guid":"https://aotu.io/notes/2017/12/27/h5-game-engine-recommend/","category":"H5游戏开发"},{"title":"GraphQL 使用介绍","link":"https://aotu.io/notes/2017/12/15/graphql-use/","description":"GraphQL 是 Fackbook 的一个开源项目，它定义了一种查询语言，用于描述客户端与服务端交互时的数据模型和功能，相比 RESTful API 主要有以下特点： 根据需要返回数据 一个请求获取多个资源 提供内省系统 这使得客户端的功能得到了加强，特别是在查询数据方面。 下面我们\u0006从使用的角度来介绍一下。 相关概念在使用 GraphQL 之前，先介绍几个相关概念，便于理解使用。 Operations GraphQL 服务提供的操作一般有：query、mutation。query 可以理解为 RESTful API 中的 GET 的请求。mutation 可以理解为 RESTful API 中的 POST、PUT、DELETE 之类的请求。 Types 定义了 GraphQL 服务支持的类型，例如： 12345678type User &#123; id: ID name: String&#125;type Query &#123; user: User&#125; 定义了 User 类型和包含的字段以及字段的类型；定义 Query 返回一个 User 类型的 user，Query 也是一种类型。 Scalar types 标量类型。GraphQL 默认提供的标量类型有：Int、Float、String、Boolean、ID，也可以实现自定义的标量类型，如：Date。 标量类型有什么用呢？返回数据的字段必须是标量类型。例如我们想返回一个 user： 123query &#123; user // 报错&#125; 上面这样是会报错的，因为 user 不是标量类型，需要改成 123456query &#123; user &#123; id name &#125;&#125; 指定返回 user 的 id 和 name，这两个字段都是标量类型，就可以正确返回了。 开始使用如果看完上面的介绍，心中有很多疑问，没关系，我们现在以 GitHub GraphQL API 为例，来实际使用一下。打开 https://developer.github.com/v4/explorer/，然后登录，会看到一个这样的界面 这是 GraphQL 提供的开发工具 GraphiQL，可以检查 GraphQL 的语法，发送 GraphQL 的请求，还提供文档查询功能。在开始使用之前先介绍一下文档查询功能。点击右上角的 &lt; Docs 并可以看到 上面的 ROOT TYPES 表示最顶层支持的类型，只有两个 Query 和 Mutation。点击 Query，可以看到该类型包含的字段。仔细看，会发现这些字段的值又都是类型。 往下滚动，找到 user(login: String!): User，点击 User 终于找到一个标量类型的字段 bio: String，按照之前说法，我们是可以查询这个字段，写出如下的查询语言： 12345&#123; user &#123; bio &#125;&#125; 准备执行时，会看到 user 下方有条红线，鼠标放上去 提示 user 必须指定一个 login 的参数，再回头看文档中该字段的描述 user(login: String!): User，是不是就可以理解了，(login: ) 表示该字段接受一个 login 参数，为 String 类型，! 表示是必须的。 将查询语言改成： 12345&#123; user(login: \"booxood\") &#123; bio &#125;&#125; 再执行，并得到了我们预期指定的结果 1234567&#123; \"data\": &#123; \"user\": &#123; \"bio\": \"Happy coding &amp; Happy life\" &#125; &#125;&#125; 现在是不是有点理解这种查询语言了。下面我们再以【 Gitalk：一个基于 Github Issue 和 Preact 开发的评论插件】中的两个需求为例 展示某个 Issue 的评论和评论上的点赞数据 1234567891011121314151617181920query &#123; repository(owner: \"gitalk\", name: \"gitalk\") &#123; issue(number: 1) &#123; comments(last: 10) &#123; totalCount nodes &#123; author &#123; login avatarUrl &#125; body reactions(first: 100, content: HEART) &#123; totalCount viewerHasReacted &#125; &#125; &#125; &#125; &#125;&#125; 先通过 repository(owner: &quot;gitalk&quot;, name: &quot;gitalk&quot;) 找到 repository，再通过 issue(number: 1) 指定 issue，然后 comments(last: 10) 表示从后面取 10 条 comments，同时获取评论的 body 和 评论的 reactions(first: 100, content: HEART) 以及 reactions 的相关信息。 添加或取消某个评论上的点赞 添加 1234567mutation &#123; addReaction(input: &#123;subjectId: \"MDEyOklzc3VlQ29tbWVudDMxNTQxOTc2NQ==\", content: HEART&#125;) &#123; reaction &#123; content &#125; &#125;&#125; 取消 1234567mutation &#123; removeReaction(input: &#123;subjectId: \"MDEyOklzc3VlQ29tbWVudDMxNTQxOTc2NQ==\", content: HEART&#125;) &#123; reaction &#123; content &#125; &#125;&#125; 之前的都是查询，这两个是 mutation，分别调用了 addReaction 和 removeReaction。可以在从文档的 ROOT TYPE 上选择 Mutation 查看支持的所有 mutation。 以上主要介绍了 GraphQL 的基本使用，具体更多内容可以查看 GraphQL 提供的教程。","pubDate":"Fri, 15 Dec 2017 10:27:36 GMT","guid":"https://aotu.io/notes/2017/12/15/graphql-use/","category":"Web开发"}]}